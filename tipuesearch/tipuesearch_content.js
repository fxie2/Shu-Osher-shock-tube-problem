var tipuesearch = {"pages":[{"text":"Shu-Osher-shock-tube-problem Shu-Osher shock tube problem Regression results on Shu-Osher shock tube problem. Obtaining the code From you preferred terminal clone this repository: git clone  https://github.com/szaghi/Shu-Osher-shock-tube-problem Code documentation The code API is available at the project GitHub Pages . Compiling the code Use FoBiS . Inside the project run, type: FoBiS.py build Using the code From you preferred terminal type: ./build/euler-1D --Ni #cells_number --order #order_of_accuracy The order of accuracy must be chosen in [1, 3, 5, 7]. Regression test results The results are contained into results sub-directory inside the root of project. Using a coarse grid of 192 uniform cells and a fine one of 384 uniform cells, the results are summarized into the following figure. Developer Info Stefano Zaghi","tags":"","loc":"index.html","title":" Shu-Osher-shock-tube-problem "},{"text":"Test FOODIE with the integration of Euler 1D PDEs system. Source Code !< Test FOODIE with the integration of Euler 1D PDEs system. program integrate_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D , only : euler_1D use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : ls_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 7 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: Dt !< Time step. real ( R_P ) :: t !< Time. real ( R_P ) :: t_final !< Final time. type ( euler_1D ) :: domain !< Domain of Euler equations. integer ( I_P ) :: order !< Order of accuracy. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: steps !< Time steps counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call command_line_interface call init steps = 1 do while ( t < t_final ) if ( verbose ) print \"(A)\" , ' Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) Dt = domain % dt ( Nmax = 0_I_P , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt steps = steps + 1 call save_time_serie ( t = t ) enddo if ( verbose ) print \"(A)\" , ' Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) call finish stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine command_line_interface () !--------------------------------------------------------------------------------------------------------------------------------- !< Handle Command Line Interface. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. integer ( I_P ) :: error !< Error handler. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration' , & examples = [ \"euler-1D --results  \" , & \"euler-1D -r -t -v -p\" , & \"euler-1D            \" , & \"euler-1D --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--order' , help = 'Order of accuracy' , choices = '1,3,5,7' , required = . false ., act = 'store' , def = '1' , error = error ) call cli % add ( switch = '--t_final' , help = 'Final time of integration' , required = . false ., act = 'store' , def = '0.178d0' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , & def = '.false.' , error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--order' , val = order , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--t_final' , val = t_final , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine command_line_interface subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. real ( R_P ) :: rho_sin !< Sinusoidal density distribution. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 2.85_R_P Dx = 1._R_P / Ni do i = 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.12_R_P ) then initial_state (:, i ) = [ 3.857143_R_P , & ! rho(s) 2.629369_R_P , & ! u 1 0.33333_R_P , & ! p 3.857143_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else rho_sin = 1._R_P + 0.2_R_P * sin ( 8._R_P * x ( i ) * 2._R_P * pi ) initial_state (:, i ) = [ rho_sin , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p rho_sin , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = 'TRA' , BC_R = 'TRA' , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = order ) call save_time_serie ( title = 'Shu-Osher shock tube problem' , & filename = 'shu-osher-order-' // trim ( str (. true ., order )) // '-grid-' // trim ( str (. true ., Ni )) // '.dat' , & t = t ) t = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine finish () !--------------------------------------------------------------------------------------------------------------------------------- !< Peform after-success finishing operations. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'Shu-Osher shock tube problem' , & filename = 'shu-osher-order-' // trim ( str (. true ., order )) // '-grid-' // trim ( str (. true ., Ni ))) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finish subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D","tags":"","loc":"sourcefile/euler-1d.f90.html","title":"euler-1D.f90 – Shu-Osher-shock-tube-problem"},{"text":"Define Euler 1D field that is a concrete extension of the abstract integrand type. Source Code !< Define Euler 1D field that is a concrete extension of the abstract integrand type. module type_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: euler_1D !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !<||euler-euler||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! ADT integrand deferred methods function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F, PR) do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D :: dState_dt ) select type ( dState_dt ) class is ( euler_1D ) dState_dt = self endselect !$OMP PARALLEL PRIVATE(i) SHARED(self, dState_dt, F) select type ( dState_dt ) class is ( euler_1D ) !$OMP DO do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) error = 0._R_P do i = 1 , lhs % Ni do v = 1 , lhs % Nc error = error + ( lhs % U ( v , i ) - rhs % U ( v , i )) ** 2 / lhs % U ( v , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D ) select type ( rhs ) class is ( euler_1D ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) * rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) * rhs enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = rhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D ) !$OMP DO do i = 1 , rhs % Ni opr % U (:, i ) = rhs % U (:, i ) * lhs enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D ) select type ( rhs ) class is ( euler_1D ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) + rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D ) select type ( rhs ) class is ( euler_1D ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) - rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Nc , 1 : lhs % Ni )) endif if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) select type ( rhs ) class is ( euler_1D ) if ( allocated ( rhs % U )) then !$OMP DO do i = 1 , lhs % Ni lhs % U (:, i ) = rhs % U (:, i ) enddo endif endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) then !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) do i = 1 , lhs % Ni lhs % U (:, i ) = rhs enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real ! private methods pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- !$OMP PARALLEL PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) SHARED(self, primitive, r_primitive) select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction !$OMP DO do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction !$OMP DO do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect !$OMP END PARALLEL return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D","tags":"","loc":"sourcefile/type_euler-1d.f90.html","title":"type_euler-1D.f90 – Shu-Osher-shock-tube-problem"},{"text":"Define the abstract type integrand for building FOODIE ODE integrators. Source Code !< Define the abstract type *integrand* for building FOODIE ODE integrators. module foodie_adt_integrand !----------------------------------------------------------------------------------------------------------------------------------- !< Define the abstract type *integrand* for building FOODIE ODE integrators. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , abstract :: integrand !< Abstract type for building FOODIE ODE integrators. #ifdef CAF class ( * ), allocatable :: dummy_to_allow_extensions [:] !< Dummy member to allow concrete extensions with coarray members. #endif contains ! public deferred procedures that concrete integrand-field must implement procedure ( time_derivative ), pass ( self ), deferred , public :: t !< Time derivative, residuals. ! operators procedure ( local_error_operator ), pass ( lhs ), deferred , public :: local_error !< ||integrand - integrand||. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_multiply_integrand !< Integrand * integrand operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_multiply_real !< Integrand * real operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_multiply_integrand !< Real * integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: add !< Integrand + integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: sub !< Integrand - integrand operator. procedure ( assignment_integrand ), pass ( lhs ), deferred , public :: assign_integrand !< Integrand = integrand. ! operators overloading generic , public :: operator (. lterror .) => local_error !< Estimate local truncation error. generic , public :: operator ( + ) => add !< Overloading + operator. generic , public :: operator ( - ) => sub !< Overloading - operator. generic , public :: operator ( * ) => integrand_multiply_integrand , & real_multiply_integrand , & integrand_multiply_real !< Overloading * operator. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. endtype integrand abstract interface !< Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). function time_derivative ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative function of integrand class, i.e. the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( IN ) :: self !< Integrand field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Result of the time derivative function of integrand field. !--------------------------------------------------------------------------------------------------------------------------------- endfunction time_derivative function local_error_operator ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 solution approximations. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. !--------------------------------------------------------------------------------------------------------------------------------- endfunction local_error_operator function integrand_op_real ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric type operator integrand.op.real. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction integrand_op_real function real_op_integrand ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric type operator real.op.integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_op_integrand function symmetric_operator ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Symmetric type operator integrand.op.integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand class ( integrand ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction symmetric_operator subroutine assignment_integrand ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Symmetric assignment integrand = integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand class ( integrand ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assignment_integrand endinterface !----------------------------------------------------------------------------------------------------------------------------------- endmodule foodie_adt_integrand","tags":"","loc":"sourcefile/foodie_adt_integrand.f90.html","title":"foodie_adt_integrand.f90 – Shu-Osher-shock-tube-problem"},{"text":"FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. Source Code !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. module foodie_integrator_tvd_runge_kutta !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< The integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP) !< one. The schemes are explicit and defined through the Butcher's table syntax, see[1] . !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<  U&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta&#94;s K&#94;s  !< !< where Ns is the number of stages used and K&#94;s is the s&#94;{th} stage computed as: !< !<  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are !< given in the Butcher table form: !< !<``` !<  gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns} !<  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns} !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns} !< ------------|------------------------------------------------------------- !<             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} !<``` !< !< Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: !< !<``` !<  gamma&#94;1    | 0                 0                 ...        0 !<  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0 !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0 !< ------------|------------------------------------------------------------- !<             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} !<``` !< !< Moreover the following relation always holds: !<  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !<##### 1 stage, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. !<``` !<  0 | 0 !< ---|--- !<    | 1 !<``` !< !<##### 2 stages, SSP, 2nd order !< This scheme is an optmial SSP(2, 2) without low-storage algorithm, see [2]. !<``` !<  0 | 0     0 !<  1 | 1     0 !< ---|----------- !<    | 1/2   1/2 !<``` !< !<##### 3 stages, SSP, 3rd order !< This scheme is an optmial SSP(3, 3) without low-storage algorithm, see [2]. !<``` !<  0   | 0     0     0 !<  1   | 1     0     0 !<  1/2 | 1/4   1/4   0 !< -----|----------------- !<      | 1/6   1/6   1/3 !<``` !< !<##### 5 stages, SSP, 4th order !< This scheme is an optmial SSP(5, 4) without low-storage algorithm, see [2]. !<``` !<  0                | 0                  0                  0                  0                  0 !<  0.39175222700392 | 0.39175222700392   0                  0                  0                  0 !<  0.58607968896780 | 0.21766909633821   0.36841059262959   0                  0                  0 !<  0.47454236302687 | 0.08269208670950   0.13995850206999   0.25189177424738   0                  0 !<  0.93501063100924 | 0.06796628370320   0.11503469844438   0.20703489864929   0.54497475021237   0 !< ------------------|--------------------------------------------------------------------------------------------- !<                   | 0.14681187618661   0.24848290924556   0.10425883036650   0.27443890091960   0.22600748319395 !<``` !< !<#### Bibliography !< !< [1] *Coefficients for the study of Runge-Kutta integration processes*, Butcher, J.C., J. Austral. Math. Soc., Vol. 3, !< pages: 185--201, 1963. !< !< [2] *High Order Strong Stability Preserving Time Discretizations*, Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of !< Scientific Computing, vol. 38, N. 3, 2009, pp. 251-289. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P , I_P use foodie_adt_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: tvd_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! computing new time step do s = 1 , self % stages U = U + stage ( s ) * ( Dt * self % beta ( s )) enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_tvd_runge_kutta","tags":"","loc":"sourcefile/foodie_integrator_tvd_runge_kutta.f90.html","title":"foodie_integrator_tvd_runge_kutta.f90 – Shu-Osher-shock-tube-problem"},{"text":"FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. Source Code !< FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. module foodie_integrator_euler_explicit !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Forward Explicit Euler scheme implemented is: !< !<  U&#94;{n+1} = U&#94;n +\\Delta t R(t, U&#94;n)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P use foodie_adt_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_explicit_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: euler_explicit_integrator !< FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< @note The integrator can be used directly without any initialization. contains procedure , nopass , public :: integrate !< Integrate integrand field. endtype euler_explicit_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine integrate ( U , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit Euler scheme, 1st order. !--------------------------------------------------------------------------------------------------------------------------------- class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), optional , intent ( IN ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- U = U + U % t ( t = t ) * Dt return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate endmodule foodie_integrator_euler_explicit","tags":"","loc":"sourcefile/foodie_integrator_euler_explicit.f90.html","title":"foodie_integrator_euler_explicit.f90 – Shu-Osher-shock-tube-problem"},{"text":"FOODIE kinds: definition of reals and integer kind parameters of FOODIE library. Source Code !< FOODIE kinds: definition of reals and integer kind parameters of FOODIE library. module foodie_kinds !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE kinds: definition of reals and integer kind parameters of FOODIE library. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: R8P public :: R4P public :: R_P public :: I8P public :: I4P public :: I2P public :: I1P public :: I_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. !----------------------------------------------------------------------------------------------------------------------------------- endmodule foodie_kinds","tags":"","loc":"sourcefile/foodie_kinds.f90.html","title":"foodie_kinds.f90 – Shu-Osher-shock-tube-problem"},{"text":"FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Source Code !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. module foodie_integrator_leapfrog !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the leapfrog class scheme implemented (see [3]) is: !< !<  U&#94;{n+2} = U&#94;{n} + 2\\Delta t \\cdot R(t&#94;{n+1}, U&#94;{n+1})  !< !< Optionally, the Robert-Asselin-Williams (RAW) filter (see [3]) is applied to the computed integration steps: !<  \\Delta = \\frac{\\nu}{2}(U&#94;{n} - 2 U&#94;{n+1} + U&#94;{n+2})  !<  U&#94;{n+1} = U&#94;{n+1} + \\Delta * \\alpha  !<  U&#94;{n+2} = U&#94;{n+2} + \\Delta * (\\alpha-1)  !< Note that for \\alpha=1 the filter reverts back to the standard Robert-Asselin scheme. !< The filter coefficients should be taken as \\nu \\in (0,1] and \\alpha \\in (0.5,1]. The default values are !< !<  + \\nu=0.01 !<  + \\alpha=0.53 !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit. The filter coefficients \\nu,\\,\\alpha  define the actual scheme. !< !<#### Bibliography !< !< [1] *The integration of a low order spectral form of the primitive meteorological equations*, Robert, A. J., J. Meteor. Soc. !< Japan,vol. 44, pages 237--245, 1966. !< !< [2] *Frequency filter for time integrations*, Asselin, R., Monthly Weather Review, vol. 100, pages 487--490, 1972. !< !< [3] *The RAW filter: An improvement to the Robert–Asselin filter in semi-implicit integrations*, Williams, P.D., Monthly !< Weather Review, vol. 139(6), pages 1996--2007, June 2011. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P , I_P use foodie_adt_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: leapfrog_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: leapfrog_integrator !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. !< !< @note The integrator could be used without initialialization (initialize the time filter coefficients) if the defulat values !< are suitable for the problem. private real ( R_P ) :: nu = 0.01_R_P !< Robert-Asselin filter coefficient. real ( R_P ) :: alpha = 0.53_R_P !< Robert-Asselin-Williams filter coefficient. contains procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. endtype leapfrog_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , nu , alpha ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual leapfrog integrator: initialize the filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( INOUT ) :: self !< LF integrator. real ( R_P ), optional , intent ( IN ) :: nu !< Williams-Robert-Asselin filter coefficient. real ( R_P ), optional , intent ( IN ) :: alpha !< Robert-Asselin filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % nu = 0.01_R_P self % alpha = 0.53_R_P if ( present ( nu )) self % nu = nu if ( present ( alpha )) self % alpha = alpha return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine integrate ( self , U , previous , Dt , t , filter ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with leapfrog class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( IN ) :: self !< LF integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 : 2 ) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. class ( integrand ), optional , intent ( INOUT ) :: filter !< Filter field displacement. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- U = previous ( 1 ) + previous ( 2 )% t ( t = t ) * ( Dt * 2._R_P ) if ( present ( filter )) then filter = ( previous ( 1 ) - previous ( 2 ) * 2._R_P + U ) * self % nu * 0.5_R_P previous ( 2 ) = previous ( 2 ) + filter * self % alpha U = U + filter * ( self % alpha - 1._R_P ) endif previous ( 1 ) = previous ( 2 ) previous ( 2 ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate endmodule foodie_integrator_leapfrog","tags":"","loc":"sourcefile/foodie_integrator_leapfrog.f90.html","title":"foodie_integrator_leapfrog.f90 – Shu-Osher-shock-tube-problem"},{"text":"FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 4rd order accurate. Source Code !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 4rd order accurate. module foodie_integrator_adams_bashforth !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 4rd order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Bashforth class scheme implemented is: !< !<  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s}{ b_s \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  !< !<where N_s is the number of previous steps considered. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit. The coefficients b_s define the actual scheme, that is selected accordingly to the number of !< **steps** used. !< !< Currently, the following schemes are available: !<##### 1 step, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. !< The *b* coefficient is: !< b = \\left[b_1\\right] = \\left[1\\right] !< The scheme is: !<  U&#94;{n+1} = U&#94;n + \\Delta t R(t&#94;n,U&#94;n)  !< !<##### 2 steps !< This scheme is 2nd order. !< The *b* coefficients are: !< b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] = !<       \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+2} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right]  !< !<##### 3 steps !< This scheme is 3rd order. !< The *b* coefficients are: !< b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] = !<       \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+3} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1}) !< +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right]  !< !<##### 4 steps !< This scheme is 4th order. !< The *b* coefficients are: !< b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 & b_4 \\end{array}} \\right] = !<       \\left[ {\\begin{array}{*{20}{c}} -\\frac{9}{24} & \\frac{37}{24} & -\\frac{59}{24} & \\frac{55}{24} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+4} = U&#94;{n+3} +\\Delta t \\left[ \\frac{55}{24}R(t&#94;{n+3}, U&#94;{n+3}) - \\frac{59}{24}R(t&#94;{n+2}, U&#94;{n+2}) !< +\\frac{37}{24} R(t&#94;{n+1}, U&#94;{n+1}) - \\frac{9}{24} R(t&#94;{n}, U&#94;{n}) \\right]  !< !<#### Bibliography !< !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P , I_P use foodie_adt_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: adams_bashforth_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: adams_bashforth_integrator !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 4rd order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. private integer ( I_P ) :: steps = 0 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< b coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. final :: finalize !< Finalize object. endtype adams_bashforth_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 1 : steps )) ; self % b = 0._R_P select case ( steps ) case ( 1 ) ! AB(1) Forward-Euler self % b ( 1 ) = 1._R_P case ( 2 ) ! AB(2) self % b ( 1 ) = - 0.5_R_P self % b ( 2 ) = 1.5_R_P case ( 3 ) ! AB(3) self % b ( 1 ) = 5._R_P / 1 2._R_P self % b ( 2 ) = - 4._R_P / 3._R_P self % b ( 3 ) = 2 3._R_P / 1 2._R_P case ( 4 ) ! AB(4) self % b ( 1 ) = - 3._R_P / 8._R_P self % b ( 2 ) = 3 7._R_P / 2 4._R_P self % b ( 3 ) = - 5 9._R_P / 2 4._R_P self % b ( 4 ) = 5 5._R_P / 2 4._R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 if ( allocated ( self % b )) deallocate ( self % b ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , previous , Dt , t , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate do s = 1 , self % steps U = U + previous ( s )% t ( t = t ( s )) * ( Dt * self % b ( s )) enddo if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do s = 1 , self % steps - 1 previous ( s ) = previous ( s + 1 ) enddo previous ( self % steps ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_adams_bashforth","tags":"","loc":"sourcefile/foodie_integrator_adams_bashforth.f90.html","title":"foodie_integrator_adams_bashforth.f90 – Shu-Osher-shock-tube-problem"},{"text":"FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 4rd order accurate. Source Code !< FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 4rd order accurate. module foodie_integrator_adams_moulton !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 4rd order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Moulton class scheme implemented is: !< !<  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s-1}{ b_s \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } + !< b_{N_S}\\cdot R(t&#94;{n+N_s}, U&#94;{n+N_s}) \\right]  !< !<where N_s is the number of previous steps considered. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are implicit. The coefficients b_s define the actual scheme, that is selected accordingly to the number of !< **steps** used. !< !< Currently, the following schemes are available: !<##### 0 step, Implicit Backward Euler, 1st order !< This scheme is TVD and reverts to Implicit Backward Euler, it being 1st order. !< The *b* coefficient is: !< b = \\left[b_0\\right] = \\left[1\\right] !< The scheme is: !<  U&#94;{n} = U&#94;{n-1} + \\Delta t R(t&#94;{n},U&#94;{n})  !< !<##### 1 step !< This scheme is 2nd order. !< The *b* coefficients are: !< b = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 \\end{array}} \\right] = !<       \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2} & \\frac{1}{2} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+1} = U&#94;{n} +\\Delta t \\left[ \\frac{1}{2} R(t&#94;{n+1}, U&#94;{n+1})+\\frac{1}{2} R(t&#94;{n}, U&#94;{n}) \\right]  !< !<##### 2 steps !< This scheme is 3rd order. !< The *b* coefficients are: !< b = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 \\end{array}} \\right] = !<       \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{12} & \\frac{2}{3} & \\frac{5}{12} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+2} = U&#94;{n+1} +\\Delta t \\left[ \\frac{5}{12}R(t&#94;{n+2}, U&#94;{n+2}) + \\frac{2}{3}R(t&#94;{n+1}, U&#94;{n+1}) !< -\\frac{1}{12} R(t&#94;{n}, U&#94;{n})  \\right]  !< !<##### 3 steps !< This scheme is 4th order. !< The *b* coefficients are: !< b = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 & b_3 \\end{array}} \\right] = !<       \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{24} & -\\frac{5}{24} & \\frac{19}{24} & \\frac{9}{24} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+3} = U&#94;{n+2} +\\Delta t \\left[ \\frac{9}{24}R(t&#94;{n+3}, U&#94;{n+3}) + \\frac{19}{24}R(t&#94;{n+2}, U&#94;{n+2}) !< -\\frac{5}{24} R(t&#94;{n+1}, U&#94;{n+1}) + \\frac{1}{24} R(t&#94;{n}, U&#94;{n}) \\right]  !< !<#### Bibliography !< !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P , I_P use foodie_adt_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: adams_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: adams_moulton_integrator !< FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 3rd order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. private integer ( I_P ) :: steps =- 1 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< b coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. final :: finalize !< Finalize object. endtype adams_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Moulton integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 0 : steps )) ; self % b = 0._R_P select case ( steps ) case ( 0 ) ! AM(0) Bacward-Euler self % b ( 0 ) = 1._R_P case ( 1 ) ! AM(1) self % b ( 0 ) = 0.5_R_P self % b ( 1 ) = 0.5_R_P case ( 2 ) ! AM(2) self % b ( 0 ) = - 1._R_P / 1 2._R_P self % b ( 1 ) = 2._R_P / 3._R_P self % b ( 2 ) = 5._R_P / 1 2._R_P case ( 3 ) ! AM(3) self % b ( 0 ) = 1._R_P / 2 4._R_P self % b ( 1 ) = - 5._R_P / 2 4._R_P self % b ( 2 ) = 1 9._R_P / 2 4._R_P self % b ( 3 ) = 3._R_P / 8._R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = - 1 if ( allocated ( self % b )) deallocate ( self % b ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , previous , Dt , t , iterations , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Moulton class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. class ( integrand ), allocatable :: delta !< Delta RHS for fixex point iterations. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate if ( self % steps > 0 ) then if ( present ( iterations )) then ! perform fixed point iterations allocate ( delta , source = previous ( self % steps )) do s = 0 , self % steps - 1 delta = delta + previous ( s + 1 )% t ( t = t ( s + 1 )) * ( Dt * self % b ( s )) enddo do s = 1 , iterations U = delta + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps )) enddo else U = previous ( self % steps ) + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps )) do s = 0 , self % steps - 1 U = U + previous ( s + 1 )% t ( t = t ( s + 1 )) * ( Dt * self % b ( s )) enddo endif if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) else U = U + U % t ( t = t ( 1 )) * ( Dt * self % b ( 0 )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 0 , self % steps - 2 previous ( s + 1 ) = previous ( s + 2 ) enddo previous ( self % steps ) = U endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_adams_moulton","tags":"","loc":"sourcefile/foodie_integrator_adams_moulton.f90.html","title":"foodie_integrator_adams_moulton.f90 – Shu-Osher-shock-tube-problem"},{"text":"FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. Source Code !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. module foodie_integrator_low_storage_runge_kutta !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< The integrators provided have the low storage property allowing for an efficient use of the memory. !< Following Williamson approach [1], the LSRK(5,4)2N (solution 3) scheme of Carpenter et al. [2] is implemented. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<\\begin{matrix} !< K_1 = U&#94;n \\\\ !< K_2 = 0 \\\\ !<\\left.\\begin{matrix} !< K_2 = A_s K_2 + \\Delta t R(t&#94;n + C_s \\Delta t, K_1) \\\\ !< K_1 = K_1 + B_s K_2 !<\\end{matrix}\\right\\} s=1,2,...N_s\\\\ !<U&#94;{n+1} = K_1 !<\\end{matrix} !< !< where *Ns* is the number of stages used and K_1, K_2 are the 2 registers used for stages computation. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus A_1=C_1=0. The coefficients A_s, B_s, C_s are given in the Williamson low storage table !< form. !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !<#### 1 stage, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. It is not a real low storage scheme, this being !< meaningless for a first order scheme. However it is added for safety reason. !< !< | ` Stage ` | ` A ` | ` B ` | ` C ` | !< |-----------|-------|-------|-------| !< | ` 1 `     | ` 0 ` | ` 1 ` | ` 0 ` | !< !<#### 5 stages, SSP, 4th order !< This scheme is a low storage RK(5, 4), based on the *solution 3* proposed in [2]. !< !< | ` Stage ` | ` A `                            | ` B `                            | ` C `                           | !< |-----------|----------------------------------|----------------------------------|---------------------------------| !< | ` 1 `     | `  0                           ` | ` 1432997174477/9575080441755  ` | ` 0                           ` | !< | ` 2 `     | ` -567301805773 /1357537059087 ` | ` 5161836677717/13612068292357 ` | ` 1432997174477/9575080441755 ` | !< | ` 3 `     | ` -2404267990393/2016746695238 ` | ` 1720146321549/2090206949498  ` | ` 2526269341429/6820363962896 ` | !< | ` 4 `     | ` -3550918686646/2091501179385 ` | ` 3134564353537/4481467310338  ` | ` 2006345519317/3224310063776 ` | !< | ` 5 `     | ` -1275806237668/842570457699  ` | ` 2277821191437/14882151754819 ` | ` 2802321613138/2924317926251 ` | !< !< !<#### 6 stages, 4th order !< This scheme is a low storage RK(6, 4), by [3]. !< !< | ` Stage ` | ` A `               | ` B `              | ` C `              | !< |-----------|---------------------|--------------------|--------------------| !< | ` 1 `     | `  0              ` | ` 0.122000000000 ` | ` 0              ` | !< | ` 2 `     | ` -0.691750960670 ` | ` 0.477263056358 ` | ` 0.122000000000 ` | !< | ` 3 `     | ` -1.727127405211 ` | ` 0.381941220320 ` | ` 0.269115878630 ` | !< | ` 4 `     | ` -0.694890150986 ` | ` 0.447757195744 ` | ` 0.447717183551 ` | !< | ` 5 `     | ` -1.039942756197 ` | ` 0.498614246822 ` | ` 0.749979795490 ` | !< | ` 6 `     | ` -1.531977447611 ` | ` 0.186648570846 ` | ` 0.898555413085 ` | !< !<#### 7 stages, 4th order !< This scheme is a low storage RK(7, 4), by [3]. !< !< | ` Stage ` | ` A `               | ` B `              | ` C `              | !< |-----------|---------------------|--------------------|--------------------| !< | ` 1 `     | `  0              ` | ` 0.117322146869 ` | ` 0              ` | !< | ` 2 `     | ` -0.647900745934 ` | ` 0.503270262127 ` | ` 0.117322146869 ` | !< | ` 3 `     | ` -2.704760863204 ` | ` 0.233663281658 ` | ` 0.294523230758 ` | !< | ` 4 `     | ` -0.460080550118 ` | ` 0.283419634625 ` | ` 0.305658622131 ` | !< | ` 5 `     | ` -0.500581787785 ` | ` 0.540367414023 ` | ` 0.582864148403 ` | !< | ` 6 `     | ` -1.906532255913 ` | ` 0.371499414620 ` | ` 0.858664273599 ` | !< | ` 7 `     | ` -1.450000000000 ` | ` 0.136670099385 ` | ` 0.868664273599 ` | !< !<#### 12 stages, 4th order !< This scheme is a low storage RK(12, 4), by [4]. !< !< | ` Stage ` | ` A `                   | ` B `                  | ` C `                  | !< |-----------|-------------------------|------------------------|------------------------| !< | ` 1  `    | `  0                  ` | ` 0.0650008435125904 ` | ` 0                  ` | !< | ` 2  `    | ` -0.0923311242368072 ` | ` 0.0161459902249842 ` | ` 0.0650008435125904 ` | !< | ` 3  `    | ` -0.9441056581158819 ` | ` 0.5758627178358159 ` | ` 0.0796560563081853 ` | !< | ` 4  `    | ` -4.3271273247576394 ` | ` 0.1649758848361671 ` | ` 0.1620416710085376 ` | !< | ` 5  `    | ` -2.1557771329026072 ` | ` 0.3934619494248182 ` | ` 0.2248877362907778 ` | !< | ` 6  `    | ` -0.9770727190189062 ` | ` 0.0443509641602719 ` | ` 0.2952293985641261 ` | !< | ` 7  `    | ` -0.7581835342571139 ` | ` 0.2074504268408778 ` | ` 0.3318332506149405 ` | !< | ` 8  `    | ` -1.7977525470825499 ` | ` 0.6914247433015102 ` | ` 0.4094724050198658 ` | !< | ` 9  `    | ` -2.6915667972700770 ` | ` 0.3766646883450449 ` | ` 0.6356954475753369 ` | !< | ` 10 `    | ` -4.6466798960268143 ` | ` 0.0757190350155483 ` | ` 0.6806551557645497 ` | !< | ` 11 `    | ` -0.1539613783825189 ` | ` 0.2027862031054088 ` | ` 0.7143773712418350 ` | !< | ` 12 `    | ` -0.5943293901830616 ` | ` 0.2167029365631842 ` | ` 0.9032588871651854 ` | !< !<#### 13 stages, 4th order !< This scheme is a low storage RK(13, 4), by [4]. !< !< | ` Stage ` | ` A `                   | ` B `                  | ` C `                  | !< |-----------|-------------------------|------------------------|------------------------| !< | ` 1  `    | `  0                  ` | ` 0.0271990297818803 ` | ` 0                  ` | !< | ` 2  `    | ` -0.6160178650170565 ` | ` 0.1772488819905108 ` | ` 0.0271990297818803 ` | !< | ` 3  `    | ` -0.4449487060774118 ` | ` 0.0378528418949694 ` | ` 0.0952594339119365 ` | !< | ` 4  `    | ` -1.0952033345276178 ` | ` 0.6086431830142991 ` | ` 0.1266450286591127 ` | !< | ` 5  `    | ` -1.2256030785959187 ` | ` 0.2154313974316100 ` | ` 0.1825883045699772 ` | !< | ` 6  `    | ` -0.2740182222332805 ` | ` 0.2066152563885843 ` | ` 0.3737511439063931 ` | !< | ` 7  `    | ` -0.0411952089052647 ` | ` 0.0415864076069797 ` | ` 0.5301279418422206 ` | !< | ` 8  `    | ` -0.1797084899153560 ` | ` 0.0219891884310925 ` | ` 0.5704177433952291 ` | !< | ` 9  `    | ` -1.1771530652064288 ` | ` 0.9893081222650993 ` | ` 0.5885784947099155 ` | !< | ` 10 `    | ` -0.4078831463120878 ` | ` 0.0063199019859826 ` | ` 0.6160769826246714 ` | !< | ` 11 `    | ` -0.8295636426191777 ` | ` 0.3749640721105318 ` | ` 0.6223252334314046 ` | !< | ` 12 `    | ` -4.7895970584252288 ` | ` 1.6080235151003195 ` | ` 0.6897593128753419 ` | !< | ` 13 `    | ` -0.6606671432964504 ` | ` 0.0961209123818189 ` | ` 0.9126827615920843 ` | !< !<#### 14 stages, 4th order !< This scheme is a low storage RK(14, 4), by [4]. !< !< | ` Stage ` | ` A `                   | ` B `                  | ` C `                  | !< |-----------|-------------------------|------------------------|------------------------| !< | ` 1  `    | `  0                  ` | ` 0.0367762454319673 ` | ` 0                  ` | !< | ` 2  `    | ` -0.7188012108672410 ` | ` 0.3136296607553959 ` | ` 0.0367762454319673 ` | !< | ` 3  `    | ` -0.7785331173421570 ` | ` 0.1531848691869027 ` | ` 0.1249685262725025 ` | !< | ` 4  `    | ` -0.0053282796654044 ` | ` 0.0030097086818182 ` | ` 0.2446177702277698 ` | !< | ` 5  `    | ` -0.8552979934029281 ` | ` 0.3326293790646110 ` | ` 0.2476149531070420 ` | !< | ` 6  `    | ` -3.9564138245774565 ` | ` 0.2440251405350864 ` | ` 0.2969311120382472 ` | !< | ` 7  `    | ` -1.5780575380587385 ` | ` 0.3718879239592277 ` | ` 0.3978149645802642 ` | !< | ` 8  `    | ` -2.0837094552574054 ` | ` 0.6204126221582444 ` | ` 0.5270854589440328 ` | !< | ` 9  `    | ` -0.7483334182761610 ` | ` 0.1524043173028741 ` | ` 0.6981269994175695 ` | !< | ` 10 `    | ` -0.7032861106563359 ` | ` 0.0760894927419266 ` | ` 0.8190890835352128 ` | !< | ` 11 `    | `  0.0013917096117681 ` | ` 0.0077604214040978 ` | ` 0.8527059887098624 ` | !< | ` 12 `    | ` -0.0932075369637460 ` | ` 0.0024647284755382 ` | ` 0.8604711817462826 ` | !< | ` 13 `    | ` -0.9514200470875948 ` | ` 0.0780348340049386 ` | ` 0.8627060376969976 ` | !< | ` 14 `    | ` -7.1151571693922548 ` | ` 5.5059777270269628 ` | ` 0.8734213127600976 ` | !< !<#### Bibliography !< !< [1] *Low-Storage Runge-Kutta Schemes*, J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48--56. !< !< [2] *Fourth-Order 2N-Storage Runge-Kutta Schemes*, Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112, !< June 1994. !< !< [3] *High-accuracy large-step explicit Runge–Kutta (HALE-RK) schemes for computational aeroacoustics*, Vasanth Allampalli and !< Ray Hixon and M. Nallasamy and Scott D. Sawyer, Journal of Computational Physics, vol. 228, 2009, pp. 3837--3850. !< !< [4] *Efficient low-storage Runge–Kutta schemes with optimized stability regions*, Jens Niegemann and Richard Diehl and Kurt !< Busch, Journal of Computational Physics, vol. 231, 2012, pp. 364--372. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: ISO_FORTRAN_ENV , only : stderr => ERROR_UNIT use foodie_kinds , only : R_P , I_P , I8P use foodie_adt_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: ls_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: ls_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: A (:) !< Low storage *A* coefficients. real ( R_P ), allocatable :: B (:) !< Low storage *B* coefficients. real ( R_P ), allocatable :: C (:) !< Low storage *C* coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype ls_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' low storage table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % A )) deallocate ( self % A ) ; allocate ( self % A ( 1 : stages )) ; self % A = 0._R_P if ( allocated ( self % B )) deallocate ( self % B ) ; allocate ( self % B ( 1 : stages )) ; self % B = 0._R_P if ( allocated ( self % C )) deallocate ( self % C ) ; allocate ( self % C ( 1 : stages )) ; self % C = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % B ( 1 ) = 1._R_P case ( 5 ) ! LSRK(5,4) self % A ( 1 ) = 0._R_P self % A ( 2 ) = - real ( 567301805773_I8P , kind = R_P ) / real ( 1357537059087_I8P , kind = R_P ) self % A ( 3 ) = - real ( 2404267990393_I8P , kind = R_P ) / real ( 2016746695238_I8P , kind = R_P ) self % A ( 4 ) = - real ( 3550918686646_I8P , kind = R_P ) / real ( 2091501179385_I8P , kind = R_P ) self % A ( 5 ) = - real ( 1275806237668_I8P , kind = R_P ) / real ( 842570457699_I8P , kind = R_P ) self % B ( 1 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % B ( 2 ) = real ( 5161836677717_I8P , kind = R_P ) / real ( 13612068292357_I8P , kind = R_P ) self % B ( 3 ) = real ( 1720146321549_I8P , kind = R_P ) / real ( 2090206949498_I8P , kind = R_P ) self % B ( 4 ) = real ( 3134564353537_I8P , kind = R_P ) / real ( 4481467310338_I8P , kind = R_P ) self % B ( 5 ) = real ( 2277821191437_I8P , kind = R_P ) / real ( 14882151754819_I8P , kind = R_P ) self % C ( 1 ) = 0._R_P self % C ( 2 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % C ( 3 ) = real ( 2526269341429_I8P , kind = R_P ) / real ( 6820363962896_I8P , kind = R_P ) self % C ( 4 ) = real ( 2006345519317_I8P , kind = R_P ) / real ( 3224310063776_I8P , kind = R_P ) self % C ( 5 ) = real ( 2802321613138_I8P , kind = R_P ) / real ( 2924317926251_I8P , kind = R_P ) case ( 6 ) ! LSRK(6,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.122000000000_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.691750960670_R_P ; self % B ( 2 ) = 0.477263056358_R_P ; self % C ( 2 ) = 0.122000000000_R_P self % A ( 3 ) = - 1.727127405211_R_P ; self % B ( 3 ) = 0.381941220320_R_P ; self % C ( 3 ) = 0.269115878630_R_P self % A ( 4 ) = - 0.694890150986_R_P ; self % B ( 4 ) = 0.447757195744_R_P ; self % C ( 4 ) = 0.447717183551_R_P self % A ( 5 ) = - 1.039942756197_R_P ; self % B ( 5 ) = 0.498614246822_R_P ; self % C ( 5 ) = 0.749979795490_R_P self % A ( 6 ) = - 1.531977447611_R_P ; self % B ( 6 ) = 0.186648570846_R_P ; self % C ( 6 ) = 0.898555413085_R_P case ( 7 ) ! LSRK(7,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.117322146869_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.647900745934_R_P ; self % B ( 2 ) = 0.503270262127_R_P ; self % C ( 2 ) = 0.117322146869_R_P self % A ( 3 ) = - 2.704760863204_R_P ; self % B ( 3 ) = 0.233663281658_R_P ; self % C ( 3 ) = 0.294523230758_R_P self % A ( 4 ) = - 0.460080550118_R_P ; self % B ( 4 ) = 0.283419634625_R_P ; self % C ( 4 ) = 0.305658622131_R_P self % A ( 5 ) = - 0.500581787785_R_P ; self % B ( 5 ) = 0.540367414023_R_P ; self % C ( 5 ) = 0.582864148403_R_P self % A ( 6 ) = - 1.906532255913_R_P ; self % B ( 6 ) = 0.371499414620_R_P ; self % C ( 6 ) = 0.858664273599_R_P self % A ( 7 ) = - 1.450000000000_R_P ; self % B ( 7 ) = 0.136670099385_R_P ; self % C ( 7 ) = 0.868664273599_R_P case ( 12 ) ! LSRK(12,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0650008435125904_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.0923311242368072_R_P ; self % B ( 2 ) = 0.0161459902249842_R_P ; self % C ( 2 ) = 0.0650008435125904_R_P self % A ( 3 ) = - 0.9441056581158819_R_P ; self % B ( 3 ) = 0.5758627178358159_R_P ; self % C ( 3 ) = 0.0796560563081853_R_P self % A ( 4 ) = - 4.3271273247576394_R_P ; self % B ( 4 ) = 0.1649758848361671_R_P ; self % C ( 4 ) = 0.1620416710085376_R_P self % A ( 5 ) = - 2.1557771329026072_R_P ; self % B ( 5 ) = 0.3934619494248182_R_P ; self % C ( 5 ) = 0.2248877362907778_R_P self % A ( 6 ) = - 0.9770727190189062_R_P ; self % B ( 6 ) = 0.0443509641602719_R_P ; self % C ( 6 ) = 0.2952293985641261_R_P self % A ( 7 ) = - 0.7581835342571139_R_P ; self % B ( 7 ) = 0.2074504268408778_R_P ; self % C ( 7 ) = 0.3318332506149405_R_P self % A ( 8 ) = - 1.7977525470825499_R_P ; self % B ( 8 ) = 0.6914247433015102_R_P ; self % C ( 8 ) = 0.4094724050198658_R_P self % A ( 9 ) = - 2.6915667972700770_R_P ; self % B ( 9 ) = 0.3766646883450449_R_P ; self % C ( 9 ) = 0.6356954475753369_R_P self % A ( 10 ) = - 4.6466798960268143_R_P ; self % B ( 10 ) = 0.0757190350155483_R_P ; self % C ( 10 ) = 0.6806551557645497_R_P self % A ( 11 ) = - 0.1539613783825189_R_P ; self % B ( 11 ) = 0.2027862031054088_R_P ; self % C ( 11 ) = 0.7143773712418350_R_P self % A ( 12 ) = - 0.5943293901830616_R_P ; self % B ( 12 ) = 0.2167029365631842_R_P ; self % C ( 12 ) = 0.9032588871651854_R_P case ( 13 ) ! LSRK(13,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0271990297818803_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.6160178650170565_R_P ; self % B ( 2 ) = 0.1772488819905108_R_P ; self % C ( 2 ) = 0.0271990297818803_R_P self % A ( 3 ) = - 0.4449487060774118_R_P ; self % B ( 3 ) = 0.0378528418949694_R_P ; self % C ( 3 ) = 0.0952594339119365_R_P self % A ( 4 ) = - 1.0952033345276178_R_P ; self % B ( 4 ) = 0.6086431830142991_R_P ; self % C ( 4 ) = 0.1266450286591127_R_P self % A ( 5 ) = - 1.2256030785959187_R_P ; self % B ( 5 ) = 0.2154313974316100_R_P ; self % C ( 5 ) = 0.1825883045699772_R_P self % A ( 6 ) = - 0.2740182222332805_R_P ; self % B ( 6 ) = 0.2066152563885843_R_P ; self % C ( 6 ) = 0.3737511439063931_R_P self % A ( 7 ) = - 0.0411952089052647_R_P ; self % B ( 7 ) = 0.0415864076069797_R_P ; self % C ( 7 ) = 0.5301279418422206_R_P self % A ( 8 ) = - 0.1797084899153560_R_P ; self % B ( 8 ) = 0.0219891884310925_R_P ; self % C ( 8 ) = 0.5704177433952291_R_P self % A ( 9 ) = - 1.1771530652064288_R_P ; self % B ( 9 ) = 0.9893081222650993_R_P ; self % C ( 9 ) = 0.5885784947099155_R_P self % A ( 10 ) = - 0.4078831463120878_R_P ; self % B ( 10 ) = 0.0063199019859826_R_P ; self % C ( 10 ) = 0.6160769826246714_R_P self % A ( 11 ) = - 0.8295636426191777_R_P ; self % B ( 11 ) = 0.3749640721105318_R_P ; self % C ( 11 ) = 0.6223252334314046_R_P self % A ( 12 ) = - 4.7895970584252288_R_P ; self % B ( 12 ) = 1.6080235151003195_R_P ; self % C ( 12 ) = 0.6897593128753419_R_P self % A ( 13 ) = - 0.6606671432964504_R_P ; self % B ( 13 ) = 0.0961209123818189_R_P ; self % C ( 13 ) = 0.9126827615920843_R_P case ( 14 ) ! LSRK(14,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0367762454319673_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.7188012108672410_R_P ; self % B ( 2 ) = 0.3136296607553959_R_P ; self % C ( 2 ) = 0.0367762454319673_R_P self % A ( 3 ) = - 0.7785331173421570_R_P ; self % B ( 3 ) = 0.1531848691869027_R_P ; self % C ( 3 ) = 0.1249685262725025_R_P self % A ( 4 ) = - 0.0053282796654044_R_P ; self % B ( 4 ) = 0.0030097086818182_R_P ; self % C ( 4 ) = 0.2446177702277698_R_P self % A ( 5 ) = - 0.8552979934029281_R_P ; self % B ( 5 ) = 0.3326293790646110_R_P ; self % C ( 5 ) = 0.2476149531070420_R_P self % A ( 6 ) = - 3.9564138245774565_R_P ; self % B ( 6 ) = 0.2440251405350864_R_P ; self % C ( 6 ) = 0.2969311120382472_R_P self % A ( 7 ) = - 1.5780575380587385_R_P ; self % B ( 7 ) = 0.3718879239592277_R_P ; self % C ( 7 ) = 0.3978149645802642_R_P self % A ( 8 ) = - 2.0837094552574054_R_P ; self % B ( 8 ) = 0.6204126221582444_R_P ; self % C ( 8 ) = 0.5270854589440328_R_P self % A ( 9 ) = - 0.7483334182761610_R_P ; self % B ( 9 ) = 0.1524043173028741_R_P ; self % C ( 9 ) = 0.6981269994175695_R_P self % A ( 10 ) = - 0.7032861106563359_R_P ; self % B ( 10 ) = 0.0760894927419266_R_P ; self % C ( 10 ) = 0.8190890835352128_R_P self % A ( 11 ) = 0.0013917096117681_R_P ; self % B ( 11 ) = 0.0077604214040978_R_P ; self % C ( 11 ) = 0.8527059887098624_R_P self % A ( 12 ) = - 0.0932075369637460_R_P ; self % B ( 12 ) = 0.0024647284755382_R_P ; self % C ( 12 ) = 0.8604711817462826_R_P self % A ( 13 ) = - 0.9514200470875948_R_P ; self % B ( 13 ) = 0.0780348340049386_R_P ; self % C ( 13 ) = 0.8627060376969976_R_P self % A ( 14 ) = - 7.1151571693922548_R_P ; self % B ( 14 ) = 5.5059777270269628_R_P ; self % C ( 14 ) = 0.8734213127600976_R_P case default write ( stderr , '(A,I3,A)' ) ' Error: ls_runge_kutta_integrator%init: ' , stages , ' is an invalid number-of-stages!' write ( stderr , '(A)' ) ' Valid number of stages are:' write ( stderr , '(A)' ) '   1  => LSRK(1, 1)' write ( stderr , '(A)' ) '   5  => LSRK(5, 4)' write ( stderr , '(A)' ) '   6  => LSRK(6, 4)' write ( stderr , '(A)' ) '   7  => LSRK(7, 4)' write ( stderr , '(A)' ) '   12 => LSRK(12, 4)' write ( stderr , '(A)' ) '   13 => LSRK(13, 4)' write ( stderr , '(A)' ) '   14 => LSRK(14, 4)' endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % A )) deallocate ( self % A ) if ( allocated ( self % B )) deallocate ( self % B ) if ( allocated ( self % C )) deallocate ( self % C ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit low storage Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 : 2 ) !< Runge-Kutta registers [1:2]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages stage ( 1 ) = U stage ( 2 ) = U * 0._R_P do s = 1 , self % stages stage ( 2 ) = stage ( 2 ) * self % A ( s ) + stage ( 1 )% t ( t = t + self % C ( s ) * Dt ) * Dt stage ( 1 ) = stage ( 1 ) + stage ( 2 ) * self % B ( s ) enddo U = stage ( 1 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_low_storage_runge_kutta","tags":"","loc":"sourcefile/foodie_integrator_low_storage_runge_kutta.f90.html","title":"foodie_integrator_low_storage_runge_kutta.f90 – Shu-Osher-shock-tube-problem"},{"text":"FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. Source Code !< FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. module foodie !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. !< !< FOODIE is a KISS library for solving systems of Ordinary Differential Equation (ODE) into the Initial Values Problems (IVP) !< contest. The mathematical formulation of the problem is: !< !< U_t = R(t,U) !< U_0 = F(0) !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function and *F* is the (vectorial) initial conditions function. !< !< FOODIE is aimed to the time-like integration of the above system of ODE. To this aim, different numerical schemes are provided: !< !<+ *explicit Adams-Bashforth* class of schemes: !<    + 1 step, namely the explicit forward Euler scheme, 1st order accurate; !<    + 2 steps, 2nd order accurate; !<    + 3 steps, 3rd order accurate; !<    + 4 steps, 4th order accurate; !<+ *forward explicit Euler* scheme, a 1st order accurate; !<+ *explicit Leapfrog*: !<    + Unfiltered, 2nd order accurate, (mostly) unstable; !<    + Robert-Asselin filtered, 1st order accurate; !<    + Robert-Asselin-Williams filter, 2nd order accurate; !<+ *explicit low storage Runge-Kutta 2N* class schemes: !<    + LS(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; !<    + LS(5,4): 5 stages, 4th order accurate; !<+ *explicit TVD or SSP Runge-Kutta* class schemes: !<    + TVD(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; !<    + SSP(2,2): 2 stages, 2nd order accurate; !<    + SSP(3,3): 3 stages, 3rd order accurate; !<    + SSP(5,4): 5 stages, 4th order accurate; !<+ *explicit embedded Runge-Kutta* class schemes: !<    + DP(7,4): 7 stages, 4th order accurate, Dormand and Prince scheme; !<+ *implicit Adams-Moulton* class of schemes: !<    + 0 step, namely the implicit backward Euler scheme, 1st order accurate; !<    + 1 step, 2nd order accurate; !<    + 2 steps, 3rd order accurate; !<    + 3 steps, 4th order accurate; !<+ *predictor-corrector Adams-Bashforth-Moulton* class of schemes: !<    + P=AB(1)-C=AM(0) step, namely the explicit/implicit forward/backward Euler scheme, 1st order accurate; !<    + P=AB(2)-C=AM(1) step, 2nd order accurate; !<    + P=AB(3)-C=AM(2) steps, 3rd order accurate; !<    + P=AB(4)-C=AM(3) steps, 4th order accurate; !< !<### Usage !< !< FOODIE schemes must be applied to only subclass extensions of the abstract class *integrand*. !< !< To use FOODIE you must: !< !<#### extend integrand abstract class provided by FOODIE implementing your concrete integrand field !< !< For example for the Lorenz' ODE system !< !<```fortran !< type, extends(integrand) :: lorenz !<   !< Lorenz equations field. !<   !< !<   !< It is a FOODIE integrand class. !<   private !<   real(R_P), dimension(:), allocatable :: state        !< Solution vector. !<   real(R_P)                            :: sigma=0._R_P !< Lorenz \\sigma. !<   real(R_P)                            :: rho=0._R_P   !< Lorenz \\rho. !<   real(R_P)                            :: beta=0._R_P  !< Lorenz \\beta. !<   contains !<     procedure, pass(self), public :: t => dLorenz_dt                                 !< Time derivate, resiuduals function. !<     procedure, pass(lhs),  public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. !<     procedure, pass(rhs),  public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. !<     procedure, pass(lhs),  public :: add => add_lorenz                               !< Lorenz + Lorenz oprator. !<     procedure, pass(lhs),  public :: assign_integrand => lorenz_assign_lorenz        !< Lorenz = Lorenz. !<     procedure, pass(lhs),  public :: assign_real => lorenz_assign_real               !< Lorenz = real. !<     ... !< endtype lorenz !<``` !< !<#### use one of the provided FOODIE integrator !< !< For example using the forward explicit Euler scheme to the above Lorenz' ODE system !< !<```fortran !< use foodie, only : euler_explicit_integrator !< use type_lorenz, only : lorenz !< type(euler_explicit_integrator) :: euler_integrator !< type(lorenz)                    :: attractor !< real                            :: dt=0.01 !< do step = 1, num_steps !<   call euler_integrator%integrate(field=attractor, dt=dt) !< enddo !<``` !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_integrator_adams_bashforth , only : adams_bashforth_integrator use foodie_integrator_adams_bashforth_moulton , only : adams_bashforth_moulton_integrator use foodie_integrator_adams_moulton , only : adams_moulton_integrator use foodie_integrator_emd_runge_kutta , only : emd_runge_kutta_integrator use foodie_integrator_euler_explicit , only : euler_explicit_integrator use foodie_integrator_leapfrog , only : leapfrog_integrator use foodie_integrator_low_storage_runge_kutta , only : ls_runge_kutta_integrator use foodie_integrator_tvd_runge_kutta , only : tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: integrand public :: adams_bashforth_integrator public :: adams_bashforth_moulton_integrator public :: adams_moulton_integrator public :: emd_runge_kutta_integrator public :: euler_explicit_integrator public :: leapfrog_integrator public :: ls_runge_kutta_integrator public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- endmodule foodie","tags":"","loc":"sourcefile/foodie.f90.html","title":"foodie.f90 – Shu-Osher-shock-tube-problem"},{"text":"FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 6th order accurate. Source Code !< FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 6th order accurate. module foodie_integrator_emd_runge_kutta !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 6th order accurate. !< !< The integrators provided have the embedded pairs property allowing for automatic step size control. !< The schemes are explicit and defined through the extended Butcher's table syntax, see[1] . !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<  U_p&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_p&#94;s K&#94;s  !<  U_{p+1}&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_{p+1}&#94;s K&#94;s  !< !< *p* is the lower accuracy order scheme and *p+1* is the higher one; Ns is the number of stages used and K&#94;s is !< the s&#94;{th} stage computed as: !< !<  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are !< given in the extended Butcher table form: !< !<``` !<  gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns} !<  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns} !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns} !< ------------|------------------------------------------------------------- !<             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns} !<             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} !<``` !< !< Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: !< !<``` !<  gamma&#94;1    | 0                 0                 ...        0 !<  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0 !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0 !< ------------|------------------------------------------------------------- !<             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns} !<             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} !<``` !< !< Moreover the following relation always holds: !<  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !<##### 2 stages, 2th order !< This scheme is due to Heun-Euler. !<``` !<  0  | 0 !<  1  | 1     0 !< ---------------- !<     | 1/2   1/2 !<     | 1      0 !<``` !< !<##### 6 stages, 5th order !< This scheme is due to Cash and Karp, see [3]. !<``` !<  0    | 0 !<  1/5\t | 1/5 !<  3/10 | 3/40\t         9/40 !<  3/5\t | 3/10\t         -9/10\t      6/5 !<  1\t   | -11/54\t       5/2\t        -70/27\t    35/27 !<  7/8\t | 1631/55296    175/512      575/13824   44275/110592     253/4096     0 !< ---------------------------------------------------------------------------------------- !<       | 37/378        0           250/621      125/594          0            512/1771 !<       | 2825/27648    0           18575/48384  13525/55296      277/14336    1/4 !<``` !< !<##### 7 stages, 4th order !< This scheme is due to Dormand and Prince, see [1]. !<``` !<  0    | 0 !<  1/5  | 1/5 !<  3/10 | 3/40          9/40 !<  4/5  | 44/45        -56/15        32/9 !<  8/9  | 19372/6561   -25360/2187   64448/6561   -212/729 !<  1    | 9017/3168    -355/33       46732/5247    49/176      -5103/18656 !<  1    | 35/384        0            500/1113      125/192     -2187/6784      11/84      0 !< -------------------------------------------------------------------------------------------- !<       | 5179/57600    0            7571/16695    393/640     -92097/339200   187/2100   1/40 !<       | 35/384        0            500/1113      125/192     -2187/6784      11/84      0 !<``` !< !<##### 9 stages, 6th order !< This scheme is due to Calvo et al., see [2]. !<``` !<  0                 | 0 !<  2/15              | 2/15 !<  1/5               | 1/20                  3/20 !<  3/10              | 3/40                  0                      9/40 !<  14/25             | 86727015/196851553    -60129073/52624712     957436434/1378352377    83886832/147842441 !<  19/25             | -86860849/45628967    111022885/25716487     108046682/101167669     -141756746/36005461 !<  35226607/35688279 | 77759591/16096467     -49252809/6452555      -381680111/51572984     879269579/66788831 !<  1                 | 237564263/39280295    -100523239/10677940    -265574846/27330247     317978411/18988713 !<  1                 | 17572349/289262523    0                      57513011/201864250      15587306/354501571 !< -------------------------------------------------------------------------------------------------------------- !<                    | 17572349/289262523    0                      57513011/201864250      15587306/354501571 !<                    | 15231665/510830334    0                      59452991/116050448      -28398517/122437738 !< ...continued... !<  0                 | !<  2/15              | !<  1/5               | !<  3/10              | !<  14/25             | !<  19/25             | 73139862/60170633 !<  35226607/35688279 | -90453121/33722162     111179552/157155827 !<  1                 | -124494385/35453627    86822444/100138635     -12873523/724232625 !<  1                 | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0 !< ----------------------------------------------------------------------------------------------------------------------- !<                    | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0 !<                    | 56673824/137010559     68003849/426673583     7097631/37564021       -71226429/583093742    1/20 !<``` !< !<##### 17 stages, 10th order !< This scheme is due to Feagin, see [4]. !<``` !<  0                        |  0 !<  0.1                      |  0.1 !<  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052 !<  0.809036761204472681298  |  0.202259190301118170324  0                        0.606777570903354510974 !<  0.309036761204472681298  |  0.184024714708643575149  0                        0.197966831227192369068 !<  0.981074190219795268254  |  0.087900734020668133731  0                        0 !<  0.833333333333333333333  |  0.085970050490246030218  0                        0 !<  0.354017365856802376329  |  0.120930449125333720660  0                        0 !<  0.882527661964732346425  |  0.110854379580391483508  0                        0 !<  0.642615758240322548157  |  0.112054414752879004829  0                        0 !<  0.357384241759677451842  |  0.113976783964185986138  0                        0 !<  0.117472338035267653574  |  0.079831452828019604635  0                        0 !<  0.833333333333333333333  |  0.985115610164857280120  0                        0 !<  0.309036761204472681298  |  0.895080295771632891049  0                        0.197966831227192369068 !<  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052  0 !<  0.1                      |  0.1                      0                       -0.157178665799771163367 !<  1                        |  0.181781300700095283888  0.675                    0.342758159847189839942 !< ------------------------------------------------------------------------------------------------------ !<                           |  0.033333333333333333333  0.025                    0.033333333333333333333 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | -0.072954784731363262918 !<  0.981074190219795268254  |  0.410459702520260645318  0.482713753678866489204 !<  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -0.073185637507085073678 !<  0.354017365856802376329  |  0                        0.260124675758295622809  0.032540262154909133015 !<  0.882527661964732346425  |  0                        0                       -0.060576148825500558762 !<  0.642615758240322548157  |  0                        0                       -0.144942775902865915672 !<  0.357384241759677451842  |  0                        0                       -0.076881336420335693858 !<  0.117472338035267653574  |  0                        0                       -0.052032968680060307651 !<  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -1.378964865748435675821 !<  0.309036761204472681298  | -0.072954784731363262918  0                       -0.851236239662007619739 !<  0.539357840802981787532  |  0                       -0.777333643644968233538  0 !<  0.1                      |  0                        0                        0 !<  1                        |  0                        0.259111214548322744512 -0.358278966717952089048 !< ------------------------------------------------------------------------------------------------------ !<                           |  0                        0.05                     0 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | -0.059578021181736100156 !<  0.882527661964732346425  |  0.321763705601778390100  0.510485725608063031577 !<  0.642615758240322548157  | -0.333269719096256706589  0.499269229556880061353  0.509504608929686104236 !<  0.357384241759677451842  |  0.239527360324390649107  0.397774662368094639047  0.010755895687360745555 !<  0.117472338035267653574  | -0.057695414616854888173  0.194781915712104164976  0.145384923188325069727 !<  0.833333333333333333333  | -0.861164195027635666673  5.784288136375372200229  3.288077619851035668904 !<  0.309036761204472681298  |  0.398320112318533301719  3.639372631810356060294  1.548228770398303223653 !<  0.539357840802981787532  | -0.091089566215517606959  0                        0 !<  0.1                      |  0                        0                        0 !<  1                        | -1.045948959408833060950  0.930327845415626983292  1.779509594317081024461 !< ------------------------------------------------------------------------------------------------------ !<                           |  0.04                     0                        0.189237478148923490158 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | !<  0.882527661964732346425  | !<  0.642615758240322548157  | !<  0.357384241759677451842  | -0.327769124164018874147 !<  0.117472338035267653574  | -0.078294271035167077755 -0.114503299361098912184 !<  0.833333333333333333333  | -2.386339050931363840134 -3.254793424836439186545 -2.163435416864229823539 !<  0.309036761204472681298  | -2.122217147040537160260 -1.583503985453261727133 -1.715616082859362649220 !<  0.539357840802981787532  |  0                        0                        0 !<  0.1                      |  0                        0                        0 !<  1                        |  0.1                     -0.282547569539044081612 -0.159327350119972549169 !< ------------------------------------------------------------------------------------------------------ !<                           |  0.277429188517743176508  0.277429188517743176508  0.189237478148923490158 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | !<  0.882527661964732346425  | !<  0.642615758240322548157  | !<  0.357384241759677451842  | !<  0.117472338035267653574  | !<  0.833333333333333333333  | !<  0.309036761204472681298  | -0.024403640575012745213 !<  0.539357840802981787532  |  0.091089566215517606959  0.777333643644968233538 !<  0.1                      |  0                        0                        0.157178665799771163367 !<  1                        | -0.145515894647001510860 -0.259111214548322744512 -0.342758159847189839942 -0.675 !< ------------------------------------------------------------------------------------------------------------- !<                           | -0.04                    -0.05                    -0.033333333333333333333 -0.025 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | !<  0.882527661964732346425  | !<  0.642615758240322548157  | !<  0.357384241759677451842  | !<  0.117472338035267653574  | !<  0.833333333333333333333  | !<  0.309036761204472681298  | !<  0.539357840802981787532  | !<  0.1                      | !<  1                        | !< --------------------------------------------------- !<                           | 0.033333333333333333333 !<``` !< !<#### Bibliography !< !< [1] *A family of embedded Runge-Kutta formulae*, Dormand, J. R., Prince, P. J. (1980), Journal of Computational and !< Applied Mathematics 6 (1): 19--26, doi:10.1016/0771-050X(80)90013-3. !< !< [2] *A New Embedded Pair of Runge-Kutta Formulas of orders 5 and 6*, M. Calvo, J.I. Montijano, L. Randez, Computers & Mathematics !< with Applications, Volume 20, Issue 1, 1990, Pages 15--24, ISSN 0898-1221, http://dx.doi.org/10.1016/0898-1221(90)90064-Q. !< !< [3] *A variable order Runge-Kutta method for initial value problems with rapidly varying right-hand sides*, J. R. Cash, !< A. H. Karp, ACM Transactions on Mathematical Software, vol. 16,  pp. 201--222, 1990, doi:10.1145/79505.79507. !< !< [4] *A tenth-order Runge-Kutta method with error estimate*, Feagin, T., Proceedings of the IAENG Conf. on Scientific !< Computing. 2007. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P , I_P use foodie_adt_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: emd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: emd_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. real ( R_P ) :: tolerance = 0._R_P !< Tolerance on the local truncation error. real ( R_P ) :: pp1_inv = 0._R_P !< 1/(p+1) where p is the accuracy order of the lower accurate scheme of the pair. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:,:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), private :: new_Dt !< Compute new estimation of the time step Dt. final :: finalize !< Finalize object. endtype emd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , stages , tolerance ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. real ( R_P ), optional , intent ( IN ) :: tolerance !< Tolerance on the local truncation error (default 0.01). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added if ( present ( tolerance )) then self % tolerance = tolerance else self % tolerance = 0.01_R_P endif self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages , 1 : 2 )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 2 ) ! HERK(2,2) self % pp1_inv = 1._R_P / ( 2._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.5_R_P ; self % beta ( 1 , 2 ) = 5._R_P self % beta ( 2 , 1 ) = 1._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 6 ) ! CKRK(6,5) self % pp1_inv = 1._R_P / ( 5._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 7._R_P / 37 8._R_P ; self % beta ( 1 , 2 ) = 282 5._R_P / 2764 8._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 25 0._R_P / 62 1._R_P ; self % beta ( 3 , 2 ) = 1857 5._R_P / 4838 4._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 59 4._R_P ; self % beta ( 4 , 2 ) = 1352 5._R_P / 5529 6._R_P self % beta ( 5 , 1 ) = 0._R_P ; self % beta ( 5 , 2 ) = 27 7._R_P / 1433 6._R_P self % beta ( 6 , 1 ) = 51 2._R_P / 177 1._R_P ; self % beta ( 6 , 2 ) = 1._R_P / 4._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 1 0._R_P ; self % alph ( 4 , 2 ) = - 9._R_P / 1 0._R_P ; self % alph ( 4 , 3 ) = 6._R_P / 5._R_P self % alph ( 5 , 1 ) =- 1 1._R_P / 5 4._R_P ; self % alph ( 5 , 2 ) = 5._R_P / 2._R_P ; self % alph ( 5 , 3 ) =- 7 0._R_P / 2 7._R_P self % alph ( 6 , 1 ) = 163 1._R_P / 5529 6._R_P ; self % alph ( 6 , 2 ) = 17 5._R_P / 51 2._R_P ; self % alph ( 6 , 3 ) = 57 5._R_P / 1382 4._R_P self % alph ( 5 , 4 ) = 3 5._R_P / 2 7._R_P self % alph ( 6 , 4 ) = 4427 5._R_P / 11059 2._R_P ; self % alph ( 6 , 5 ) = 25 3._R_P / 409 6._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 3._R_P / 5._R_P self % gamm ( 5 ) = 1._R_P self % gamm ( 6 ) = 7._R_P / 8._R_P case ( 7 ) ! DPRK(7,4) self % pp1_inv = 1._R_P / ( 4._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 5._R_P / 38 4._R_P ; self % beta ( 1 , 2 ) = 517 9._R_P / 5760 0._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 50 0._R_P / 111 3._R_P ; self % beta ( 3 , 2 ) = 757 1._R_P / 1669 5._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 19 2._R_P ; self % beta ( 4 , 2 ) = 39 3._R_P / 64 0._R_P self % beta ( 5 , 1 ) = - 218 7._R_P / 678 4._R_P ; self % beta ( 5 , 2 ) = - 9209 7._R_P / 33920 0._R_P self % beta ( 6 , 1 ) = 1 1._R_P / 8 4._R_P ; self % beta ( 6 , 2 ) = 18 7._R_P / 210 0._R_P self % beta ( 7 , 1 ) = 0._R_P ; self % beta ( 7 , 2 ) = 1._R_P / 4 0._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 4 4._R_P / 4 5._R_P ; self % alph ( 4 , 2 ) =- 5 6._R_P / 1 5._R_P ; self % alph ( 4 , 3 ) = 3 2._R_P / 9._R_P self % alph ( 5 , 1 ) = 1937 2._R_P / 656 1._R_P ; self % alph ( 5 , 2 ) =- 2536 0._R_P / 218 7._R_P ; self % alph ( 5 , 3 ) = 6444 8._R_P / 656 1._R_P self % alph ( 6 , 1 ) = 901 7._R_P / 316 8._R_P ; self % alph ( 6 , 2 ) =- 35 5._R_P / 3 3._R_P ; self % alph ( 6 , 3 ) = 4673 2._R_P / 524 7._R_P self % alph ( 7 , 1 ) = 3 5._R_P / 38 4._R_P ; self % alph ( 7 , 2 ) = 0._R_P ; self % alph ( 7 , 3 ) = 50 0._R_P / 111 3._R_P self % alph ( 5 , 4 ) =- 21 2._R_P / 72 9._R_P self % alph ( 6 , 4 ) = 4 9._R_P / 17 6._R_P ; self % alph ( 6 , 5 ) =- 510 3._R_P / 1865 6._R_P self % alph ( 7 , 4 ) = 12 5._R_P / 19 2._R_P ; self % alph ( 7 , 5 ) =- 218 7._R_P / 678 4._R_P ; self % alph ( 7 , 6 ) = 1 1._R_P / 8 4._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 4._R_P / 5._R_P self % gamm ( 5 ) = 8._R_P / 9._R_P self % gamm ( 6 ) = 1._R_P self % gamm ( 7 ) = 1._R_P case ( 9 ) ! CMRK(9,6) self % pp1_inv = 1._R_P / ( 6._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % beta ( 1 , 2 ) = 1523166 5._R_P / 51083033 4._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 5751301 1._R_P / 20186425 0._R_P ; self % beta ( 3 , 2 ) = 5945299 1._R_P / 11605044 8._R_P self % beta ( 4 , 1 ) = 1558730 6._R_P / 35450157 1._R_P ; self % beta ( 4 , 2 ) = - 2839851 7._R_P / 12243773 8._R_P self % beta ( 5 , 1 ) = 7178302 1._R_P / 23498286 5._R_P ; self % beta ( 5 , 2 ) = 5667382 4._R_P / 13701055 9._R_P self % beta ( 6 , 1 ) = 2967200 0._R_P / 18048016 7._R_P ; self % beta ( 6 , 2 ) = 6800384 9._R_P / 42667358 3._R_P self % beta ( 7 , 1 ) = 6556762 1._R_P / 12706095 2._R_P ; self % beta ( 7 , 2 ) = 709763 1._R_P / 3756402 1._R_P self % beta ( 8 , 1 ) = - 7907457 0._R_P / 21055759 7._R_P ; self % beta ( 8 , 2 ) = - 7122642 9._R_P / 58309374 2._R_P self % beta ( 9 , 1 ) = 0._R_P ; self % beta ( 9 , 2 ) = 1._R_P / 2 0._R_P self % alph ( 2 , 1 ) = 2._R_P / 1 5._R_P self % alph ( 3 , 1 ) = 1._R_P / 2 0._R_P ; self % alph ( 3 , 2 ) = 3._R_P / 2 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 8672701 5._R_P / 19685155 3._R_P ; self % alph ( 5 , 2 ) =- 6012907 3._R_P / 5262471 2._R_P self % alph ( 6 , 1 ) =- 8686084 9._R_P / 4562896 7._R_P ; self % alph ( 6 , 2 ) = 11102288 5._R_P / 2571648 7._R_P self % alph ( 7 , 1 ) = 7775959 1._R_P / 1609646 7._R_P ; self % alph ( 7 , 2 ) =- 4925280 9._R_P / 645255 5._R_P self % alph ( 8 , 1 ) = 23756426 3._R_P / 3928029 5._R_P ; self % alph ( 8 , 2 ) =- 10052323 9._R_P / 1067794 0._R_P self % alph ( 9 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 4 , 3 ) = 9._R_P / 4 0._R_P self % alph ( 5 , 3 ) = 95743643 4._R_P / 137835237 7._R_P ; self % alph ( 5 , 4 ) = 8388683 2._R_P / 14784244 1._R_P self % alph ( 6 , 3 ) = 10804668 2._R_P / 10116766 9._R_P ; self % alph ( 6 , 4 ) =- 14175674 6._R_P / 3600546 1._R_P self % alph ( 7 , 3 ) =- 38168011 1._R_P / 5157298 4._R_P ; self % alph ( 7 , 4 ) = 87926957 9._R_P / 6678883 1._R_P self % alph ( 8 , 3 ) =- 26557484 6._R_P / 2733024 7._R_P ; self % alph ( 8 , 4 ) = 31797841 1._R_P / 1898871 3._R_P self % alph ( 9 , 3 ) = 5751301 1._R_P / 20186425 0._R_P ; self % alph ( 9 , 4 ) = 1558730 6._R_P / 35450157 1._R_P self % alph ( 6 , 5 ) = 7313986 2._R_P / 6017063 3._R_P self % alph ( 7 , 5 ) =- 9045312 1._R_P / 3372216 2._R_P ; self % alph ( 7 , 6 ) = 11117955 2._R_P / 15715582 7._R_P self % alph ( 8 , 5 ) =- 12449438 5._R_P / 3545362 7._R_P ; self % alph ( 8 , 6 ) = 8682244 4._R_P / 10013863 5._R_P self % alph ( 9 , 5 ) = 7178302 1._R_P / 23498286 5._R_P ; self % alph ( 9 , 6 ) = 2967200 0._R_P / 18048016 7._R_P self % alph ( 8 , 7 ) =- 1287352 3._R_P / 72423262 5._R_P self % alph ( 9 , 7 ) = 6556762 1._R_P / 12706095 2._R_P ; self % alph ( 9 , 8 ) =- 7907457 0._R_P / 21055759 7._R_P self % gamm ( 2 ) = 2._R_P / 1 5._R_P self % gamm ( 3 ) = 1._R_P / 5._R_P self % gamm ( 4 ) = 3._R_P / 1 0._R_P self % gamm ( 5 ) = 1 4._R_P / 2 5._R_P self % gamm ( 6 ) = 1 9._R_P / 2 5._R_P self % gamm ( 7 ) = 3522660 7._R_P / 3568827 9._R_P self % gamm ( 8 ) = 1._R_P self % gamm ( 9 ) = 1._R_P case ( 17 ) ! FRK(17,10) self % pp1_inv = 1._R_P / ( 1 0._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 1 , 2 ) = 0.033333333333333333333_R_P self % beta ( 2 , 1 ) = 0.025_R_P ; self % beta ( 2 , 2 ) = 1._R_P / 3 6._R_P self % beta ( 3 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 3 , 2 ) = 0.033333333333333333333_R_P self % beta ( 4 , 1 ) = 0._R_P ; self % beta ( 4 , 2 ) = 0._R_P self % beta ( 5 , 1 ) = 0.05_R_P ; self % beta ( 5 , 2 ) = 0.05_R_P self % beta ( 6 , 1 ) = 0._R_P ; self % beta ( 6 , 2 ) = 0._R_P self % beta ( 7 , 1 ) = 0.04_R_P ; self % beta ( 7 , 2 ) = 0.04_R_P self % beta ( 8 , 1 ) = 0._R_P ; self % beta ( 8 , 2 ) = 0._R_P self % beta ( 9 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 9 , 2 ) = 0.189237478148923490158_R_P self % beta ( 10 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 10 , 2 ) = 0.277429188517743176508_R_P self % beta ( 11 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 11 , 2 ) = 0.277429188517743176508_R_P self % beta ( 12 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 12 , 2 ) = 0.189237478148923490158_R_P self % beta ( 13 , 1 ) =- 0.04_R_P ; self % beta ( 13 , 2 ) =- 0.04_R_P self % beta ( 14 , 1 ) =- 0.05_R_P ; self % beta ( 14 , 2 ) =- 0.05_R_P self % beta ( 15 , 1 ) =- 0.033333333333333333333_R_P ; self % beta ( 15 , 2 ) =- 0.033333333333333333333_R_P self % beta ( 16 , 1 ) =- 0.025_R_P ; self % beta ( 16 , 2 ) =- 1._R_P / 3 6._R_P self % beta ( 17 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 17 , 2 ) = 0.033333333333333333333_R_P self % alph ( 2 , 1 ) = 0.1_R_P self % alph ( 3 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 3 , 2 ) = 1.454534402178273228052_R_P self % alph ( 4 , 1 ) = 0.202259190301118170324_R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 0.184024714708643575149_R_P ; self % alph ( 5 , 2 ) = 0._R_P self % alph ( 6 , 1 ) = 0.087900734020668133731_R_P ; self % alph ( 6 , 2 ) = 0._R_P self % alph ( 7 , 1 ) = 0.085970050490246030218_R_P ; self % alph ( 7 , 2 ) = 0._R_P self % alph ( 8 , 1 ) = 0.120930449125333720660_R_P ; self % alph ( 8 , 2 ) = 0._R_P self % alph ( 9 , 1 ) = 0.110854379580391483508_R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 10 , 1 ) = 0.112054414752879004829_R_P ; self % alph ( 10 , 2 ) = 0._R_P self % alph ( 11 , 1 ) = 0.113976783964185986138_R_P ; self % alph ( 11 , 2 ) = 0._R_P self % alph ( 12 , 1 ) = 0.079831452828019604635_R_P ; self % alph ( 12 , 2 ) = 0._R_P self % alph ( 13 , 1 ) = 0.985115610164857280120_R_P ; self % alph ( 13 , 2 ) = 0._R_P self % alph ( 14 , 1 ) = 0.895080295771632891049_R_P ; self % alph ( 14 , 2 ) = 0._R_P self % alph ( 15 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 15 , 2 ) = 1.454534402178273228052_R_P self % alph ( 16 , 1 ) = 0.1_R_P ; self % alph ( 16 , 2 ) = 0._R_P self % alph ( 17 , 1 ) = 0.181781300700095283888_R_P ; self % alph ( 17 , 2 ) = 0.675_R_P self % alph ( 4 , 3 ) = 0.606777570903354510974_R_P self % alph ( 5 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 5 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 6 , 3 ) = 0._R_P ; self % alph ( 6 , 4 ) = 0.410459702520260645318_R_P self % alph ( 7 , 3 ) = 0._R_P ; self % alph ( 7 , 4 ) = 0.330885963040722183948_R_P self % alph ( 8 , 3 ) = 0._R_P ; self % alph ( 8 , 4 ) = 0._R_P self % alph ( 9 , 3 ) = 0._R_P ; self % alph ( 9 , 4 ) = 0._R_P self % alph ( 10 , 3 ) = 0._R_P ; self % alph ( 10 , 4 ) = 0._R_P self % alph ( 11 , 3 ) = 0._R_P ; self % alph ( 11 , 4 ) = 0._R_P self % alph ( 12 , 3 ) = 0._R_P ; self % alph ( 12 , 4 ) = 0._R_P self % alph ( 13 , 3 ) = 0._R_P ; self % alph ( 13 , 4 ) = 0.330885963040722183948_R_P self % alph ( 14 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 14 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 15 , 3 ) = 0._R_P ; self % alph ( 15 , 4 ) = 0._R_P self % alph ( 16 , 3 ) =- 0.157178665799771163367_R_P ; self % alph ( 16 , 4 ) = 0._R_P self % alph ( 17 , 3 ) = 0.342758159847189839942_R_P ; self % alph ( 17 , 4 ) = 0._R_P self % alph ( 6 , 5 ) = 0.482713753678866489204_R_P self % alph ( 7 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 7 , 6 ) =- 0.073185637507085073678_R_P self % alph ( 8 , 5 ) = 0.260124675758295622809_R_P ; self % alph ( 8 , 6 ) = 0.032540262154909133015_R_P self % alph ( 9 , 5 ) = 0._R_P ; self % alph ( 9 , 6 ) =- 0.060576148825500558762_R_P self % alph ( 10 , 5 ) = 0._R_P ; self % alph ( 10 , 6 ) =- 0.144942775902865915672_R_P self % alph ( 11 , 5 ) = 0._R_P ; self % alph ( 11 , 6 ) =- 0.076881336420335693858_R_P self % alph ( 12 , 5 ) = 0._R_P ; self % alph ( 12 , 6 ) =- 0.052032968680060307651_R_P self % alph ( 13 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 13 , 6 ) =- 1.378964865748435675821_R_P self % alph ( 14 , 5 ) = 0._R_P ; self % alph ( 14 , 6 ) =- 0.851236239662007619739_R_P self % alph ( 15 , 5 ) =- 0.777333643644968233538_R_P ; self % alph ( 15 , 6 ) = 0._R_P self % alph ( 16 , 5 ) = 0._R_P ; self % alph ( 16 , 6 ) = 0._R_P self % alph ( 17 , 5 ) = 0.259111214548322744512_R_P ; self % alph ( 17 , 6 ) =- 0.358278966717952089048_R_P self % alph ( 8 , 7 ) =- 0.059578021181736100156_R_P self % alph ( 9 , 7 ) = 0.321763705601778390100_R_P ; self % alph ( 9 , 8 ) = 0.510485725608063031577_R_P self % alph ( 10 , 7 ) =- 0.333269719096256706589_R_P ; self % alph ( 10 , 8 ) = 0.499269229556880061353_R_P self % alph ( 11 , 7 ) = 0.239527360324390649107_R_P ; self % alph ( 11 , 8 ) = 0.397774662368094639047_R_P self % alph ( 12 , 7 ) =- 0.057695414616854888173_R_P ; self % alph ( 12 , 8 ) = 0.194781915712104164976_R_P self % alph ( 13 , 7 ) =- 0.861164195027635666673_R_P ; self % alph ( 13 , 8 ) = 5.784288136375372200229_R_P self % alph ( 14 , 7 ) = 0.398320112318533301719_R_P ; self % alph ( 14 , 8 ) = 3.639372631810356060294_R_P self % alph ( 15 , 7 ) =- 0.091089566215517606959_R_P ; self % alph ( 15 , 8 ) = 0._R_P self % alph ( 16 , 7 ) = 0._R_P ; self % alph ( 16 , 8 ) = 0._R_P self % alph ( 17 , 7 ) =- 1.045948959408833060950_R_P ; self % alph ( 17 , 8 ) = 0.930327845415626983292_R_P self % alph ( 10 , 9 ) = 0.509504608929686104236_R_P self % alph ( 11 , 9 ) = 0.010755895687360745555_R_P ; self % alph ( 11 , 10 ) =- 0.327769124164018874147_R_P self % alph ( 12 , 9 ) = 0.145384923188325069727_R_P ; self % alph ( 12 , 10 ) =- 0.078294271035167077755_R_P self % alph ( 13 , 9 ) = 3.288077619851035668904_R_P ; self % alph ( 13 , 10 ) =- 2.386339050931363840134_R_P self % alph ( 14 , 9 ) = 1.548228770398303223653_R_P ; self % alph ( 14 , 10 ) =- 2.122217147040537160260_R_P self % alph ( 15 , 9 ) = 0._R_P ; self % alph ( 15 , 10 ) = 0._R_P self % alph ( 16 , 9 ) = 0._R_P ; self % alph ( 16 , 10 ) = 0._R_P self % alph ( 17 , 9 ) = 1.779509594317081024461_R_P ; self % alph ( 17 , 10 ) = 0.1_R_P self % alph ( 12 , 11 ) =- 0.114503299361098912184_R_P self % alph ( 13 , 11 ) =- 3.254793424836439186545_R_P ; self % alph ( 13 , 12 ) =- 2.163435416864229823539_R_P self % alph ( 14 , 11 ) =- 1.583503985453261727133_R_P ; self % alph ( 14 , 12 ) =- 1.715616082859362649220_R_P self % alph ( 15 , 11 ) = 0._R_P ; self % alph ( 15 , 12 ) = 0._R_P self % alph ( 16 , 11 ) = 0._R_P ; self % alph ( 16 , 12 ) = 0._R_P self % alph ( 17 , 11 ) =- 0.282547569539044081612_R_P ; self % alph ( 17 , 12 ) =- 0.159327350119972549169_R_P self % alph ( 14 , 13 ) =- 0.024403640575012745213_R_P self % alph ( 15 , 13 ) = 0.091089566215517606959_R_P ; self % alph ( 15 , 14 ) = 0.777333643644968233538_R_P self % alph ( 16 , 13 ) = 0._R_P ; self % alph ( 16 , 14 ) = 0._R_P self % alph ( 17 , 13 ) =- 0.145515894647001510860_R_P ; self % alph ( 17 , 14 ) =- 0.259111214548322744512_R_P self % alph ( 16 , 15 ) = 0.157178665799771163367_R_P self % alph ( 17 , 15 ) =- 0.342758159847189839942_R_P ; self % alph ( 17 , 16 ) =- 0.675_R_P self % gamm ( 2 ) = 0.1_R_P self % gamm ( 3 ) = 0.539357840802981787532_R_P self % gamm ( 4 ) = 0.809036761204472681298_R_P self % gamm ( 5 ) = 0.309036761204472681298_R_P self % gamm ( 6 ) = 0.981074190219795268254_R_P self % gamm ( 7 ) = 0.833333333333333333333_R_P self % gamm ( 8 ) = 0.354017365856802376329_R_P self % gamm ( 9 ) = 0.882527661964732346425_R_P self % gamm ( 10 ) = 0.642615758240322548157_R_P self % gamm ( 11 ) = 0.357384241759677451842_R_P self % gamm ( 12 ) = 0.117472338035267653574_R_P self % gamm ( 13 ) = 0.833333333333333333333_R_P self % gamm ( 14 ) = 0.309036761204472681298_R_P self % gamm ( 15 ) = 0.539357840802981787532_R_P self % gamm ( 16 ) = 0.1_R_P self % gamm ( 17 ) = 1._R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % tolerance = 0._R_P self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit embedded Runge-Kutta scheme. !< !< The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( INOUT ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: U1 !< First U evaluation. class ( integrand ), allocatable :: U2 !< Second U evaluation. real ( R_P ) :: error !< Local truncation error estimation. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( U1 , source = U ) allocate ( U2 , source = U ) error = 1 e6 do while ( error > self % tolerance ) ! compute stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! compute new time step U1 = U U2 = U do s = 1 , self % stages U1 = U1 + stage ( s ) * ( Dt * self % beta ( s , 1 )) U2 = U2 + stage ( s ) * ( Dt * self % beta ( s , 2 )) enddo error = U2 . lterror . U1 call self % new_Dt ( error = error , Dt = Dt ) enddo U = U1 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate ! private methods elemental subroutine new_Dt ( self , error , Dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute new estimation of the time step Dt. !< !< The formula employed is: !< !<  Dt_{new} = 0.9 Dt_{old} \\left( \\frac{tolerance}{error} \\right)&#94;{\\frac{1}{p+1}}  !< !< @note 0.9 is a safety factor. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( IN ) :: self !< Integrator. real ( R_P ), intent ( IN ) :: error !< Local truncation error estimation. real ( R_P ), intent ( INOUT ) :: Dt !< Time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( error > self % tolerance ) Dt = 0.9_R_P * Dt * ( self % tolerance / error ) ** self % pp1_inv return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine new_Dt elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_emd_runge_kutta","tags":"","loc":"sourcefile/foodie_integrator_embedded_runge_kutta.f90.html","title":"foodie_integrator_embedded_runge_kutta.f90 – Shu-Osher-shock-tube-problem"},{"text":"FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order\n accurate. Source Code !< FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order !< accurate. module foodie_integrator_adams_bashforth_moulton !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order !< accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Bashforth-Moulton class scheme implemented is: !< !<##### predictor !<  U&#94;{n+N_s&#94;p} = U&#94;{n+N_s&#94;p-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s&#94;p}{ b_s&#94;p \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  !<##### corrector !<  U&#94;{n+N_s&#94;c} = U&#94;{n+N_s&#94;c-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s&#94;c}{ b_s&#94;c \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } \\right]  !< !<where N_s&#94;p is the number of previous steps considered for the predictor and N_s&#94;c is the number of previous steps !<considered for the corrector. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The coefficients b_s&#94;{p,c} define the actual scheme, that is selected accordingly to the number of !< **steps** used. The predictor and corrector schemes should have the same formal order of accuracy, thus N_s&#94;p=N_s&#94;c+1 !< should hold. !< !< Currently, the following schemes are available: !<##### P=AB(1)-C=AM(0) step, Explicit/Implicit Farward/Backward Euler, 1st order !< This scheme is TVD and reverts to Explicit/Implicit Farward/Backward Euler, it being 1st order. !< The *b* coefficient is: !< b&#94;p = \\left[b_1\\right] = \\left[1\\right] !< b&#94;c = \\left[b_0\\right] = \\left[1\\right] !< The scheme is: !<  U&#94;{n+1,p} = U&#94;{n} + \\Delta t R(t&#94;{n},U&#94;{n})  !<  U&#94;{n+1,c} = U&#94;{n} + \\Delta t R(t&#94;{n+1},U&#94;{n+1,p})  !< !<##### P=AB(2)-C=AM(1) steps !< This scheme is 2nd order. !< The *b* coefficients are: !< b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right] !< b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2} & \\frac{1}{2} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+2,p} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right]  !<  U&#94;{n+2,c} = U&#94;{n+1} +\\Delta t \\left[ \\frac{1}{2} R(t&#94;{n+2,p}, U&#94;{n+2})+\\frac{1}{2} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  !< !<##### P=AB(3)-C=AM(2) steps !< This scheme is 3rd order. !< The *b* coefficients are: !< b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right] !< b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{12} & \\frac{2}{3} & \\frac{5}{12} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+3,p} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1}) !< +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right]  !<  U&#94;{n+3,c} = U&#94;{n+2} +\\Delta t \\left[ \\frac{5}{12}R(t&#94;{n+3}, U&#94;{n+3,p}) + \\frac{2}{3}R(t&#94;{n+2}, U&#94;{n+2}) !< -\\frac{1}{12} R(t&#94;{n+1}, U&#94;{n+1})  \\right]  !< !<##### P=AB(4)-C=AM(3) steps !< This scheme is 4th order. !< The *b* coefficients are: !< b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 & b_4 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} -\\frac{9}{24} & \\frac{37}{24} & -\\frac{59}{24} & \\frac{55}{24} \\end{array}} \\right] !< b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 & b_3 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{24} & -\\frac{5}{24} & \\frac{19}{24} & \\frac{9}{24} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+4,p} = U&#94;{n+3} +\\Delta t \\left[ \\frac{55}{24}R(t&#94;{n+3}, U&#94;{n+3}) - \\frac{59}{24}R(t&#94;{n+2}, U&#94;{n+2}) !< +\\frac{37}{24} R(t&#94;{n+1}, U&#94;{n+1}) - \\frac{9}{24} R(t&#94;{n}, U&#94;{n}) \\right]  !<  U&#94;{n+4,c} = U&#94;{n+3} +\\Delta t \\left[ \\frac{9}{24}R(t&#94;{n+4}, U&#94;{n+4,p}) + \\frac{19}{24}R(t&#94;{n+3}, U&#94;{n+3}) !< -\\frac{5}{24} R(t&#94;{n+2}, U&#94;{n+2}) + \\frac{1}{24} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  !< !<#### Bibliography !< !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P , I_P use foodie_adt_integrand , only : integrand use foodie_integrator_adams_bashforth , only : adams_bashforth_integrator use foodie_integrator_adams_moulton , only : adams_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: adams_bashforth_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: adams_bashforth_moulton_integrator !< FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. !< !< @note The integrator must be created or initialized (predictor and corrector schemes selection) before used. private integer ( I_P ) :: steps =- 1 !< Number of time steps. type ( adams_bashforth_integrator ) :: predictor !< Predictor solver. type ( adams_moulton_integrator ) :: corrector !< Corrector solver. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype adams_bashforth_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth-Moulton integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps call self % predictor % init ( steps = steps ) call self % corrector % init ( steps = steps - 1 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = - 1 call self % predictor % destroy call self % corrector % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , previous , Dt , t , iterations ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth-Moulton class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( IN ) :: self !< Actual ABM integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations of AM scheme. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % predictor % integrate ( U = U , previous = previous , Dt = Dt , t = t , autoupdate = . false .) call self % corrector % integrate ( U = U , previous = previous ( 2 :), Dt = Dt , t = t , iterations = iterations , autoupdate = . false .) call self % predictor % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_adams_bashforth_moulton","tags":"","loc":"sourcefile/foodie_integrator_adams_bashforth_moulton.f90.html","title":"foodie_integrator_adams_bashforth_moulton.f90 – Shu-Osher-shock-tube-problem"},{"text":"Source Code module wenoof !----------------------------------------------------------------------------------------------------------------------------------- !< WenOOF, WENO interpolation Object Oriented Fortran library !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use type_weno_interpolator , only : weno_constructor , weno_interpolator use type_weno_interpolator_upwind , only : weno_constructor_upwind , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: weno_factory , weno_constructor , weno_interpolator public :: weno_constructor_upwind , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: weno_factory !< WENO factory aimed to create and return a concrete WENO interpolator to the client code without exposing the concrete !< interpolators classes. contains procedure , nopass :: create endtype !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine create ( constructor , interpolator ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create and return a concrete WENO interpolator object being an extension of the abstract *weno_interpolator* type. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_constructor ), intent ( IN ) :: constructor !< The concrete WENO constructor selected by client code. class ( weno_interpolator ), allocatable , intent ( OUT ) :: interpolator !< The concrete WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( constructor ) type is ( weno_constructor_upwind ) allocate ( weno_interpolator_upwind :: interpolator ) call interpolator % create ( constructor = constructor ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine create endmodule wenoof","tags":"","loc":"sourcefile/wenoof.f90.html","title":"wenoof.f90 – Shu-Osher-shock-tube-problem"},{"text":"WenOOF kinds: definition of reals and integer kind parameters of WenOOF library. Source Code !< WenOOF kinds: definition of reals and integer kind parameters of WenOOF library. module wenoof_kinds !----------------------------------------------------------------------------------------------------------------------------------- !< WenOOF kinds: definition of reals and integer kind parameters of WenOOF library. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: R8P public :: R4P public :: R_P public :: I8P public :: I4P public :: I2P public :: I1P public :: I_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. !----------------------------------------------------------------------------------------------------------------------------------- endmodule wenoof_kinds","tags":"","loc":"sourcefile/wenoof_kinds.f90.html","title":"wenoof_kinds.f90 – Shu-Osher-shock-tube-problem"},{"text":"Source Code module type_weno_interpolator !----------------------------------------------------------------------------------------------------------------------------------- !< Abstract WENO interpolator object, !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use wenoof_kinds , only : I_P , R_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: weno_interpolator , weno_constructor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , abstract :: weno_constructor !< Abstract type used for create new concrete WENO interpolators. !< !< @note Every concrete WENO interpolator implementations must define their own constructor type. private endtype weno_constructor type , abstract :: weno_interpolator !< WENO interpolator object. !< !< @note Do not implement any real interpolator: provide the interface for the different interpolators implemented. private contains procedure ( abstract_destructor ), pass ( self ), deferred , public :: destroy procedure ( abstract_constructor ), pass ( self ), deferred , public :: create procedure ( abstract_description ), pass ( self ), deferred , public :: description procedure ( abstract_interpolate ), pass ( self ), deferred , public :: interpolate endtype weno_interpolator abstract interface elemental subroutine abstract_destructor ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy a WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- import :: weno_interpolator class ( weno_interpolator ), intent ( INOUT ) :: self !< WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine abstract_destructor subroutine abstract_constructor ( self , constructor ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create a WENO interpolator. !< !< @note Before call this method a concrete constructor must be instantiated. !--------------------------------------------------------------------------------------------------------------------------------- import :: weno_interpolator import :: weno_constructor class ( weno_interpolator ), intent ( INOUT ) :: self !< WENO interpolator. class ( weno_constructor ), intent ( IN ) :: constructor !< WENO constructor. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine abstract_constructor pure subroutine abstract_description ( self , string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string describing a WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- import :: weno_interpolator class ( weno_interpolator ), intent ( IN ) :: self !< WENO interpolator. character ( len = :), allocatable , intent ( OUT ) :: string !< String returned. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine abstract_description pure subroutine abstract_interpolate ( self , S , stencil , location , interpolation ) !--------------------------------------------------------------------------------------------------------------------------------- !< Interpolate the stecil input values computing the actual interpolation. !--------------------------------------------------------------------------------------------------------------------------------- import :: weno_interpolator , I_P , R_P class ( weno_interpolator ), intent ( IN ) :: self !< WENO interpolator. integer ( I_P ), intent ( IN ) :: S !< Number of stencils used. real ( R_P ), intent ( IN ) :: stencil ( 1 :, 1 - S :) !< Stencil used for the interpolation, [1:2, 1-S:-1+S]. character ( * ), intent ( IN ) :: location !< Location of interpolated value(s): central, left, right, both. real ( R_P ), intent ( OUT ) :: interpolation ( 1 :) !< Result of the interpolation, [1:2]. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine abstract_interpolate endinterface !----------------------------------------------------------------------------------------------------------------------------------- endmodule type_weno_interpolator","tags":"","loc":"sourcefile/type_weno_interpolator.f90.html","title":"type_weno_interpolator.f90 – Shu-Osher-shock-tube-problem"},{"text":"Source Code module type_weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !< Module providing upwind biased WENO interpolator object and constructor, !< !< @note The provided WENO interpolator implements the *Efficient Implementation of Weighted ENO Schemes*, !< Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use wenoof_kinds , only : I_P , R_P use type_weno_interpolator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: weno_interpolator_upwind , weno_constructor_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( weno_constructor ) :: weno_constructor_upwind !< Upwind biased WENO interpolator constructor, !< !< @note The constructed WENO interpolator implements the *Efficient Implementation of Weighted ENO Schemes*, !< Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130. integer ( I_P ) :: S = 0 !< Stencils dimension. real ( R_P ) :: eps = 1 0._R_P ** ( - 6 ) !< Parameter for avoiding divided by zero when computing smoothness indicators. endtype weno_constructor_upwind interface weno_constructor_upwind procedure weno_constructor_upwind_init endinterface type , extends ( weno_interpolator ) :: weno_interpolator_upwind !< Upwind biased WENO interpolator object, !< !< @note The WENO interpolator implemented is the *Efficient Implementation of Weighted ENO Schemes*, !< Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130. !< !< @note The supported accuracy formal order are: 3rd, 5th, 7th corresponding to use 2, 3, 4 stencils composed of 2, 3, 4 values, !< respectively. private integer ( I_P ) :: S = 0_I_P !< Stencil dimension. real ( R_P ) :: eps = 0._R_P !< Parameter for avoiding divided by zero when computing smoothness indicators. real ( R_P ), allocatable :: weights_opt (:,:) !< Optimal weights                    [1:2,0:S-1]. real ( R_P ), allocatable :: poly_coef (:,:,:) !< Polynomials coefficients           [1:2,0:S-1,0:S-1]. real ( R_P ), allocatable :: smooth_coef (:,:,:) !< Smoothness indicators coefficients [0:S-1,0:S-1,0:S-1]. contains ! public methods procedure , pass ( self ), public :: destroy procedure , pass ( self ), public :: create procedure , pass ( self ), public :: description procedure , pass ( self ), public :: interpolate generic , public :: assignment ( = ) => assign_interpolator !< Overloading = assignament. ! private methods procedure , pass ( lhs ), private :: assign_interpolator !< Assignament operator. final :: finalize endtype weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- contains ! weno_constructor_upwind elemental function weno_constructor_upwind_init ( S , eps ) result ( constructor ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create (initialize) the WENO interpolator. !< !< @note For this class of interpolators it is sufficient to provide the maximum number of stencils used (that is also the !< dimension, i.e. number of values, of each stencil). During the actual interpolation phase the client code can specify, for each !< intepolation a different number of stencil bounded by this maximum value. This is useful for coupling the interpolator with !< algorithm like the Recursive Order Reduction (ROR) strategy. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: S !< Maximum stencils dimension. real ( R_P ), intent ( IN ), optional :: eps !< Parameter for avoiding divided by zero when computing smoothness indicators. type ( weno_constructor_upwind ) :: constructor !<WENO constructor. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- constructor % S = S if ( present ( eps )) constructor % eps = eps return !--------------------------------------------------------------------------------------------------------------------------------- endfunction weno_constructor_upwind_init ! weno_interpolator_upwind ! public methods elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( INOUT ) :: self !< WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % S = 0_I_P self % eps = 0._R_P if ( allocated ( self % weights_opt )) deallocate ( self % weights_opt ) if ( allocated ( self % poly_coef )) deallocate ( self % poly_coef ) if ( allocated ( self % smooth_coef )) deallocate ( self % smooth_coef ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine create ( self , constructor ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( INOUT ) :: self !< WENO interpolator. class ( weno_constructor ), intent ( IN ) :: constructor !< WENO constructor. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( constructor ) type is ( weno_constructor_upwind ) call self % destroy self % S = constructor % S self % eps = constructor % eps allocate ( self % weights_opt ( 1 : 2 , 0 : self % S - 1 )) allocate ( self % poly_coef ( 1 : 2 , 0 : self % S - 1 , 0 : self % S - 1 )) allocate ( self % smooth_coef ( 0 : self % S - 1 , 0 : self % S - 1 , 0 : self % S - 1 )) call set_weights_optimal call set_polynomial_coefficients call set_smoothness_indicators_coefficients endselect return !--------------------------------------------------------------------------------------------------------------------------------- contains subroutine set_weights_optimal () !------------------------------------------------------------------------------------------------------------------------------- !< Set the values of optimial weights. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- select case ( self % S ) case ( 2 ) ! 3rd order ! 1 => left interface (i-1/2) self % weights_opt ( 1 , 0 ) = 2._R_P / 3._R_P ! stencil 0 self % weights_opt ( 1 , 1 ) = 1._R_P / 3._R_P ! stencil 1 ! 2 => right interface (i+1/2) self % weights_opt ( 2 , 0 ) = 1._R_P / 3._R_P ! stencil 0 self % weights_opt ( 2 , 1 ) = 2._R_P / 3._R_P ! stencil 1 case ( 3 ) ! 5th order ! 1 => left interface (i-1/2) self % weights_opt ( 1 , 0 ) = 0.3_R_P ! stencil 0 self % weights_opt ( 1 , 1 ) = 0.6_R_P ! stencil 1 self % weights_opt ( 1 , 2 ) = 0.1_R_P ! stencil 2 ! 2 => right interface (i+1/2) self % weights_opt ( 2 , 0 ) = 0.1_R_P ! stencil 0 self % weights_opt ( 2 , 1 ) = 0.6_R_P ! stencil 1 self % weights_opt ( 2 , 2 ) = 0.3_R_P ! stencil 2 case ( 4 ) ! 7th order ! 1 => left interface (i-1/2) self % weights_opt ( 1 , 0 ) = 4._R_P / 3 5._R_P ! stencil 0 self % weights_opt ( 1 , 1 ) = 1 8._R_P / 3 5._R_P ! stencil 1 self % weights_opt ( 1 , 2 ) = 1 2._R_P / 3 5._R_P ! stencil 2 self % weights_opt ( 1 , 3 ) = 1._R_P / 3 5._R_P ! stencil 3 ! 2 => right interface (i+1/2) self % weights_opt ( 2 , 0 ) = 1._R_P / 3 5._R_P ! stencil 0 self % weights_opt ( 2 , 1 ) = 1 2._R_P / 3 5._R_P ! stencil 1 self % weights_opt ( 2 , 2 ) = 1 8._R_P / 3 5._R_P ! stencil 2 self % weights_opt ( 2 , 3 ) = 4._R_P / 3 5._R_P ! stencil 3 endselect return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_weights_optimal subroutine set_polynomial_coefficients () !------------------------------------------------------------------------------------------------------------------------------- !< Set the values of polynomial_coefficient. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- associate ( coef => self % poly_coef ) select case ( self % S ) case ( 2 ) ! 3rd order ! 1 => left interface (i-1/2) !  cell  0               ;    cell  1 coef ( 1 , 0 , 0 ) = 0.5_R_P ; coef ( 1 , 1 , 0 ) = 0.5_R_P ! stencil 0 coef ( 1 , 0 , 1 ) = - 0.5_R_P ; coef ( 1 , 1 , 1 ) = 1.5_R_P ! stencil 1 ! 2 => right interface (i+1/2) !  cell  0               ;    cell  1 coef ( 2 , 0 , 0 ) = 1.5_R_P ; coef ( 2 , 1 , 0 ) = - 0.5_R_P ! stencil 0 coef ( 2 , 0 , 1 ) = 0.5_R_P ; coef ( 2 , 1 , 1 ) = 0.5_R_P ! stencil 1 case ( 3 ) ! 5th order ! 1 => left interface (i-1/2) !  cell  0                     ;    cell  1                     ;    cell  2 coef ( 1 , 0 , 0 ) = 1._R_P / 3._R_P ; coef ( 1 , 1 , 0 ) = 5._R_P / 6._R_P ; coef ( 1 , 2 , 0 ) = - 1._R_P / 6._R_P ! stencil 0 coef ( 1 , 0 , 1 ) = - 1._R_P / 6._R_P ; coef ( 1 , 1 , 1 ) = 5._R_P / 6._R_P ; coef ( 1 , 2 , 1 ) = 1._R_P / 3._R_P ! stencil 1 coef ( 1 , 0 , 2 ) = 1._R_P / 3._R_P ; coef ( 1 , 1 , 2 ) = - 7._R_P / 6._R_P ; coef ( 1 , 2 , 2 ) = 1 1._R_P / 6._R_P ! stencil 2 ! 2 => right interface (i+1/2) !  cell  0                     ;    cell  1                     ;    cell  2 coef ( 2 , 0 , 0 ) = 1 1._R_P / 6._R_P ; coef ( 2 , 1 , 0 ) = - 7._R_P / 6._R_P ; coef ( 2 , 2 , 0 ) = 1._R_P / 3._R_P ! stencil 0 coef ( 2 , 0 , 1 ) = 1._R_P / 3._R_P ; coef ( 2 , 1 , 1 ) = 5._R_P / 6._R_P ; coef ( 2 , 2 , 1 ) = - 1._R_P / 6._R_P ! stencil 1 coef ( 2 , 0 , 2 ) = - 1._R_P / 6._R_P ; coef ( 2 , 1 , 2 ) = 5._R_P / 6._R_P ; coef ( 2 , 2 , 2 ) = 1._R_P / 3._R_P ! stencil 2 case ( 4 ) ! 7th order ! 1 => left interface (i-1/2) !  cell  0                 ;   cell  1                 ;   cell  2                  ;   cell  3 coef ( 1 , 0 , 0 ) = 1._R_P / 4._R_P ; coef ( 1 , 1 , 0 ) = 1 3._R_P / 1 2._R_P ; coef ( 1 , 2 , 0 ) = - 5._R_P / 1 2._R_P ; coef ( 1 , 3 , 0 ) = 1._R_P / 1 2._R_P ! sten 0 coef ( 1 , 0 , 1 ) =- 1._R_P / 1 2._R_P ; coef ( 1 , 1 , 1 ) = 7._R_P / 1 2._R_P ; coef ( 1 , 2 , 1 ) = 7._R_P / 1 2._R_P ; coef ( 1 , 3 , 1 ) =- 1._R_P / 1 2._R_P ! sten 1 coef ( 1 , 0 , 2 ) = 1._R_P / 1 2._R_P ; coef ( 1 , 1 , 2 ) =- 5._R_P / 1 2._R_P ; coef ( 1 , 2 , 2 ) = 1 3._R_P / 1 2._R_P ; coef ( 1 , 3 , 2 ) = 1._R_P / 4._R_P ! sten 2 coef ( 1 , 0 , 3 ) =- 1._R_P / 4._R_P ; coef ( 1 , 1 , 3 ) = 1 3._R_P / 1 2._R_P ; coef ( 1 , 2 , 3 ) =- 2 3._R_P / 1 2._R_P ; coef ( 1 , 3 , 3 ) = 2 5._R_P / 1 2._R_P ! sten 3 ! 2 => right interface (i+1/2) !  cell  0                 ;   cell  1                  ;   cell  2                 ;   cell  3 coef ( 2 , 0 , 0 ) = 2 5._R_P / 1 2._R_P ; coef ( 2 , 1 , 0 ) =- 2 3._R_P / 1 2._R_P ; coef ( 2 , 2 , 0 ) = 1 3._R_P / 1 2._R_P ; coef ( 2 , 3 , 0 ) =- 1._R_P / 4._R_P ! sten 0 coef ( 2 , 0 , 1 ) = 1._R_P / 4._R_P ; coef ( 2 , 1 , 1 ) = 1 3._R_P / 1 2._R_P ; coef ( 2 , 2 , 1 ) =- 5._R_P / 1 2._R_P ; coef ( 2 , 3 , 1 ) = 1._R_P / 1 2._R_P ! sten 1 coef ( 2 , 0 , 2 ) =- 1._R_P / 1 2._R_P ; coef ( 2 , 1 , 2 ) = 7._R_P / 1 2._R_P ; coef ( 2 , 2 , 2 ) = 7._R_P / 1 2._R_P ; coef ( 2 , 3 , 2 ) =- 1._R_P / 1 2._R_P ! sten 2 coef ( 2 , 0 , 3 ) = 1._R_P / 1 2._R_P ; coef ( 2 , 1 , 3 ) = - 5._R_P / 1 2._R_P ; coef ( 2 , 2 , 3 ) = 1 3._R_P / 1 2._R_P ; coef ( 2 , 3 , 3 ) = 1._R_P / 4._R_P ! sten 3 endselect endassociate return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_polynomial_coefficients subroutine set_smoothness_indicators_coefficients () !------------------------------------------------------------------------------------------------------------------------------- !< Set the values of smoothness indicators coefficients. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- associate ( coef => self % smooth_coef ) select case ( self % S ) case ( 2 ) ! 3rd order ! stencil 0 !      i*i             ;       (i-1)*i coef ( 0 , 0 , 0 ) = 1._R_P ; coef ( 1 , 0 , 0 ) = - 2._R_P !      /               ;       (i-1)*(i-1) coef ( 0 , 1 , 0 ) = 0._R_P ; coef ( 1 , 1 , 0 ) = 1._R_P ! stencil 1 !     (i+1)*(i+1)      ;       (i+1)*i coef ( 0 , 0 , 1 ) = 1._R_P ; coef ( 1 , 0 , 1 ) = - 2._R_P !      /               ;        i*i coef ( 0 , 1 , 1 ) = 0._R_P ; coef ( 1 , 1 , 1 ) = 1._R_P case ( 3 ) ! 5th order ! stencil 0 !      i*i                      ;       (i-1)*i                   ;       (i-2)*i coef ( 0 , 0 , 0 ) = 1 0._R_P / 3._R_P ; coef ( 1 , 0 , 0 ) = - 3 1._R_P / 3._R_P ; coef ( 2 , 0 , 0 ) = 1 1._R_P / 3._R_P !      /                        ;       (i-1)*(i-1)               ;       (i-2)*(i-1) coef ( 0 , 1 , 0 ) = 0._R_P ; coef ( 1 , 1 , 0 ) = 2 5._R_P / 3._R_P ; coef ( 2 , 1 , 0 ) = - 1 9._R_P / 3._R_P !      /                        ;        /                        ;       (i-2)*(i-2) coef ( 0 , 2 , 0 ) = 0._R_P ; coef ( 1 , 2 , 0 ) = 0._R_P ; coef ( 2 , 2 , 0 ) = 4._R_P / 3._R_P ! stencil 1 !     (i+1)*(i+1)               ;        i*(i+1)                  ;       (i-1)*(i+1) coef ( 0 , 0 , 1 ) = 4._R_P / 3._R_P ; coef ( 1 , 0 , 1 ) = - 1 3._R_P / 3._R_P ; coef ( 2 , 0 , 1 ) = 5._R_P / 3._R_P !      /                        ;        i*i                      ;       (i-1)*i coef ( 0 , 1 , 1 ) = 0._R_P ; coef ( 1 , 1 , 1 ) = 1 3._R_P / 3._R_P ; coef ( 2 , 1 , 1 ) = - 1 3._R_P / 3._R_P !      /                        ;        /                        ;       (i-1)*(i-1) coef ( 0 , 2 , 1 ) = 0._R_P ; coef ( 1 , 2 , 1 ) = 0._R_P ; coef ( 2 , 2 , 1 ) = 4._R_P / 3._R_P ! stencil 2 !     (i+2)*(i+2)               ;       (i+1)*(i+2)               ;        i*(i+2) coef ( 0 , 0 , 2 ) = 4._R_P / 3._R_P ; coef ( 1 , 0 , 2 ) = - 1 9._R_P / 3._R_P ; coef ( 2 , 0 , 2 ) = 1 1._R_P / 3._R_P !      /                        ;       (i+1)*(i+1)               ;        i*(i+1) coef ( 0 , 1 , 2 ) = 0._R_P ; coef ( 1 , 1 , 2 ) = 2 5._R_P / 3._R_P ; coef ( 2 , 1 , 2 ) = - 3 1._R_P / 3._R_P !      /                        ;        /                        ;        i*i coef ( 0 , 2 , 2 ) = 0._R_P ; coef ( 1 , 2 , 2 ) = 0._R_P ; coef ( 2 , 2 , 2 ) = 1 0._R_P / 3._R_P case ( 4 ) ! 7th order ! stencil 0 !      i*i                ;       (i-1)*i             ;       (i-2)*i              ;       (i-3)*i coef ( 0 , 0 , 0 ) = 210 7._R_P ; coef ( 1 , 0 , 0 ) =- 940 2._R_P ; coef ( 2 , 0 , 0 ) = 704 2._R_P ; coef ( 3 , 0 , 0 ) = - 185 4._R_P !      /                  ;       (i-1)*(i-1)         ;       (i-2)*(i-1)          ;       (i-3)*(i-1) coef ( 0 , 1 , 0 ) = 0._R_P ; coef ( 1 , 1 , 0 ) = 1100 3._R_P ; coef ( 2 , 1 , 0 ) =- 1724 6._R_P ; coef ( 3 , 1 , 0 ) = 464 2._R_P !      /                  ;        /                  ;       (i-2)*(i-2)          ;       (i-3)*(i-2) coef ( 0 , 2 , 0 ) = 0._R_P ; coef ( 1 , 2 , 0 ) = 0._R_P ; coef ( 2 , 2 , 0 ) = 704 3._R_P ; coef ( 3 , 2 , 0 ) = - 388 2._R_P !      /                  ;        /                  ;        /                   ;       (i-3)*(i-3) coef ( 0 , 3 , 0 ) = 0._R_P ; coef ( 1 , 3 , 0 ) = 0._R_P ; coef ( 2 , 3 , 0 ) = 0._R_P ; coef ( 3 , 3 , 0 ) = 54 7._R_P ! stencil 1 !     (i+1)*(i+1)         ;        i*(i+1)            ;       (i-1)*(i+1)          ;       (i-2)*(i+1) coef ( 0 , 0 , 1 ) = 54 7._R_P ; coef ( 1 , 0 , 1 ) =- 252 2._R_P ; coef ( 2 , 0 , 1 ) = 192 2._R_P ; coef ( 3 , 0 , 1 ) = - 49 4._R_P !       /                 ;          i*i              ;       (i-1)*i              ;       (i-2)*i coef ( 0 , 1 , 1 ) = 0._R_P ; coef ( 1 , 1 , 1 ) = 344 3._R_P ; coef ( 2 , 1 , 1 ) = - 596 6._R_P ; coef ( 3 , 1 , 1 ) = 160 2._R_P !       /                 ;          /                ;       (i-1)*(i-1)          ;       (i-2)*(i-1) coef ( 0 , 2 , 1 ) = 0._R_P ; coef ( 1 , 2 , 1 ) = 0._R_P ; coef ( 2 , 2 , 1 ) = 284 3._R_P ; coef ( 3 , 2 , 1 ) = - 164 2._R_P !       /                 ;          /                ;        /                   ;       (i-2)*(i-2) coef ( 0 , 3 , 1 ) = 0._R_P ; coef ( 1 , 3 , 1 ) = 0._R_P ; coef ( 2 , 3 , 1 ) = 0._R_P ; coef ( 3 , 3 , 1 ) = 26 7._R_P ! stencil 2 !     (i+2)*(i+2)         ;       (i+1)*(i+2)         ;            i*(i+2)         ;       (i-1)*(i+2) coef ( 0 , 0 , 2 ) = 26 7._R_P ; coef ( 1 , 0 , 2 ) =- 164 2._R_P ; coef ( 2 , 0 , 2 ) = 160 2._R_P ; coef ( 3 , 0 , 2 ) = - 49 4._R_P !      /                  ;       (i+1)*(i+1)         ;        i*(i+1)             ;       (i-1)*(i+1) coef ( 0 , 1 , 2 ) = 0._R_P ; coef ( 1 , 1 , 2 ) = 284 3._R_P ; coef ( 2 , 1 , 2 ) = - 596 6._R_P ; coef ( 3 , 1 , 2 ) = 192 2._R_P !      /                  ;        /                  ;        i*i                 ;       (i-1)*i coef ( 0 , 2 , 2 ) = 0._R_P ; coef ( 1 , 2 , 2 ) = 0._R_P ; coef ( 2 , 2 , 2 ) = 344 3._R_P ; coef ( 3 , 2 , 2 ) = - 252 2._R_P !      /                  ;        /                  ;        /                   ;       (i-1)*(i-1) coef ( 0 , 3 , 2 ) = 0._R_P ; coef ( 1 , 3 , 2 ) = 0._R_P ; coef ( 2 , 3 , 2 ) = 0._R_P ; coef ( 3 , 3 , 2 ) = 54 7._R_P ! stencil 3 !     (i+3)*(i+3)         ;       (i+2)*(i+3)         ;           (i+1)*(i+3)      ;        i*(i+3) coef ( 0 , 0 , 3 ) = 54 7._R_P ; coef ( 1 , 0 , 3 ) =- 388 2._R_P ; coef ( 2 , 0 , 3 ) = 464 2._R_P ; coef ( 3 , 0 , 3 ) = - 185 4._R_P !      /                  ;       (i+2)*(i+2)         ;       (i+1)*(i+2)          ;        i*(i+2) coef ( 0 , 1 , 3 ) = 0._R_P ; coef ( 1 , 1 , 3 ) = 704 3._R_P ; coef ( 2 , 1 , 3 ) =- 1724 6._R_P ; coef ( 3 , 1 , 3 ) = 704 2._R_P !      /                  ;        /                  ;       (i+1)*(i+1)          ;        i*(i+1) coef ( 0 , 2 , 3 ) = 0._R_P ; coef ( 1 , 2 , 3 ) = 0._R_P ; coef ( 2 , 2 , 3 ) = 1100 3._R_P ; coef ( 3 , 2 , 3 ) = - 940 2._R_P !      /                  ;        /                  ;        /                   ;        i*i coef ( 0 , 3 , 3 ) = 0._R_P ; coef ( 1 , 3 , 3 ) = 0._R_P ; coef ( 2 , 3 , 3 ) = 0._R_P ; coef ( 3 , 3 , 3 ) = 210 7._R_P endselect endassociate return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_smoothness_indicators_coefficients endsubroutine create pure subroutine description ( self , string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string describing the WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( IN ) :: self !< WENO interpolator. character ( len = :), allocatable , intent ( OUT ) :: string !< String returned. character ( len = 23 ) :: dummy !< Dummy string. character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !< New line character. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- string = 'WENO upwind-biased interpolator' // nl string = string // '  Based on the scheme proposed by Jiang and Shu \"Efficient Implementation of Weighted ENO Schemes\", see ' // & 'JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130' // nl write ( dummy , \"(I15)\" ) 2 * self % S - 1 string = string // '  Provide a formal order of accuracy equals to: ' // trim ( adjustl ( dummy )) // nl write ( dummy , \"(I15)\" ) self % S string = string // '  Use ' // trim ( adjustl ( dummy )) // ' stencils composed by ' // trim ( adjustl ( dummy )) // ' values' // nl write ( dummy , \"(E23.15)\" ) self % eps string = string // '  The eps value used for avoiding division by zero is ' // trim ( adjustl ( dummy )) // nl string = string // '  The \"interpolate\" method has the following public API' // nl string = string // '    interpolate(S, stencil, location, interpolation)' // nl string = string // '  where:' // nl string = string // '    S: integer(I_P), intent(IN), the number of stencils actually used' // nl string = string // '    stencil(1:, 1-S:-1+S): real(R_P), intent(IN), the stencils used' // nl string = string // '    location: character(*), intent(IN), the location of interpolation {left, right, both}' // nl string = string // '    interpolation(1:, 1-S:-1+S): realR_P, intent(OUT), the interpolated values' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine description pure subroutine interpolate ( self , S , stencil , location , interpolation ) !--------------------------------------------------------------------------------------------------------------------------------- !< Interpolate the stecil input values computing the actual interpolation. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( IN ) :: self !< WENO interpolator. integer , intent ( IN ) :: S !< Number of stencils actually used. real ( R_P ), intent ( IN ) :: stencil ( 1 :, 1 - S :) !< Stencil used for the interpolation, [1:2, 1-S:-1+S]. character ( * ), intent ( IN ) :: location !< Location of interpolated value(s): left, right, both. real ( R_P ), intent ( OUT ) :: interpolation ( 1 :) !< Result of the interpolation, [1:2]. real ( R_P ) :: polynomials ( 1 : 2 , 0 : S - 1 ) !< Polynomial reconstructions. real ( R_P ) :: weights ( 1 : 2 , 0 : S - 1 ) !< Weights of the stencils. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( location ) case ( 'both' , 'b' ) call compute_polynomials ( f1 = 1_I_P , f2 = 2_I_P , ff = 0_I_P , polynomials = polynomials ) call compute_weights ( f1 = 1_I_P , f2 = 2_I_P , ff = 0_I_P , weights = weights ) call compute_convolution ( f1 = 1_I_P , f2 = 2_I_P , ff = 0_I_P , interpolation = interpolation ) case ( 'left' , 'l' ) call compute_polynomials ( f1 = 1_I_P , f2 = 1_I_P , ff = 0_I_P , polynomials = polynomials ) call compute_weights ( f1 = 1_I_P , f2 = 1_I_P , ff = 0_I_P , weights = weights ) call compute_convolution ( f1 = 1_I_P , f2 = 1_I_P , ff = 0_I_P , interpolation = interpolation ) case ( 'right' , 'r' ) call compute_polynomials ( f1 = 2_I_P , f2 = 2_I_P , ff =- 1_I_P , polynomials = polynomials ) call compute_weights ( f1 = 2_I_P , f2 = 2_I_P , ff =- 1_I_P , weights = weights ) call compute_convolution ( f1 = 2_I_P , f2 = 2_I_P , ff =- 1_I_P , interpolation = interpolation ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- contains pure subroutine compute_polynomials ( f1 , f2 , ff , polynomials ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute the polynomials reconstructions. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: f1 , f2 , ff !< Faces to be computed. real ( R_P ), intent ( OUT ) :: polynomials ( 1 :, 0 :) !< Polynomial reconstructions. integer ( I_P ) :: s1 , s2 , f !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- polynomials = 0. do s1 = 0 , S - 1 ! stencils loop do s2 = 0 , S - 1 ! values loop do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) polynomials ( f , s1 ) = polynomials ( f , s1 ) + self % poly_coef ( f , s2 , s1 ) * stencil ( f + ff , - s2 + s1 ) enddo enddo enddo return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine compute_polynomials pure subroutine compute_weights ( f1 , f2 , ff , weights ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute the stencils weights. !------------------------------------------------------------------------------------------------------------------------------- integer , intent ( IN ) :: f1 , f2 , ff !< Faces to be computed. real ( R_P ), intent ( OUT ) :: weights ( 1 :, 0 :) !< Weights of the stencils, [1:2, 0:S - 1 ]. real ( R_P ) :: IS ( 1 : 2 , 0 : S - 1 ) !< Smoothness indicators of the stencils. real ( R_P ) :: a ( 1 : 2 , 0 : S - 1 ) !< Alpha coefficients for the weights. real ( R_P ) :: a_tot ( 1 : 2 ) !< Sum of the alpha coefficients. integer ( I_P ) :: s1 , s2 , s3 , f !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- ! computing smoothness indicators do s1 = 0 , S - 1 ! stencils loop do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) IS ( f , s1 ) = 0. do s2 = 0 , S - 1 do s3 = 0 , S - 1 IS ( f , s1 ) = IS ( f , s1 ) + self % smooth_coef ( s3 , s2 , s1 ) * stencil ( f + ff , s1 - s3 ) * stencil ( f + ff , s1 - s2 ) enddo enddo enddo enddo ! computing alfa coefficients a_tot = 0. do s1 = 0 , S - 1 ! stencil loops do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) a ( f , s1 ) = self % weights_opt ( f , s1 ) * ( 1. / ( self % eps + IS ( f , s1 )) ** S ) ; a_tot ( f ) = a_tot ( f ) + a ( f , s1 ) enddo enddo ! computing the weights do s1 = 0 , S - 1 ! stencils loop do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) weights ( f , s1 ) = a ( f , s1 ) / a_tot ( f ) enddo enddo return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine compute_weights pure subroutine compute_convolution ( f1 , f2 , ff , interpolation ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute the polynomials convolution. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: f1 , f2 , ff !< Faces to be computed. real ( R_P ), intent ( OUT ) :: interpolation ( 1 :) !< Left and right (1,2) interface value of reconstructed. integer ( I_P ) :: k , f !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- ! computing the convultion interpolation = 0. do k = 0 , S - 1 ! stencils loop do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) interpolation ( f + ff ) = interpolation ( f + ff ) + weights ( f , k ) * polynomials ( f , k ) enddo enddo return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine compute_convolution endsubroutine interpolate ! private methods pure subroutine assign_interpolator ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one interpolator to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( INOUT ) :: lhs !< Left hand side. class ( weno_interpolator ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( weno_interpolator_upwind ) lhs % S = rhs % S lhs % eps = rhs % eps if ( allocated ( rhs % weights_opt )) lhs % weights_opt = rhs % weights_opt if ( allocated ( rhs % poly_coef )) lhs % poly_coef = rhs % poly_coef if ( allocated ( rhs % smooth_coef )) lhs % smooth_coef = rhs % smooth_coef endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_interpolator elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( weno_interpolator_upwind ), intent ( INOUT ) :: self !< WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule type_weno_interpolator_upwind","tags":"","loc":"sourcefile/type_weno_interpolator_upwind.f90.html","title":"type_weno_interpolator_upwind.f90 – Shu-Osher-shock-tube-problem"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 4/14/2015 !  license: BSD ! !  For making simple x-y plots from Fortran. !  It works by generating a Python script and executing it. ! !# See also !   * Inspired by: [EasyPlot](https://pypi.python.org/pypi/EasyPlot) module pyplot_module use , intrinsic :: iso_fortran_env , only : real64 implicit none private integer , parameter , private :: wp = real64 !! Default real kind [8 bytes]. character ( len =* ), parameter :: tmp_file = 'pyplot_module_temp_1234567890.py' !! Default name of the temporary file !! (this can also be user-specified). character ( len =* ), parameter :: python_exe = 'python' !! The python executable name. character ( len =* ), parameter :: int_fmt = '(I10)' !! integer format string integer , parameter :: max_int_len = 10 !! max string length for integers character ( len =* ), parameter :: real_fmt = '(E30.16)' !! real number format string integer , parameter :: max_real_len = 30 !! max string length for reals type , public :: pyplot !!  The main pyplot class. private character ( len = :), allocatable :: str !! string buffer logical :: show_legend = . false . !! show legend into plot logical :: use_numpy = . true . !! use numpy python module logical :: mplot3d = . false . !! it is a 3d plot contains ! public methods procedure , public :: initialize !! initialize pyplot instance procedure , public :: add_plot !! add a 2d plot to pyplot instance procedure , public :: add_3d_plot !! add a 3d plot to pyplot instance procedure , public :: add_bar !! add a barplot to pyplot instance procedure , public :: savefig !! save plots of pyplot instance procedure , public :: destroy !! destroy pyplot instance ! private methods procedure :: execute !! execute pyplot commands procedure :: add_str !! add string to pytplot instance buffer end type pyplot contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Destructor. subroutine destroy ( me ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler if ( allocated ( me % str )) deallocate ( me % str ) end subroutine destroy !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Add a string to the buffer. subroutine add_str ( me , str ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler character ( len =* ), intent ( in ) :: str !! str to be added to pyplot handler buffer me % str = me % str // str // new_line ( ' ' ) end subroutine add_str !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Initialize a plot subroutine initialize ( me , grid , xlabel , ylabel , zlabel , title , legend , use_numpy , figsize , & font_size , axes_labelsize , xtick_labelsize , ytick_labelsize , ztick_labelsize , & legend_fontsize , mplot3d ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler logical , intent ( in ), optional :: grid !! activate grid drawing character ( len =* ), intent ( in ), optional :: xlabel !! label of x axis character ( len =* ), intent ( in ), optional :: ylabel !! label of y axis character ( len =* ), intent ( in ), optional :: zlabel !! label of z axis character ( len =* ), intent ( in ), optional :: title !! plot title logical , intent ( in ), optional :: legend !! plot legend logical , intent ( in ), optional :: use_numpy !! activate usage of numpy python module integer , dimension ( 2 ), intent ( in ), optional :: figsize !! dimension of the figure integer , intent ( in ), optional :: font_size !! font size integer , intent ( in ), optional :: axes_labelsize !! size of axis labels integer , intent ( in ), optional :: xtick_labelsize !! size of x axis tick lables integer , intent ( in ), optional :: ytick_labelsize !! size of y axis tick lables integer , intent ( in ), optional :: ztick_labelsize !! size of z axis tick lables integer , intent ( in ), optional :: legend_fontsize !! size of legend font logical , intent ( in ), optional :: mplot3d !! set true for 3d plots character ( len = max_int_len ) :: width_str !! figure width dummy string character ( len = max_int_len ) :: height_str !! figure height dummy string character ( len = max_int_len ) :: font_size_str !! font size dummy string character ( len = max_int_len ) :: axes_labelsize_str !! size of axis labels dummy string character ( len = max_int_len ) :: xtick_labelsize_str !! size of x axis tick labels dummy string character ( len = max_int_len ) :: ytick_labelsize_str !! size of x axis tick labels dummy string character ( len = max_int_len ) :: ztick_labelsize_str !! size of z axis tick labels dummy string character ( len = max_int_len ) :: legend_fontsize_str !! size of legend font dummy string character ( len =* ), parameter :: default_font_size_str = '10' !! the default font size for plots call me % destroy () if ( present ( legend )) then me % show_legend = legend else me % show_legend = . false . end if if ( present ( use_numpy )) then me % use_numpy = use_numpy else me % use_numpy = . true . end if if ( present ( figsize )) then call integer_to_string ( figsize ( 1 ), width_str ) call integer_to_string ( figsize ( 2 ), height_str ) end if if ( present ( mplot3d )) then me % mplot3d = mplot3d else me % mplot3d = . false . end if call optional_int_to_string ( font_size , font_size_str , default_font_size_str ) call optional_int_to_string ( axes_labelsize , axes_labelsize_str , default_font_size_str ) call optional_int_to_string ( xtick_labelsize , xtick_labelsize_str , default_font_size_str ) call optional_int_to_string ( ytick_labelsize , ytick_labelsize_str , default_font_size_str ) call optional_int_to_string ( ztick_labelsize , ztick_labelsize_str , default_font_size_str ) call optional_int_to_string ( legend_fontsize , legend_fontsize_str , default_font_size_str ) me % str = '' call me % add_str ( '#!/usr/bin/python' ) call me % add_str ( '' ) call me % add_str ( 'import matplotlib' ) call me % add_str ( 'import matplotlib.pyplot as plt' ) if ( me % mplot3d ) call me % add_str ( 'from mpl_toolkits.mplot3d import Axes3D' ) if ( me % use_numpy ) call me % add_str ( 'import numpy as np' ) call me % add_str ( '' ) call me % add_str ( 'matplotlib.rcParams[\"font.family\"] = \"Serif\"' ) call me % add_str ( 'matplotlib.rcParams[\"font.size\"] = ' // trim ( font_size_str )) call me % add_str ( 'matplotlib.rcParams[\"axes.labelsize\"] = ' // trim ( axes_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"xtick.labelsize\"] = ' // trim ( xtick_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"ytick.labelsize\"] = ' // trim ( ytick_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"legend.fontsize\"] = ' // trim ( legend_fontsize_str )) call me % add_str ( '' ) if ( present ( figsize )) then !if specifying the figure size call me % add_str ( 'fig = plt.figure(figsize=(' // trim ( width_str ) // ',' // trim ( height_str ) // '))' ) else call me % add_str ( 'fig = plt.figure()' ) end if if ( me % mplot3d ) then call me % add_str ( 'ax = fig.gca(projection=''3d'')' ) else call me % add_str ( 'ax = fig.gca()' ) end if if ( present ( grid )) then if ( grid ) call me % add_str ( 'ax.grid()' ) end if if ( present ( xlabel )) call me % add_str ( 'ax.set_xlabel(\"' // trim ( xlabel ) // '\")' ) if ( present ( ylabel )) call me % add_str ( 'ax.set_ylabel(\"' // trim ( ylabel ) // '\")' ) if ( present ( zlabel )) call me % add_str ( 'ax.set_zlabel(\"' // trim ( zlabel ) // '\")' ) if ( present ( title )) call me % add_str ( 'ax.set_title(\"' // trim ( title ) // '\")' ) call me % add_str ( '' ) end subroutine initialize !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Add an x,y plot. subroutine add_plot ( me , x , y , label , linestyle , markersize , linewidth ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler real ( wp ), dimension (:), intent ( in ) :: x !! x values real ( wp ), dimension (:), intent ( in ) :: y !! y values character ( len =* ), intent ( in ) :: label !! plot label character ( len =* ), intent ( in ) :: linestyle !! style of the plot line integer , intent ( in ), optional :: markersize !! size of the plot markers integer , intent ( in ), optional :: linewidth !! width of the plot line character ( len = :), allocatable :: xstr !! x values strinfied character ( len = :), allocatable :: ystr !! y values strinfied character ( len = max_int_len ) :: imark !! actual markers size character ( len = max_int_len ) :: iline !! actual line width character ( len =* ), parameter :: xname = 'x' !! x variable name for script character ( len =* ), parameter :: yname = 'y' !! y variable name for script if ( allocated ( me % str )) then !convert the arrays to strings: call vec_to_string ( x , xstr , me % use_numpy ) call vec_to_string ( y , ystr , me % use_numpy ) !get optional inputs (if not present, set default value): call optional_int_to_string ( markersize , imark , '3' ) call optional_int_to_string ( linewidth , iline , '3' ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) call me % add_str ( '' ) !write the plot statement: call me % add_str ( 'ax.plot(' // & trim ( xname ) // ',' // & trim ( yname ) // ',' // & '\"' // trim ( linestyle ) // '\",' // & 'linewidth=' // trim ( adjustl ( iline )) // ',' // & 'markersize=' // trim ( adjustl ( imark )) // ',' // & 'label=\"' // trim ( label ) // '\")' ) call me % add_str ( '' ) else error stop 'Error in add_plot: pyplot class not properly initialized.' end if end subroutine add_plot !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Add a 3D x,y,z plot. ! !@note Must initialize the class with ```mplot3d=.true.``` subroutine add_3d_plot ( me , x , y , z , label , linestyle , markersize , linewidth ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler real ( wp ), dimension (:), intent ( in ) :: x !! x values real ( wp ), dimension (:), intent ( in ) :: y !! y values real ( wp ), dimension (:), intent ( in ) :: z !! z values character ( len =* ), intent ( in ) :: label !! plot label character ( len =* ), intent ( in ) :: linestyle !! style of the plot line integer , intent ( in ), optional :: markersize !! size of the plot markers integer , intent ( in ), optional :: linewidth !! width of the plot line character ( len = :), allocatable :: xstr !! x values strinfied character ( len = :), allocatable :: ystr !! y values strinfied character ( len = :), allocatable :: zstr !! z values strinfied character ( len = max_int_len ) :: imark !! actual markers size character ( len = max_int_len ) :: iline !! actual line width character ( len =* ), parameter :: xname = 'x' !! x variable name for script character ( len =* ), parameter :: yname = 'y' !! y variable name for script character ( len =* ), parameter :: zname = 'z' !! z variable name for script if ( allocated ( me % str )) then !convert the arrays to strings: call vec_to_string ( x , xstr , me % use_numpy ) call vec_to_string ( y , ystr , me % use_numpy ) call vec_to_string ( z , zstr , me % use_numpy ) !get optional inputs (if not present, set default value): call optional_int_to_string ( markersize , imark , '3' ) call optional_int_to_string ( linewidth , iline , '3' ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) call me % add_str ( trim ( zname ) // ' = ' // zstr ) call me % add_str ( '' ) !write the plot statement: call me % add_str ( 'ax.plot(' // & trim ( xname ) // ',' // & trim ( yname ) // ',' // & trim ( zname ) // ',' // & '\"' // trim ( linestyle ) // '\",' // & 'linewidth=' // trim ( adjustl ( iline )) // ',' // & 'markersize=' // trim ( adjustl ( imark )) // ',' // & 'label=\"' // trim ( label ) // '\")' ) call me % add_str ( '' ) else error stop 'Error in add_3d_plot: pyplot class not properly initialized.' end if end subroutine add_3d_plot !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Add a bar plot. subroutine add_bar ( me , left , height , label , width , bottom , color ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler real ( wp ), dimension (:), intent ( in ) :: left !! left bar values real ( wp ), dimension (:), intent ( in ) :: height !! height bar values character ( len =* ), intent ( in ) :: label !! plot label real ( wp ), dimension (:), intent ( in ), optional :: width !! width values real ( wp ), dimension (:), intent ( in ), optional :: bottom !! bottom values character ( len =* ), intent ( in ), optional :: color !! plot color character ( len = :), allocatable :: xstr !! x axis values stringified character ( len = :), allocatable :: ystr !! y axis values stringified character ( len = :), allocatable :: wstr !! width values stringified character ( len = :), allocatable :: bstr !! bottom values stringified character ( len = :), allocatable :: plt_str !! plot string character ( len =* ), parameter :: xname = 'x' !! x axis name character ( len =* ), parameter :: yname = 'y' !! y axis name character ( len =* ), parameter :: wname = 'w' !! width name character ( len =* ), parameter :: bname = 'b' !! bottom name if ( allocated ( me % str )) then !convert the arrays to strings: call vec_to_string ( left , xstr , me % use_numpy ) call vec_to_string ( height , ystr , me % use_numpy ) if ( present ( width )) call vec_to_string ( width , wstr , me % use_numpy ) if ( present ( bottom )) call vec_to_string ( bottom , bstr , me % use_numpy ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) if ( present ( width )) call me % add_str ( trim ( wname ) // ' = ' // wstr ) if ( present ( bottom )) call me % add_str ( trim ( bname ) // ' = ' // bstr ) call me % add_str ( '' ) !create the plot string: plt_str = 'ax.bar(' // & 'left=' // trim ( xname ) // ',' // & 'height=' // trim ( yname ) // ',' if ( present ( width )) plt_str = plt_str // 'width=' // trim ( wname ) // ',' if ( present ( bottom )) plt_str = plt_str // 'bottom=' // trim ( bstr ) // ',' if ( present ( color )) plt_str = plt_str // 'color=\"' // trim ( color ) // '\",' plt_str = plt_str // 'label=\"' // trim ( label ) // '\")' !write the plot statement: call me % add_str ( plt_str ) call me % add_str ( '' ) else error stop 'Error in add_bar: pyplot class not properly initialized.' end if end subroutine add_bar !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Integer to string, specifying the default value if ! the optional argument is not present. subroutine optional_int_to_string ( int_value , string_value , default_value ) integer , intent ( in ), optional :: int_value !! integer value character ( len =* ), intent ( out ) :: string_value !! integer value stringified character ( len =* ), intent ( in ) :: default_value !! default integer value if ( present ( int_value )) then call integer_to_string ( int_value , string_value ) else string_value = default_value end if end subroutine optional_int_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Integer to string conversion. subroutine integer_to_string ( i , s ) integer , intent ( in ), optional :: i !! integer value character ( len =* ), intent ( out ) :: s !! integer value stringified integer :: istat !! IO status write ( s , int_fmt , iostat = istat ) i if ( istat /= 0 ) then error stop 'Error converting integer to string' else s = adjustl ( s ) end if end subroutine integer_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Real vector to string. subroutine vec_to_string ( v , str , use_numpy ) real ( wp ), dimension (:), intent ( in ) :: v !! real values character ( len = :), allocatable , intent ( out ) :: str !! real values stringified logical , intent ( in ) :: use_numpy !! activate numpy python module usage integer :: i !! counter integer :: istat !! IO status character ( len = max_real_len ) :: tmp !! dummy string str = '[' do i = 1 , size ( v ) write ( tmp , real_fmt , iostat = istat ) v ( i ) if ( istat /= 0 ) error stop 'Error in vec_to_string' str = str // trim ( adjustl ( tmp )) if ( i < size ( v )) str = str // ',' end do str = str // ']' !convert to numpy array if necessary: if ( use_numpy ) str = 'np.array(' // str // ')' end subroutine vec_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 8/16/2015 ! !  Write the buffer to a file, and then execute it with Python. ! !  If user specifies a Python file name, then the file is kept, otherwise !  a temporary filename is used, and the file is deleted after it is used. subroutine execute ( me , pyfile ) class ( pyplot ), intent ( inout ) :: me !! pytplot handler character ( len =* ), intent ( in ), optional :: pyfile !! name of the python script to generate integer :: istat !! IO status integer :: iunit !! IO unit character ( len = :), allocatable :: file !! file name logical :: scratch !! if a scratch file is to be used if ( allocated ( me % str )) then scratch = (. not . present ( pyfile )) !file name to use: if ( scratch ) then file = trim ( tmp_file ) !use the default else file = trim ( pyfile ) !use the user-specified name end if !open the file: open ( newunit = iunit , file = file , status = 'REPLACE' , iostat = istat ) if ( istat /= 0 ) error stop 'Error opening file.' !write to the file: write ( iunit , '(A)' ) me % str !run the file using python: call execute_command_line ( python_exe // ' ' // file ) !close the file: if ( scratch ) then close ( iunit , status = 'DELETE' , iostat = istat ) else close ( iunit , iostat = istat ) end if if ( istat /= 0 ) error stop 'Error closing file.' !cleanup: if ( allocated ( file )) deallocate ( file ) end if end subroutine execute !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! ! Save the figure. subroutine savefig ( me , figfile , pyfile ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler character ( len =* ), intent ( in ) :: figfile !! file name for the figure character ( len =* ), intent ( in ), optional :: pyfile !! name of the Python script to generate if ( allocated ( me % str )) then !finish up the string: if ( me % show_legend ) then call me % add_str ( 'ax.legend(loc=\"best\")' ) call me % add_str ( '' ) end if call me % add_str ( 'plt.savefig(\"' // trim ( figfile ) // '\")' ) !run it: call me % execute ( pyfile ) else error stop 'error in savefig: pyplot class not properly initialized.' end if end subroutine savefig !***************************************************************************************** !***************************************************************************************** end module pyplot_module !*****************************************************************************************","tags":"","loc":"sourcefile/pyplot_module.f90.html","title":"pyplot_module.f90 – Shu-Osher-shock-tube-problem"},{"text":"FLAP, Fortran command Line Arguments Parser for poor people Source Code !< FLAP, Fortran command Line Arguments Parser for poor people module Data_Type_Command_Line_Interface !----------------------------------------------------------------------------------------------------------------------------------- !< FLAP, Fortran command Line Arguments Parser for poor people !<{!README-FLAP.md!} !< !<### ChangeLog !< !<{!ChangeLog-FLAP.md!} !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT , stderr => ERROR_UNIT ! Standard output/error logical units. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , abstract :: Type_Object private character ( len = :), public , allocatable :: progname !< Program name. character ( len = :), public , allocatable :: version !< Program version. character ( len = :), allocatable :: help !< Help message. character ( len = :), public , allocatable :: description !< Detailed description. character ( len = :), public , allocatable :: license !< License description. character ( len = :), public , allocatable :: authors !< Authors list. character ( len = :), public , allocatable :: epilog !< Epilog message. character ( len = :), public , allocatable :: m_exclude !< Mutually exclude other CLA(s group). integer ( I4P ), public :: error = 0_I4P !< Error traping flag. contains procedure :: free_object !< Free dynamic memory. procedure :: errored !< Trig error occurence and print meaningful message. procedure :: print_version !< Print version. procedure :: assign_object !< Assignment overloading. endtype Type_Object type , extends ( Type_Object ) :: Type_Command_Line_Argument !< Command line arguments (CLA). !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value. private character ( len = :), allocatable :: switch !< Switch name. character ( len = :), allocatable :: switch_ab !< Abbreviated switch name. logical :: required = . false . !< Flag for set required argument. logical :: positional = . false . !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ) :: position = 0_I4P !< Position of positional CLA. logical :: passed = . false . !< Flag for checking if CLA has been passed to CLI. logical :: hidden = . false . !< Flag for hiding CLA, thus it does not compare into help. character ( len = :), allocatable :: act !< CLA value action. character ( len = :), allocatable :: def !< Default value. character ( len = :), allocatable :: nargs !< Number of arguments consumed by CLA. character ( len = :), allocatable :: choices !< List (comma separated) of allowable values for the argument. character ( len = :), allocatable :: val !< CLA value. character ( len = :), allocatable :: envvar !< Environment variable from which take value. contains ! public methods procedure , public :: free => free_cla !< Free dynamic memory. procedure , public :: check => check_cla !< Check CLA data consistency. procedure , public :: check_choices => check_choices_cla !< Check if CLA value is in allowed choices. procedure , public :: check_list_size => check_list_size_cla !< Check CLA multiple values list size consistency. generic , public :: get => get_cla , get_cla_list !< Get CLA value(s). generic , public :: get_varying => & !< Get CLA value(s) from CLAs list parsedi, varying size list. #ifdef r16p get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char procedure , public :: usage => usage_cla !< Get correct CLA usage. procedure , public :: signature => signature_cla !< Get CLA signature for adding to CLI one. ! private methods procedure , private :: get_cla !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: assign_cla !< CLA assignment overloading. generic , private :: assignment ( = ) => assign_cla !< CLA assignment overloading. final :: finalize_cla !< Free dynamic memory when finalizing. endtype Type_Command_Line_Argument type , extends ( Type_Object ) :: Type_Command_Line_Arguments_Group !< Group of CLAs for building nested commands. private character ( len = :), allocatable :: group !< Group name (command). integer ( I4P ) :: Na = 0_I4P !< Number of CLA. integer ( I4P ) :: Na_required = 0_I4P !< Number of command line arguments that CLI requires. integer ( I4P ) :: Na_optional = 0_I4P !< Number of command line arguments that are optional for CLI. type ( Type_Command_Line_Argument ), allocatable :: cla (:) !< CLA list [1:Na]. logical :: called = . false . !< Flag for checking if CLAs group has been passed to CLI. contains ! public methods procedure , public :: free => free_clasg !< Free dynamic memory. procedure , public :: check => check_clasg !< Check CLAs data consistency. procedure , public :: check_required => check_required_clasg !< Check if required CLAs are passed. procedure , public :: check_m_exclusive => check_m_exclusive_clasg !< Check if two mutually exclusive CLAs have been passed. procedure , public :: add => add_cla_clasg !< Add CLA to CLAs group. procedure , public :: passed => passed_clasg !< Check if a CLA has been passed. procedure , public :: defined => defined_clasg !< Check if a CLA has been defined. procedure , public :: parse => parse_clasg !< Parse CLAs group arguments. procedure , public :: usage => usage_clasg !< Get correct CLAs group usage. procedure , public :: signature => signature_clasg !< Get CLAs group signature for adding to the CLI one. ! private methods procedure , private :: assign_clasg !< CLAs group assignment overloading. generic , private :: assignment ( = ) => assign_clasg !< CLAs group assignment overloading. final :: finalize_clasg !< Free dynamic memory when finalizing. endtype Type_Command_Line_Arguments_Group type , extends ( Type_Object ), public :: Type_Command_Line_Interface !< Command Line Interface (CLI). private type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg (:) !< CLA list [1:Na]. #ifdef __GFORTRAN__ character ( 512 ), allocatable :: args (:) !< Actually passed command line arguments. character ( 512 ), allocatable :: examples (:) !< Examples of correct usage. #else character ( len = :), allocatable :: args (:) !< Actually passed command line arguments. character ( len = :), allocatable :: examples (:) !< Examples of correct usage (not work with gfortran). #endif logical :: disable_hv = . false . !< Disable automatic 'help' and 'version' CLAs. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: init !< Initialize CLI. procedure , public :: add_group !< Add CLAs group CLI. procedure , public :: add !< Add CLA to CLI. procedure , public :: passed !< Check if a CLA has been passed. procedure , public :: defined !< Check if a CLA has been defined. procedure , public :: defined_group !< Check if a CLAs group has been defined. procedure , public :: set_mutually_exclusive_groups !< Set two CLAs group as mutually exclusive. procedure , public :: run_command => called_group !< Check if a CLAs group has been runned. procedure , public :: parse !< Parse Command Line Interfaces. generic , public :: get => get_cla_cli , get_cla_list_cli !< Get CLA value(s) from CLAs list parsed. generic , public :: get_varying => & !< Get CLA value(s) from CLAs list parsedi, varying size list. #ifdef r16p get_cla_list_varying_R16P_cli , & #endif get_cla_list_varying_R8P_cli , & get_cla_list_varying_R4P_cli , & get_cla_list_varying_I8P_cli , & get_cla_list_varying_I4P_cli , & get_cla_list_varying_I2P_cli , & get_cla_list_varying_I1P_cli , & get_cla_list_varying_logical_cli , & get_cla_list_varying_char_cli procedure , public :: usage !< Get CLI usage. procedure , public :: signature !< Get CLI signature. procedure , public :: print_usage !< Print correct usage of CLI. procedure , public :: save_man_page !< Save man page build on CLI. ! private methods procedure , private :: check !< Check CLAs data consistenc. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs group have been called. procedure , private :: get_clasg_indexes !< Get CLAs groups indexes. generic , private :: get_args => get_args_from_string ,& !< Get CLAs from string. get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_args_from_string !< Get CLAs from string. procedure , private :: get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_cla_cli !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list_cli !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R16P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R16P. procedure , private :: get_cla_list_varying_R8P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical_cli !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char_cli !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: assign_cli !< CLI assignment overloading. generic , private :: assignment ( = ) => assign_cli !< CLI assignment overloading. final :: finalize !< Free dynamic memory when finalizing. endtype Type_Command_Line_Interface ! parameters integer ( I4P ), parameter :: max_val_len = 1000 !< Maximum number of characters of CLA value. character ( len =* ), parameter :: action_store = 'STORE' !< CLA that stores value (if invoked a value must be passed). character ( len =* ), parameter :: action_store_star = 'STORE*' !< CLA that stores value or revert on default is invoked alone. character ( len =* ), parameter :: action_store_true = 'STORE_TRUE' !< CLA that stores .true. without the necessity of a value. character ( len =* ), parameter :: action_store_false = 'STORE_FALSE' !< CLA that stores .false. without the necessity of a value. character ( len =* ), parameter :: action_print_help = 'PRINT_HELP' !< CLA that print help message. character ( len =* ), parameter :: action_print_vers = 'PRINT_VERSION' !< CLA that print version. character ( len =* ), parameter :: args_sep = '||!||' !< Arguments separator for multiple valued (list) CLA. ! code errors and status integer ( I4P ), parameter :: error_cla_optional_no_def = 1 !< Optional CLA without default value. integer ( I4P ), parameter :: error_cla_required_m_exclude = 2 !< Required CLA cannot exclude others. integer ( I4P ), parameter :: error_cla_positional_m_exclude = 3 !< Positional CLA cannot exclude others. integer ( I4P ), parameter :: error_cla_named_no_name = 4 !< Named CLA without switch name. integer ( I4P ), parameter :: error_cla_positional_no_position = 5 !< Positional CLA without position. integer ( I4P ), parameter :: error_cla_positional_no_store = 6 !< Positional CLA without action_store. integer ( I4P ), parameter :: error_cla_not_in_choices = 7 !< CLA value out of a specified choices. integer ( I4P ), parameter :: error_cla_missing_required = 8 !< Missing required CLA. integer ( I4P ), parameter :: error_cla_m_exclude = 9 !< Two mutually exclusive CLAs have been passed. integer ( I4P ), parameter :: error_cla_casting_logical = 10 !< Error casting CLA value to logical type. integer ( I4P ), parameter :: error_cla_choices_logical = 11 !< Error adding choices check for CLA value of logical type. integer ( I4P ), parameter :: error_cla_no_list = 12 !< Actual CLA is not list-values. integer ( I4P ), parameter :: error_cla_nargs_insufficient = 13 !< Multi-valued CLA with insufficient arguments. integer ( I4P ), parameter :: error_cla_value_missing = 14 !< Missing value of CLA. integer ( I4P ), parameter :: error_cla_unknown = 15 !< Unknown CLA (switch name). integer ( I4P ), parameter :: error_cla_envvar_positional = 16 !< Envvar not allowed for positional CLA. integer ( I4P ), parameter :: error_cla_envvar_not_store = 17 !< Envvar not allowed action different from store; integer ( I4P ), parameter :: error_cla_envvar_nargs = 18 !< Envvar not allowed for list-values CLA. integer ( I4P ), parameter :: error_cla_store_star_positional = 19 !< Action store* not allowed for positional CLA. integer ( I4P ), parameter :: error_cla_store_star_nargs = 20 !< Action store* not allowed for list-values CLA. integer ( I4P ), parameter :: error_cla_store_star_envvar = 21 !< Action store* not allowed for environment variable CLA. integer ( I4P ), parameter :: error_cla_action_unknown = 22 !< Unknown CLA (switch name). integer ( I4P ), parameter :: error_clasg_consistency = 23 !< CLAs group consistency error. integer ( I4P ), parameter :: error_clasg_m_exclude = 24 !< Two mutually exclusive CLAs group have been called. integer ( I4P ), parameter :: error_cli_missing_cla = 25 !< CLA not found in CLI. integer ( I4P ), parameter :: error_cli_missing_group = 26 !< Group not found in CLI. integer ( I4P ), parameter :: error_cli_missing_selection_cla = 27 !< CLA selection in CLI failing. integer ( I4P ), parameter :: error_cli_too_few_clas = 28 !< Insufficient arguments for CLI. integer ( I4P ), parameter :: status_clasg_print_v = - 1 !< Print version status. integer ( I4P ), parameter :: status_clasg_print_h = - 2 !< Print help status. !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary procedures pure function Upper_Case ( string ) ! elemental function Upper_Case(string) ! 1513-209 (S) The result of an elemental function must be a nonpointer, nonallocatable scalar, and its type parameters must be constant expressions. !--------------------------------------------------------------------------------------------------------------------------------- !< Convert the lower case characters of a string to upper case one. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len =* ), intent ( IN ) :: string !< String to be converted. character ( len = len ( string )) :: Upper_Case !< Converted string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. character ( len = 26 ), parameter :: upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( len = 26 ), parameter :: lower_alphabet = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Upper_Case = string do n1 = 1 , len ( string ) n2 = index ( lower_alphabet , string ( n1 : n1 )) if ( n2 > 0 ) Upper_Case ( n1 : n1 ) = upper_alphabet ( n2 : n2 ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction Upper_Case pure subroutine tokenize ( strin , delimiter , toks , Nt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to char(0). !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( IN ) :: strin !< String to be tokenized. character ( len =* ), intent ( IN ) :: delimiter !< Delimiter of tokens. character ( len = len ( strin )), intent ( OUT ), allocatable :: toks (:) !< Tokens. integer ( I4P ), intent ( OUT ), optional :: Nt !< Number of tokens. character ( len = len ( strin )) :: strsub !< Temporary string. integer ( I4P ) :: dlen !< Delimiter length. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: n !< Counter. integer ( I4P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialization if ( allocated ( toks )) deallocate ( toks ) strsub = strin dlen = len ( delimiter ) if ( dlen > len ( strin )) then allocate ( toks ( 1 : 1 )) ; toks ( 1 ) = char ( 0 ) ; if ( present ( Nt )) Nt = 1 ; return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenization do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tokenize ! Type_Object procedures elemental subroutine free_object ( obj ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: obj !< Object data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( obj % progname )) deallocate ( obj % progname ) if ( allocated ( obj % version )) deallocate ( obj % version ) if ( allocated ( obj % help )) deallocate ( obj % help ) if ( allocated ( obj % description )) deallocate ( obj % description ) if ( allocated ( obj % license )) deallocate ( obj % license ) if ( allocated ( obj % authors )) deallocate ( obj % authors ) if ( allocated ( obj % epilog )) deallocate ( obj % epilog ) if ( allocated ( obj % m_exclude )) deallocate ( obj % m_exclude ) obj % error = 0_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_object subroutine errored ( obj , error , pref , group , switch , val_str , log_value , a1 , a2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Trig error occurence and print meaningful message. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: obj !< Object data. integer ( I4P ), intent ( IN ) :: error !< Error occurred. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Group name. character ( * ), optional , intent ( IN ) :: switch !< CLA switch name. character ( * ), optional , intent ( IN ) :: val_str !< Value string. character ( * ), optional , intent ( IN ) :: log_value !< Logical value to be casted. integer ( I4P ), optional , intent ( IN ) :: a1 , a2 !< CLAs group inconsistent indexes. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- obj % error = error if ( obj % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref select type ( obj ) class is ( Type_Command_Line_Argument ) select case ( obj % error ) case ( error_cla_optional_no_def ) if ( obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str ( n = obj % position )) // & '-th\" positional option has not a default value!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // obj % switch // '\" has not a default value!' endif case ( error_cla_required_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // obj % switch // '\" cannot exclude others' // & ', it being requiredi, only optional ones can!' case ( error_cla_positional_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str ( n = obj % position )) // & '-th\" positional option cannot exclude others, only optional named options can!' case ( error_cla_named_no_name ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a non positional optiona must have a switch name!' case ( error_cla_positional_no_position ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a positional option must have a position number different from 0!' case ( error_cla_positional_no_store ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a positional option must have action set to \"' // action_store // '\"!' case ( error_cla_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: the options \"' // obj % switch // '\" and \"' // obj % m_exclude // '\" are mutually' // & ' exclusive, but both have been passed!' case ( error_cla_not_in_choices ) if ( obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: value of \"' // trim ( str ( n = obj % position )) // & '-th\" positional option must be chosen in:' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: value of named option \"' // obj % switch // '\" must be chosen in:' endif write ( stderr , '(A)' ) prefd // '(' // obj % choices // ')' write ( stderr , '(A)' ) prefd // '\"' // trim ( val_str ) // '\" has been passed!' case ( error_cla_missing_required ) if (. not . obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" is required!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option is required!' endif case ( error_cla_casting_logical ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: cannot convert \"' // log_value // '\" of option \"' // obj % switch // & '\" to logical type!' case ( error_cla_choices_logical ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: cannot use \"choices\" value check for option \"' // obj % switch // & '\" it being of logical type! The choices is, by definition of logical, limited to \".true.\" or \".false.\"' case ( error_cla_no_list ) if (. not . obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" has not \"nargs\" value' // & ' but an array has been passed to \"get\" method!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has not \"nargs\" value but an array has been passed to \"get\" method!' endif case ( error_cla_nargs_insufficient ) if (. not . obj % positional ) then if ( obj % nargs == '+' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" requires at least ' // & '1 argument but no one remains!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" requires ' // & trim ( adjustl ( obj % nargs )) // ' arguments but no enough ones remain!' endif else if ( obj % nargs == '+' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option requires at least 1 argument but no one remains' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option requires ' // & trim ( adjustl ( obj % nargs )) // ' arguments but no enough ones remain!' endif endif case ( error_cla_value_missing ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" needs a value that is not passed!' case ( error_cla_unknown ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: switch \"' // trim ( adjustl ( switch )) // '\" is unknown!' case ( error_cla_envvar_positional ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has \"envvar\" value that is not allowed for positional option!' case ( error_cla_envvar_not_store ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" is an envvar with action different from \"' // action_store // '\" that is not allowed!' case ( error_cla_envvar_nargs ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" is an envvar that is not allowed for list valued option!' case ( error_cla_store_star_positional ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has \"' // action_store_star // '\" action that is not allowed for positional option!' case ( error_cla_store_star_nargs ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for list valued option!' case ( error_cla_store_star_envvar ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for environment variable option!' case ( error_cla_action_unknown ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has unknown \"' // obj % act // '\" action!' endselect class is ( Type_Command_Line_Arguments_Group ) select case ( obj % error ) case ( error_clasg_consistency ) if ( obj % group /= '' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: group (command) name: \"' // obj % group // '\" consistency error:' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: consistency error:' endif write ( stderr , '(A)' ) prefd // ' \"' // trim ( str (. true ., a1 )) // '-th\" option has the same switch or abbreviated switch of \"' & // trim ( str (. true ., a2 )) // '-th\" option:' write ( stderr , '(A)' ) prefd // ' CLA(' // trim ( str (. true ., a1 )) // ') switches = ' // obj % cla ( a1 )% switch // ' ' // & obj % cla ( a1 )% switch_ab write ( stderr , '(A)' ) prefd // ' CLA(' // trim ( str (. true ., a2 )) // ') switches = ' // obj % cla ( a2 )% switch // ' ' // & obj % cla ( a2 )% switch_ab case ( error_clasg_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: the group \"' // obj % group // '\" and \"' // obj % m_exclude // '\" are mutually' // & ' exclusive, but both have been called!' endselect class is ( Type_Command_Line_Interface ) select case ( obj % error ) case ( error_cli_missing_cla ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: there is no option \"' // trim ( adjustl ( switch )) // '\"!' case ( error_cli_missing_selection_cla ) write ( stderr , '(A)' ) prefd // obj % progname // & ': error: to get an option value one of switch \"name\" or \"position\" must be provided!' case ( error_cli_missing_group ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: ther is no group (command) named \"' // trim ( adjustl ( group )) // '\"!' case ( error_cli_too_few_clas ) ! write(stderr,'(A)')prefd//obj%progname//': error: too few arguments ('//trim(str(.true.,Na))//')'//& ! ' respect the required ('//trim(str(.true.,obj%Na_required))//')' endselect endselect write ( stderr , '(A)' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine errored subroutine print_version ( obj , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print version. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( IN ) :: obj !< Object data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref write ( stdout , '(A)' ) prefd // obj % progname // ' version ' // obj % version if ( obj % license /= '' ) then write ( stdout , '(A)' ) prefd // obj % license endif if ( obj % authors /= '' ) then write ( stdout , '(A)' ) prefd // obj % authors endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_version elemental subroutine assign_object ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: lhs !< Left hand side. class ( Type_Object ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members if ( allocated ( rhs % progname )) lhs % progname = rhs % progname if ( allocated ( rhs % version )) lhs % version = rhs % version if ( allocated ( rhs % help )) lhs % help = rhs % help if ( allocated ( rhs % description )) lhs % description = rhs % description if ( allocated ( rhs % license )) lhs % license = rhs % license if ( allocated ( rhs % authors )) lhs % authors = rhs % authors if ( allocated ( rhs % epilog )) lhs % epilog = rhs % epilog if ( allocated ( rhs % m_exclude )) lhs % m_exclude = rhs % m_exclude lhs % error = rhs % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_object ! Type_Command_Line_Argument procedures elemental subroutine free_cla ( cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cla % free_object ! Type_Command_Line_Argument members if ( allocated ( cla % switch )) deallocate ( cla % switch ) if ( allocated ( cla % switch_ab )) deallocate ( cla % switch_ab ) if ( allocated ( cla % act )) deallocate ( cla % act ) if ( allocated ( cla % def )) deallocate ( cla % def ) if ( allocated ( cla % nargs )) deallocate ( cla % nargs ) if ( allocated ( cla % choices )) deallocate ( cla % choices ) if ( allocated ( cla % val )) deallocate ( cla % val ) if ( allocated ( cla % envvar )) deallocate ( cla % envvar ) cla % required = . false . cla % positional = . false . cla % position = 0_I4P cla % passed = . false . cla % hidden = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_cla elemental subroutine finalize_cla ( cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cla % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_cla subroutine check_cla ( cla , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( allocated ( cla % envvar )) then if ( cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_envvar_positional ) return endif if (. not . allocated ( cla % act )) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return else if ( cla % act /= action_store ) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return endif endif if ( allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_envvar_nargs ) return endif endif if ( allocated ( cla % act )) then if ( cla % act == action_store_star . and . cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_store_star_positional ) return endif if ( cla % act == action_store_star . and . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_store_star_nargs ) return endif if ( cla % act == action_store_star . and . allocated ( cla % envvar )) then call cla % errored ( pref = prefd , error = error_cla_store_star_envvar ) return endif if ( cla % act /= action_store . and . & cla % act /= action_store_star . and . & cla % act /= action_store_true . and . & cla % act /= action_store_false . and .& cla % act /= action_print_help . and . & cla % act /= action_print_vers ) then call cla % errored ( pref = prefd , error = error_cla_action_unknown ) return endif endif if ((. not . cla % required ). and .(. not . allocated ( cla % def ))) then call cla % errored ( pref = prefd , error = error_cla_optional_no_def ) return endif if (( cla % required ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_required_m_exclude ) return endif if (( cla % positional ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_positional_m_exclude ) return endif if ((. not . cla % positional ). and .(. not . allocated ( cla % switch ))) then call cla % errored ( pref = prefd , error = error_cla_named_no_name ) return elseif (( cla % positional ). and .( cla % position == 0_I4P )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_position ) return elseif (( cla % positional ). and .( cla % act /= action_store )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_store ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_cla subroutine check_choices_cla ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if CLA value is in allowed choices. !< !< @note This procedure can be called if and only if cla%choices has been allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. class ( * ), intent ( IN ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len ( cla % choices )), allocatable :: toks (:) !< Tokens for parsing choices list. integer ( I4P ) :: Nc !< Number of choices. logical :: val_in !< Flag for checking if val is in the choosen range. character ( len = :), allocatable :: val_str !< Value in string form. character ( len = :), allocatable :: tmp !< Temporary string for avoiding GNU gfrotran bug. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- val_in = . false . val_str = '' tmp = cla % choices call tokenize ( strin = tmp , delimiter = ',' , toks = toks , Nt = Nc ) select type ( val ) #ifdef r16p type is ( real ( R16P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R16P )) val_in = . true . enddo #endif type is ( real ( R8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R8P )) val_in = . true . enddo type is ( real ( R4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R4P )) val_in = . true . enddo type is ( integer ( I8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I8P )) val_in = . true . enddo type is ( integer ( I4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I4P )) val_in = . true . enddo type is ( integer ( I2P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I2P )) val_in = . true . enddo type is ( integer ( I1P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I1P )) val_in = . true . enddo type is ( character ( * )) val_str = val do c = 1 , Nc if ( val == toks ( c )) val_in = . true . enddo type is ( logical ) prefd = '' ; if ( present ( pref )) prefd = pref call cla % errored ( pref = prefd , error = error_cla_choices_logical ) endselect if (. not . val_in . and .( cla % error == 0 )) then prefd = '' ; if ( present ( pref )) prefd = pref call cla % errored ( pref = prefd , error = error_cla_not_in_choices , val_str = val_str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_choices_cla subroutine get_cla ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if ( cla % act == action_store . or . cla % act == action_store_star ) then if ( cla % passed . and . allocated ( cla % val )) then select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I1P ) type is ( logical ) read ( cla % val , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % val ) type is ( character ( * )) val = cla % val endselect elseif ( allocated ( cla % def )) then ! using default value select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I1P ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) type is ( character ( * )) val = cla % def endselect endif if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val , pref = prefd ) elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla subroutine get_cla_list ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsV ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsD ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect endif elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list function check_list_size_cla ( cla , Nv , val , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA multiple values list size consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), intent ( IN ) :: Nv !< Number of values. character ( * ), intent ( IN ) :: val !< First value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical :: is_ok !< Check result. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref is_ok = . true . if ( Nv == 1 ) then if ( trim ( adjustl ( val )) == '' ) then ! there is no real value, but only for nargs=+ this is a real error is_ok = . false . if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction check_list_size_cla subroutine get_cla_list_varying_R16P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return if ( Nv == 1 ) then if ( trim ( adjustl ( valsD ( 1 ))) == '' ) then if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif return endif endif allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P subroutine get_cla_list_varying_R8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P subroutine get_cla_list_varying_R4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P subroutine get_cla_list_varying_I8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P subroutine get_cla_list_varying_I4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P subroutine get_cla_list_varying_I2P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P subroutine get_cla_list_varying_I1P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P subroutine get_cla_list_varying_logical ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, logical. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical subroutine get_cla_list_varying_char ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, character. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsV ( v ))) enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsD ( v ))) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char function usage_cla ( cla , pref ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLA usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: usage !< Usage string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then prefd = '' ; if ( present ( pref )) prefd = pref if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then usage = '' select case ( cla % nargs ) case ( '+' ) usage = usage // ' value#1 [value#2...]' case ( '*' ) usage = usage // ' [value#1 value#2...]' case default do a = 1 , cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) usage = usage // ' value#' // trim ( str (. true ., a )) enddo endselect if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // usage // ', ' // trim ( adjustl ( cla % switch_ab )) // usage else usage = '   ' // trim ( adjustl ( cla % switch )) // usage endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ' value, ' // trim ( adjustl ( cla % switch_ab )) // ' value' else usage = '   ' // trim ( adjustl ( cla % switch )) // ' value' endif endif else usage = '  value' endif if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif elseif ( cla % act == action_store_star ) then usage = '  [value]' if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ', ' // trim ( adjustl ( cla % switch_ab )) else usage = '   ' // trim ( adjustl ( cla % switch )) endif endif usage = prefd // usage if ( cla % positional ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( str (. true ., cla % position )) // '-th argument' if ( allocated ( cla % envvar )) then if ( cla % envvar /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'environment variable name \"' // trim ( adjustl ( cla % envvar )) // '\"' endif endif if (. not . cla % required ) then if ( cla % def /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'default value ' // trim ( adjustl ( cla % def )) endif endif if ( cla % m_exclude /= '' ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'mutually exclude \"' // cla % m_exclude // '\"' usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( adjustl ( cla % help )) else usage = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_cla function signature_cla ( cla ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then select case ( cla % nargs ) case ( '+' ) signd = ' value#1 [value#2 value#3...]' case ( '*' ) signd = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) signd = '' do a = 1 , nargs signd = signd // ' value#' // trim ( str (. true ., a )) enddo endselect else signd = ' value' endif if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) // signd else signd = ' [' // trim ( adjustl ( cla % switch )) // signd // ']' endif else if ( cla % required ) then signd = ' value' else signd = ' [value]' endif endif elseif ( cla % act == action_store_star ) then signd = ' [value]' else if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) else signd = ' [' // trim ( adjustl ( cla % switch )) // ']' endif endif else signd = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_cla elemental subroutine assign_cla ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Argument ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % required = rhs % required lhs % positional = rhs % positional lhs % position = rhs % position lhs % passed = rhs % passed lhs % hidden = rhs % hidden return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cla ! Type_Command_Line_Arguments_Group procedures elemental subroutine free_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call clasg % free_object ! Type_Command_Line_Arguments_Group members if ( allocated ( clasg % group )) deallocate ( clasg % group ) if ( allocated ( clasg % cla )) then call clasg % cla % free deallocate ( clasg % cla ) endif clasg % Na = 0_I4P clasg % Na_required = 0_I4P clasg % Na_optional = 0_I4P clasg % called = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_clasg elemental subroutine finalize_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call clasg % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_clasg subroutine check_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a , aa !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! verifing if CLAs switches are unique CLA_unique : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then do aa = 1 , clasg % Na if (( a /= aa ). and .(. not . clasg % cla ( aa )% positional )) then if (( clasg % cla ( a )% switch == clasg % cla ( aa )% switch ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch ). or .& ( clasg % cla ( a )% switch == clasg % cla ( aa )% switch_ab ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch_ab )) then call clasg % errored ( pref = prefd , error = error_clasg_consistency , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! updating mutually exclusive relations CLA_exclude : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % defined ( switch = clasg % cla ( a )% m_exclude , pos = aa )) then clasg % cla ( aa )% m_exclude = clasg % cla ( a )% switch endif endif endif enddo CLA_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_clasg subroutine check_required_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLAs are passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( clasg % called ) then do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) then if (. not . clasg % cla ( a )% passed ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_missing_required ) clasg % error = clasg % cla ( a )% error write ( stdout , '(A)' ) clasg % usage ( pref = prefd ) return endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_required_clasg subroutine check_m_exclusive_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs have been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref do a = 1 , clasg % Na if ( clasg % cla ( a )% passed ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % passed ( switch = clasg % cla ( a )% m_exclude )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_m_exclude ) clasg % error = clasg % cla ( a )% error return endif endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive_clasg subroutine add_cla_clasg ( clasg , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. type ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. type ( Type_Command_Line_Argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % Na > 0_I4P ) then if (. not . cla % positional ) then allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , clasg % Na cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( clasg % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , clasg % Na + 1 cla_list_new ( c ) = clasg % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = clasg % cla ) clasg % Na = clasg % Na + 1 if ( cla % required ) then clasg % Na_required = clasg % Na_required + 1 else clasg % Na_optional = clasg % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) prefd = '' ; if ( present ( pref )) prefd = pref call clasg % check ( pref = prefd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_cla_clasg pure function passed_clasg ( clasg , switch , position ) result ( passed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if ( clasg % Na > 0 ) then if ( present ( switch )) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then passed = clasg % cla ( a )% passed exit endif endif enddo elseif ( present ( position )) then passed = clasg % cla ( position )% passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed_clasg function defined_clasg ( clasg , switch , pos ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( OUT ) :: pos !< CLA position. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if ( present ( pos )) pos = 0 if ( clasg % Na > 0 ) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_clasg subroutine parse_clasg ( clasg , pref , args ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAs group arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), intent ( IN ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , clasg % Na ! loop ver CLAs group clas named options if (. not . clasg % cla ( a )% positional ) then if ( trim ( adjustl ( clasg % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( clasg % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( clasg % cla ( a )% act == action_store ) then found_val = . false . if ( allocated ( clasg % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = clasg % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then clasg % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) then clasg % cla ( a )% val = clasg % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( clasg % cla ( a )% nargs )) then clasg % cla ( a )% val = '' select case ( clasg % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( clasg % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) enddo arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_value_missing ) clasg % error = clasg % cla ( a )% error return endif arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( clasg % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . endif endif if (. not . found ) then ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) clasg % cla ( a )% val = clasg % cla ( a )% def endif elseif ( clasg % cla ( a )% act == action_print_help ) then clasg % error = status_clasg_print_h elseif ( clasg % cla ( a )% act == action_print_vers ) then clasg % error = status_clasg_print_v endif clasg % cla ( a )% passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . clasg % cla ( arg )% positional ) then ! current argument (arg-th) is not positional... there is a problem! call clasg % cla ( arg )% errored ( pref = prefd , error = error_cla_unknown , switch = trim ( adjustl ( args ( arg )))) clasg % error = clasg % cla ( arg )% error return else ! positional CLA always stores a value clasg % cla ( arg )% val = trim ( adjustl ( args ( arg ))) clasg % cla ( arg )% passed = . true . endif endif enddo call clasg % check_m_exclusive ( pref = prefd ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_clasg function usage_clasg ( clasg , pref , no_header ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAs group usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref usage = clasg % progname ; if ( clasg % group /= '' ) usage = clasg % progname // ' ' // clasg % group usage = prefd // clasg % help // ' ' // usage // clasg % signature () if ( clasg % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // clasg % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( clasg % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif if ( clasg % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , clasg % Na if (. not . clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_clasg function signature_clasg ( clasg ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs group signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = '' do a = 1 , clasg % Na signd = signd // clasg % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_clasg elemental subroutine assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Arguments_Group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % called = rhs % called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_clasg ! Type_Command_Line_Interface procedures elemental subroutine free ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cli % free_object ! Type_Command_Line_Interface members if ( allocated ( cli % clasg )) then do g = 0 , size ( cli % clasg , dim = 1 ) - 1 call cli % clasg ( g )% free enddo deallocate ( cli % clasg ) endif if ( allocated ( cli % examples )) deallocate ( cli % examples ) cli % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental subroutine finalize ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize subroutine init ( cli , progname , version , help , description , license , authors , examples , epilog , disable_hv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: progname !< Program name. character ( * ), optional , intent ( IN ) :: version !< Program version. character ( * ), optional , intent ( IN ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( IN ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( IN ) :: license !< License description. character ( * ), optional , intent ( IN ) :: authors !< Authors list. character ( * ), optional , intent ( IN ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( IN ) :: epilog !< Epilog message. logical , optional , intent ( IN ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free if ( present ( progname )) then cli % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then cli % progname = prog_invocation else cli % progname = 'program' endif endif cli % version = 'unknown' ; if ( present ( version )) cli % version = version cli % help = 'usage: ' ; if ( present ( help )) cli % help = help cli % description = '' ; if ( present ( description )) cli % description = description cli % license = '' ; if ( present ( license )) cli % license = license cli % authors = '' ; if ( present ( authors )) cli % authors = authors cli % epilog = '' ; if ( present ( epilog )) cli % epilog = epilog if ( present ( disable_hv )) cli % disable_hv = disable_hv if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( cli % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: cli % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif cli % examples = examples endif ! initialize only the first default group allocate ( cli % clasg ( 0 : 0 )) call cli % clasg ( 0 )% assign_object ( cli ) cli % clasg ( 0 )% group = '' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine add_group ( cli , help , description , exclude , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLAs group to CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: help !< Help message. character ( * ), optional , intent ( IN ) :: description !< Detailed description. character ( * ), optional , intent ( IN ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( IN ) :: group !< Name of the grouped CLAs. type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. integer ( I4P ) :: gi !< Group index !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cli % defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( cli % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) !    clasg_list_new(0:Ng-1) = cli%clasg(0:Ng-1) ! Not working on Intel Fortran 15.0.2 do gi = 0 , Ng - 1 clasg_list_new ( gi ) = cli % clasg ( gi ) enddo call clasg_list_new ( Ng )% assign_object ( cli ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( cli % clasg ) allocate ( cli % clasg ( 0 : Ng )) cli % clasg = clasg_list_new deallocate ( clasg_list_new ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_group subroutine set_mutually_exclusive_groups ( cli , group1 , group2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set two CLAs group ad mutually exclusive. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( IN ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 , g2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( cli % defined_group ( group = group1 , g = g1 ). and . cli % defined_group ( group = group2 , g = g2 )) then cli % clasg ( g1 )% m_exclude = group2 cli % clasg ( g2 )% m_exclude = group1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_mutually_exclusive_groups subroutine add ( cli , pref , group , group_index , switch , switch_ab , help , required , positional , position , hidden , act , def , nargs ,& choices , exclude , envvar , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( IN ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( IN ) :: help !< Help message describing the CLA. logical , optional , intent ( IN ) :: required !< Flag for set required argument. logical , optional , intent ( IN ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical , optional , intent ( IN ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( IN ) :: act !< CLA value action. character ( * ), optional , intent ( IN ) :: def !< Default value. character ( * ), optional , intent ( IN ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( IN ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( IN ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( IN ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. type ( Type_Command_Line_Argument ) :: cla !< CLA data. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initializing CLA call cla % assign_object ( cli ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % required = . false . ; if ( present ( required )) cla % required = required cla % positional = . false . ; if ( present ( positional )) cla % positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % hidden = . false . ; if ( present ( hidden )) cla % hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( def )) cla % val = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar prefd = '' ; if ( present ( pref )) prefd = pref call cla % check ( pref = prefd ) ; cli % error = cla % error if ( cli % error /= 0 ) then if ( present ( error )) error = cli % error return endif ! adding CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call cli % clasg ( 0 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( 0 )% error elseif ( present ( group )) then if ( cli % defined_group ( group = group , g = g )) then call cli % clasg ( g )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( g )% error else call cli % add_group ( group = group ) call cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( cli % clasg , dim = 1 ) - 1 ) then call cli % clasg ( group_index )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( group_index )% error endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add subroutine check ( cli , pref , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLAs data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref do g = 0 , size ( cli % clasg , dim = 1 ) - 1 ! check group consistency call cli % clasg ( g )% check ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( present ( error )) error = cli % error if ( cli % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( cli % clasg ( g )% m_exclude /= '' ) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) cli % clasg ( gg )% m_exclude = cli % clasg ( g )% group endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check subroutine check_m_exclusive ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs group have been called. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do g = 1 , size ( cli % clasg , dim = 1 ) - 1 if ( cli % clasg ( g )% called . and .( cli % clasg ( g )% m_exclude /= '' )) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) then if ( cli % clasg ( gg )% called ) then prefd = '' ; if ( present ( pref )) prefd = pref call cli % clasg ( g )% errored ( pref = prefd , error = error_clasg_m_exclude ) cli % error = cli % clasg ( g )% error exit endif endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive function passed ( cli , group , switch , position ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if (. not . present ( group )) then if ( present ( switch )) then passed = cli % clasg ( 0 )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( 0 )% passed ( position = position ) endif else if ( cli % defined_group ( group = group , g = g )) then if ( present ( switch )) then passed = cli % clasg ( g )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( g )% passed ( position = position ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed function defined_group ( cli , group , g ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. integer ( I4P ), optional , intent ( OUT ) :: g !< Index of group. logical :: defined !< Check if a CLAs group has been defined. integer ( I4P ) :: gg , ggg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . do gg = 0 , size ( cli % clasg , dim = 1 ) - 1 ggg = gg if ( allocated ( cli % clasg ( gg )% group )) defined = ( cli % clasg ( gg )% group == group ) if ( defined ) exit enddo if ( present ( g )) g = ggg return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_group function called_group ( cli , group ) result ( called ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been runned. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: called !< Check if a CLAs group has been runned. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- called = . false . if ( cli % defined_group ( group = group , g = g )) called = cli % clasg ( g )% called return !--------------------------------------------------------------------------------------------------------------------------------- endfunction called_group function defined ( cli , switch , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if (. not . present ( group )) then defined = cli % clasg ( 0 )% defined ( switch = switch ) else if ( cli % defined_group ( group = group , g = g )) defined = cli % clasg ( g )% defined ( switch = switch ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined subroutine parse ( cli , pref , args , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse Command Line Interfaces by means of a previously initialized CLAs groups list. !< !< @note The leading and trailing white spaces are removed from CLA values. !< !< @note If the *args* argument is passed the command line arguments are taken from it and not from the actual program CLI !< invocations. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: args !< String containing command line arguments. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter for CLAs group. integer ( I4P ), allocatable :: ai (:,:) !< Counter for CLAs grouped. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! add help and version switches if not done by user if (. not . cli % disable_hv ) then do g = 0 , size ( cli % clasg , dim = 1 ) - 1 if (. not .( cli % defined ( group = cli % clasg ( g )% group , switch = '--help' ). and . cli % defined ( group = cli % clasg ( g )% group , switch = '-h' ))) & call cli % add ( pref = prefd , & group_index = g , & switch = '--help' , & switch_ab = '-h' , & help = 'Print this help message' , & required = . false ., & def = '' , & act = 'print_help' ) if (. not .( cli % defined ( group = cli % clasg ( g )% group , switch = '--version' ). and . cli % defined ( group = cli % clasg ( g )% group , switch = '-v' ))) & call cli % add ( pref = prefd , & group_index = g , & switch = '--version' , & switch_ab = '-v' , & help = 'Print version' , & required = . false ., & def = '' , & act = 'print_version' ) enddo endif ! add hidden CLA '--' for getting the rid of eventual trailing CLAs garbage do g = 0 , size ( cli % clasg , dim = 1 ) - 1 if (. not . cli % defined ( group = cli % clasg ( g )% group , switch = '--' )) & call cli % add ( pref = prefd , & group_index = g , & switch = '--' , & required = . false ., & hidden = . true ., & nargs = '*' , & def = '' , & act = 'store' ) enddo ! parsing passed CLAs grouping in indexes if ( present ( args )) then call cli % get_args ( args = args , ai = ai ) else call cli % get_args ( ai = ai ) endif ! checking CLI consistency call cli % check ( pref = prefd ) if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! parsing cli do g = 0 , size ( ai , dim = 1 ) - 1 if ( ai ( g , 1 ) > 0 ) call cli % clasg ( g )% parse ( pref = prefd , args = cli % args ( ai ( g , 1 ): ai ( g , 2 ))) cli % error = cli % clasg ( g )% error if ( cli % error /= 0 ) exit enddo if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! trapping the special cases of version/help printing if ( cli % error == status_clasg_print_v ) then call cli % print_version ( pref = prefd ) stop elseif ( cli % error == status_clasg_print_h ) then write ( stdout , '(A)' ) cli % usage ( pref = prefd , g = g ) stop endif ! checking if all required CLAs have been passed do g = 0 , size ( ai , dim = 1 ) - 1 call cli % clasg ( g )% check_required ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( cli % error > 0 ) exit enddo if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! check mutually exclusive interaction call cli % check_m_exclusive ( pref = prefd ) if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse subroutine get_clasg_indexes ( cli , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. integer ( I4P ) :: g !< Counter for CLAs group. logical :: found !< Flag for inquiring if a named group is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( ai ( 0 : size ( cli % clasg , dim = 1 ) - 1 , 1 : 2 )) ai = 0 if ( allocated ( cli % args )) then Na = size ( cli % args , dim = 1 ) a = 0 found = . false . search_named : do while ( a < Na ) a = a + 1 if ( cli % defined_group ( group = trim ( cli % args ( a )), g = g )) then found = . true . cli % clasg ( g )% called = . true . ai ( g , 1 ) = a + 1 aa = a do while ( aa < Na ) aa = aa + 1 if ( cli % defined_group ( group = trim ( cli % args ( aa )))) then a = aa - 1 ai ( g , 2 ) = a exit else ai ( g , 2 ) = aa endif enddo elseif (. not . found ) then ai ( 0 , 2 ) = a endif enddo search_named if ( ai ( 0 , 2 ) > 0 ) then ai ( 0 , 1 ) = 1 cli % clasg ( 0 )% called = . true . elseif ( all ( ai == 0 )) then cli % clasg ( 0 )% called = . true . endif else cli % clasg ( 0 )% called = . true . endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_clasg_indexes subroutine get_args_from_string ( cli , args , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from string. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: args !< String containing command line arguments. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. character ( len = len_trim ( args )) :: argsd !< Dummy string containing command line arguments. character ( len = len_trim ( args )), allocatable :: toks (:) !< CLAs tokenized. integer ( I4P ) :: Nt !< Number of tokens. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: t !< Counter for tokens. integer ( I4P ) :: c !< Counter for characters inside tokens. #ifndef __GFORTRAN__ integer ( I4P ) :: length !< Maxium lenght of arguments string. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! prepare cli arguments list if ( allocated ( cli % args )) deallocate ( cli % args ) ! sanitize arguments string argsd = trim ( args ) if ( index ( args , \"'\" ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = \"'\" ) elseif ( index ( args , '\"' ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = '\"' ) endif ! tokenize arguments string; the previously sanitized white spaces inside tokens are restored call tokenize ( strin = argsd , delimiter = ' ' , toks = toks , Nt = Nt ) Na = 0 find_number_of_valid_arguments : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then Na = Na + 1 do c = 1 , len ( toks ( t )) if ( toks ( t )( c : c ) == \"'\" ) toks ( t )( c : c ) = \" \" enddo endif enddo find_number_of_valid_arguments if ( Na > 0 ) then ! allocate cli arguments list #ifdef __GFORTRAN__ allocate ( cli % args ( 1 : Na )) #else length = 0 find_longest_arg : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) length = max ( length , len_trim ( adjustl ( toks ( t )))) enddo find_longest_arg allocate ( character ( length ) :: cli % args ( 1 : Na )) #endif ! construct arguments list a = 0 get_args : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then a = a + 1 cli % args ( a ) = trim ( adjustl ( toks ( t ))) endif enddo get_args endif call cli % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- contains function sanitize_args ( argsin , delimiter ) result ( sanitized ) !------------------------------------------------------------------------------------------------------------------------------- !< Sanitize arguments string. !< !< Substitute white spaces enclosed into string-arguments, i.e. 'string argument with spaces...' or !< \"string argument with spaces...\" with a safe equivalent for tokenization against white spaces, i.e. the finally tokenized !< string is string'argument'with'spaces... !< !< @note The white spaces are reintroduce later. !------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: argsin !< Arguments string. character ( * ), intent ( IN ) :: delimiter !< Delimiter enclosing string argument. character ( len = len_trim ( argsin )) :: sanitized !< Arguments string sanitized. character ( len = len_trim ( argsin )), allocatable :: tok (:) !< Arguments string tokens. integer ( I4P ) :: Nt !< Number of command line arguments passed. integer ( I4P ) :: t , tt !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- call tokenize ( strin = trim ( argsin ), delimiter = delimiter , toks = tok , Nt = Nt ) do t = 2 , Nt , 2 do tt = 1 , len_trim ( adjustl ( tok ( t ))) if ( tok ( t )( tt : tt ) == ' ' ) tok ( t )( tt : tt ) = \"'\" enddo enddo sanitized = '' do t = 1 , Nt sanitized = trim ( sanitized ) // \" \" // trim ( adjustl ( tok ( t ))) enddo sanitized = trim ( adjustl ( sanitized )) return !------------------------------------------------------------------------------------------------------------------------------- endfunction sanitize_args endsubroutine get_args_from_string subroutine get_args_from_invocation ( cli , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from CLI invocation. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. character ( max_val_len ) :: switch !< Switch name. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( cli % args )) deallocate ( cli % args ) Na = command_argument_count () if ( Na > 0 ) then #ifdef __GFORTRAN__ allocate ( cli % args ( 1 : Na )) #else aa = 0 find_longest_arg : do a = 1 , Na call get_command_argument ( a , switch ) aa = max ( aa , len_trim ( switch )) enddo find_longest_arg allocate ( character ( aa ) :: cli % args ( 1 : Na )) #endif get_args : do a = 1 , Na call get_command_argument ( a , switch ) cli % args ( a ) = trim ( adjustl ( switch )) enddo get_args endif call cli % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_args_from_invocation subroutine get_cla_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( cli % error == 0. and . cli % clasg ( g )% called ) then if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( position )% error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_cli subroutine get_cla_list_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_cli subroutine get_cla_list_varying_R16P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P_cli subroutine get_cla_list_varying_R8P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P_cli subroutine get_cla_list_varying_R4P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P_cli subroutine get_cla_list_varying_I8P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P_cli subroutine get_cla_list_varying_I4P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P_cli subroutine get_cla_list_varying_I2P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P_cli subroutine get_cla_list_varying_I1P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P_cli subroutine get_cla_list_varying_logical_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, logical. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical_cli subroutine get_cla_list_varying_char_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, character. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char_cli function usage ( cli , g , pref , no_header , no_examples , no_epilog ) result ( usaged ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage of CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. integer ( I4P ), intent ( IN ) :: g !< Group index. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( IN ) :: no_examples !< Avoid insert examples to usage. logical , optional , intent ( IN ) :: no_epilog !< Avoid insert epilogue to usage. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: usaged !< Usage string. logical :: no_headerd !< Avoid insert header to usage. logical :: no_examplesd !< Avoid insert examples to usage. logical :: no_epilogd !< Avoid insert epilogue to usage. integer ( I4P ) :: gi !< Counter. integer ( I4P ) :: e !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- no_headerd = . false . ; if ( present ( no_header )) no_headerd = no_header no_examplesd = . false . ; if ( present ( no_examples )) no_examplesd = no_examples no_epilogd = . false . ; if ( present ( no_epilog )) no_epilogd = no_epilog prefd = '' ; if ( present ( pref )) prefd = pref if ( g > 0 ) then ! usage of a specific command usaged = cli % clasg ( g )% usage ( pref = prefd , no_header = no_headerd ) else ! usage of whole CLI if ( no_headerd ) then usaged = '' else usaged = prefd // cli % help // cli % progname // ' ' // cli % signature () if ( cli % description /= '' ) usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // cli % description endif if ( cli % clasg ( 0 )% Na > 0 ) usaged = usaged // new_line ( 'a' ) // cli % clasg ( 0 )% usage ( pref = prefd , no_header = . true .) if ( size ( cli % clasg , dim = 1 ) > 1 ) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Commands:' do gi = 1 , size ( cli % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // cli % clasg ( gi )% group usaged = usaged // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // cli % clasg ( gi )% description enddo usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'For more detailed commands help try:' do gi = 1 , size ( cli % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // cli % progname // ' ' // cli % clasg ( gi )% group // ' -h,--help' enddo endif endif if ( allocated ( cli % examples ). and .(. not . no_examplesd )) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Examples:' do e = 1 , size ( cli % examples , dim = 1 ) usaged = usaged // new_line ( 'a' ) // prefd // '   ' // trim ( cli % examples ( e )) enddo endif if ( cli % epilog /= '' . and .(. not . no_epilogd )) usaged = usaged // new_line ( 'a' ) // prefd // cli % epilog return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage function signature ( cli ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLI signature. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = cli % clasg ( 0 )% signature () if ( size ( cli % clasg , dim = 1 ) > 1 ) then signd = signd // ' {' // cli % clasg ( 1 )% group do g = 2 , size ( cli % clasg , dim = 1 ) - 1 signd = signd // ',' // cli % clasg ( g )% group enddo signd = signd // '} ...' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature subroutine print_usage ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage of CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref write ( stdout , '(A)' ) cli % usage ( pref = prefd , g = 0 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_usage subroutine save_man_page ( cli , man_file , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save man page build on the CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: man_file !< Output file name for saving man page. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: man !< Man page. integer ( I4P ) :: idate ( 1 : 8 ) !< Integer array for handling the date. integer ( I4P ) :: e !< Counter. integer ( I4P ) :: u !< Unit file handler. character ( * ), parameter :: month ( 12 ) = [ \"Jan\" ,& \"Feb\" ,& \"Mar\" ,& \"Apr\" ,& \"May\" ,& \"Jun\" ,& \"Jul\" ,& \"Aug\" ,& \"Sep\" ,& \"Oct\" ,& \"Nov\" ,& \"Dec\" ] !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call date_and_time ( values = idate ) man = '.TH ' // cli % progname // ' \"1\" \"' // month ( idate ( 2 )) // ' ' // trim ( adjustl ( strz ( 4 , idate ( 1 )))) // '\" \"version ' // cli % version // & '\" \"' // cli % progname // ' Manual\"' man = man // new_line ( 'a' ) // '.SH NAME' man = man // new_line ( 'a' ) // cli % progname // ' - manual page for ' // cli % progname // ' version ' // cli % version man = man // new_line ( 'a' ) // '.SH SYNOPSIS' man = man // new_line ( 'a' ) // '.B ' // cli % progname // new_line ( 'a' ) // trim ( adjustl ( cli % signature ())) if ( cli % description /= '' ) man = man // new_line ( 'a' ) // '.SH DESCRIPTION' // new_line ( 'a' ) // cli % description if ( cli % clasg ( 0 )% Na > 0 ) then man = man // new_line ( 'a' ) // '.SH OPTIONS' man = man // new_line ( 'a' ) // cli % usage ( no_header = . true ., no_examples = . true ., no_epilog = . true ., g = 0 ) endif if ( allocated ( cli % examples )) then man = man // new_line ( 'a' ) // '.SH EXAMPLES' man = man // new_line ( 'a' ) // '.PP' man = man // new_line ( 'a' ) // '.nf' man = man // new_line ( 'a' ) // '.RS' do e = 1 , size ( cli % examples , dim = 1 ) man = man // new_line ( 'a' ) // trim ( cli % examples ( e )) enddo man = man // new_line ( 'a' ) // '.RE' man = man // new_line ( 'a' ) // '.fi' man = man // new_line ( 'a' ) // '.PP' endif if ( cli % authors /= '' ) man = man // new_line ( 'a' ) // '.SH AUTHOR' // new_line ( 'a' ) // cli % authors if ( cli % license /= '' ) man = man // new_line ( 'a' ) // '.SH COPYRIGHT' // new_line ( 'a' ) // cli % license open ( newunit = u , file = trim ( adjustl ( man_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) man else write ( u , \"(A)\" ) man endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_man_page elemental subroutine assign_cli ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Interface ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Interface members if ( allocated ( rhs % clasg )) lhs % clasg = rhs % clasg if ( allocated ( rhs % examples )) lhs % examples = rhs % examples lhs % disable_hv = rhs % disable_hv return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cli endmodule Data_Type_Command_Line_Interface","tags":"","loc":"sourcefile/data_type_command_line_interface.f90.html","title":"Data_Type_Command_Line_Interface.F90 – Shu-Osher-shock-tube-problem"},{"text":"type, public, extends(integrand) :: euler_1D type~~euler_1d~~InheritsGraph type~euler_1d euler_1D type~weno_interpolator_upwind weno_interpolator_upwind type~weno_interpolator_upwind->type~euler_1d weno weno_interpolator weno_interpolator weno_interpolator->type~weno_interpolator_upwind integrand integrand integrand->type~euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Euler 1D PDEs system field. It is a FOODIE integrand class concrete extension. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E)\n Finalize field. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type( weno_interpolator_upwind ), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalization Procedures final :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( euler_1D ), intent(inout) :: self Euler field. Description Destroy field. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. procedure, public, pass(self) :: destroy Destroy field. private puresubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. Description Destroy field. procedure, public, pass(self) :: output Extract Euler field. private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private purefunction compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. procedure, public, pass(lhs) :: local_error => euler_local_error ||euler-euler||. private function euler_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 euler approximations. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. private function euler_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. private function euler_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. private function real_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. procedure, public, pass(lhs) :: add => add_euler Euler + Euler operator. private function add_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. procedure, public, pass(lhs) :: sub => sub_euler Euler - Euler. private function sub_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. private subroutine euler_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private purefunction primitive2conservative (self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private purefunction conservative2primitive (self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private puresubroutine impose_boundary_conditions (self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private puresubroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Source Code type , extends ( integrand ) :: euler_1D !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !<||euler-euler||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D","tags":"","loc":"type/euler_1d.html","title":"euler_1D – Shu-Osher-shock-tube-problem "},{"text":"type, public, abstract :: integrand Abstract type for building FOODIE ODE integrators. Components Type Visibility Attributes Name Initial class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. Type-Bound Procedures procedure( time_derivative ), public, pass(self), deferred :: t Time derivative, residuals. function time_derivative (self, t) result(dState_dt) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function. procedure( local_error_operator ), public, pass(lhs), deferred :: local_error ||integrand - integrand||. function local_error_operator (lhs, rhs) result(error) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 solution approximations. procedure( symmetric_operator ), public, pass(lhs), deferred :: integrand_multiply_integrand Integrand * integrand operator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. procedure( integrand_op_real ), public, pass(lhs), deferred :: integrand_multiply_real Integrand * real operator. function integrand_op_real (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real. procedure( real_op_integrand ), public, pass(rhs), deferred :: real_multiply_integrand Real * integrand operator. function real_op_integrand (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand. procedure( symmetric_operator ), public, pass(lhs), deferred :: add Integrand + integrand operator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. procedure( symmetric_operator ), public, pass(lhs), deferred :: sub Integrand - integrand operator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. procedure( assignment_integrand ), public, pass(lhs), deferred :: assign_integrand Integrand = integrand. subroutine assignment_integrand (lhs, rhs) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. pass(lhs) deferred local_error () Arguments None Description ||integrand - integrand||. generic, public :: operator(+) => add Overloading + operator. pass(lhs) deferred add () Arguments None Description Integrand + integrand operator. generic, public :: operator(-) => sub Overloading - operator. pass(lhs) deferred sub () Arguments None Description Integrand - integrand operator. generic, public :: operator(*) => integrand_multiply_integrand , real_multiply_integrand , integrand_multiply_real Overloading * operator. pass(lhs) deferred integrand_multiply_integrand () Arguments None Description Integrand * integrand operator. pass(rhs) deferred real_multiply_integrand () Arguments None Description Real * integrand operator. pass(lhs) deferred integrand_multiply_real () Arguments None Description Integrand * real operator. generic, public :: assignment(=) => assign_integrand Overloading = assignament. pass(lhs) deferred assign_integrand () Arguments None Description Integrand = integrand. Source Code type , abstract :: integrand !< Abstract type for building FOODIE ODE integrators. #ifdef CAF class ( * ), allocatable :: dummy_to_allow_extensions [:] !< Dummy member to allow concrete extensions with coarray members. #endif contains ! public deferred procedures that concrete integrand-field must implement procedure ( time_derivative ), pass ( self ), deferred , public :: t !< Time derivative, residuals. ! operators procedure ( local_error_operator ), pass ( lhs ), deferred , public :: local_error !< ||integrand - integrand||. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_multiply_integrand !< Integrand * integrand operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_multiply_real !< Integrand * real operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_multiply_integrand !< Real * integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: add !< Integrand + integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: sub !< Integrand - integrand operator. procedure ( assignment_integrand ), pass ( lhs ), deferred , public :: assign_integrand !< Integrand = integrand. ! operators overloading generic , public :: operator (. lterror .) => local_error !< Estimate local truncation error. generic , public :: operator ( + ) => add !< Overloading + operator. generic , public :: operator ( - ) => sub !< Overloading - operator. generic , public :: operator ( * ) => integrand_multiply_integrand , & real_multiply_integrand , & integrand_multiply_real !< Overloading * operator. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. endtype integrand","tags":"","loc":"type/integrand.html","title":"integrand – Shu-Osher-shock-tube-problem "},{"text":"type, public :: tvd_runge_kutta_integrator FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. Note The integrator must be created or initialized (initialize the RK coefficients) before used.\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Source Code type :: tvd_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype tvd_runge_kutta_integrator","tags":"","loc":"type/tvd_runge_kutta_integrator.html","title":"tvd_runge_kutta_integrator – Shu-Osher-shock-tube-problem "},{"text":"type, public :: euler_explicit_integrator FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. Note The integrator can be used directly without any initialization. Type-Bound Procedures procedure, public, nopass :: integrate Integrate integrand field. private subroutine integrate (U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. Description Integrate field with explicit Euler scheme, 1st order. Source Code type :: euler_explicit_integrator !< FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< @note The integrator can be used directly without any initialization. contains procedure , nopass , public :: integrate !< Integrate integrand field. endtype euler_explicit_integrator","tags":"","loc":"type/euler_explicit_integrator.html","title":"euler_explicit_integrator – Shu-Osher-shock-tube-problem "},{"text":"type, public :: leapfrog_integrator FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Note The integrator could be used without initialialization (initialize the time filter coefficients) if the defulat values\n are suitable for the problem. Components Type Visibility Attributes Name Initial real(kind=R_P), private :: nu = 0.01_R_P Robert-Asselin filter coefficient. real(kind=R_P), private :: alpha = 0.53_R_P Robert-Asselin-Williams filter coefficient. Type-Bound Procedures procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, nu, alpha) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(inout) :: self LF integrator. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. Description Create the actual leapfrog integrator: initialize the filter coefficient. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, filter) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(in) :: self LF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:2) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. class( integrand ), intent(inout), optional :: filter Filter field displacement. Description Integrate field with leapfrog class scheme. Source Code type :: leapfrog_integrator !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. !< !< @note The integrator could be used without initialialization (initialize the time filter coefficients) if the defulat values !< are suitable for the problem. private real ( R_P ) :: nu = 0.01_R_P !< Robert-Asselin filter coefficient. real ( R_P ) :: alpha = 0.53_R_P !< Robert-Asselin-Williams filter coefficient. contains procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. endtype leapfrog_integrator","tags":"","loc":"type/leapfrog_integrator.html","title":"leapfrog_integrator – Shu-Osher-shock-tube-problem "},{"text":"type, public :: adams_bashforth_integrator FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 4rd order accurate. Note The integrator must be created or initialized (initialize the b coefficients) before used.\n Finalize object. Inherited By type~~adams_bashforth_integrator~~InheritedByGraph type~adams_bashforth_integrator adams_bashforth_integrator type~adams_bashforth_moulton_integrator adams_bashforth_moulton_integrator type~adams_bashforth_integrator->type~adams_bashforth_moulton_integrator predictor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps. real(kind=R_P), private, allocatable :: b (:) b coefficients. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth integrator: initialize the b coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, autoupdate) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Description Integrate field with Adams-Bashforth class scheme. procedure, public, pass(self) :: update_previous Cyclic update previous time steps. private subroutine update_previous (self, U, previous) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Description Cyclic update previous time steps. Source Code type :: adams_bashforth_integrator !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 4rd order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. private integer ( I_P ) :: steps = 0 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< b coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. final :: finalize !< Finalize object. endtype adams_bashforth_integrator","tags":"","loc":"type/adams_bashforth_integrator.html","title":"adams_bashforth_integrator – Shu-Osher-shock-tube-problem "},{"text":"type, public :: adams_moulton_integrator FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 3rd order accurate. Note The integrator must be created or initialized (initialize the b coefficients) before used.\n Finalize object. Inherited By type~~adams_moulton_integrator~~InheritedByGraph type~adams_moulton_integrator adams_moulton_integrator type~adams_bashforth_moulton_integrator adams_bashforth_moulton_integrator type~adams_moulton_integrator->type~adams_bashforth_moulton_integrator corrector Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = -1 Number of time steps. real(kind=R_P), private, allocatable :: b (:) b coefficients. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( adams_moulton_integrator ), intent(inout) :: self AB integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. Description Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, steps) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Moulton integrator: initialize the b coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, iterations, autoupdate) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Description Integrate field with Adams-Moulton class scheme. procedure, public, pass(self) :: update_previous Cyclic update previous time steps. private subroutine update_previous (self, U, previous) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Description Cyclic update previous time steps. Source Code type :: adams_moulton_integrator !< FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 3rd order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. private integer ( I_P ) :: steps =- 1 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< b coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. final :: finalize !< Finalize object. endtype adams_moulton_integrator","tags":"","loc":"type/adams_moulton_integrator.html","title":"adams_moulton_integrator – Shu-Osher-shock-tube-problem "},{"text":"type, public :: ls_runge_kutta_integrator FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. Note The integrator must be created or initialized (initialize the RK coefficients) before used.\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: A (:) Low storage A coefficients. real(kind=R_P), public, allocatable :: B (:) Low storage B coefficients. real(kind=R_P), public, allocatable :: C (:) Low storage C coefficients. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private subroutine init (self, stages) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' low storage table coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:2) Runge-Kutta registers [1:2]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit low storage Runge-Kutta scheme. Source Code type :: ls_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: A (:) !< Low storage *A* coefficients. real ( R_P ), allocatable :: B (:) !< Low storage *B* coefficients. real ( R_P ), allocatable :: C (:) !< Low storage *C* coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype ls_runge_kutta_integrator","tags":"","loc":"type/ls_runge_kutta_integrator.html","title":"ls_runge_kutta_integrator – Shu-Osher-shock-tube-problem "},{"text":"type, public :: emd_runge_kutta_integrator FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. Note The integrator must be created or initialized (initialize the RK coefficients) before used.\n Finalize object. Components Type Visibility Attributes Name Initial real(kind=R_P), public :: tolerance = 0._R_P Tolerance on the local truncation error. real(kind=R_P), public :: pp1_inv = 0._R_P 1/(p+1) where p is the accuracy order of the lower accurate scheme of the pair. integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:,:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, stages, tolerance) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. real(kind=R_P), intent(in), optional :: tolerance Tolerance on the local truncation error (default 0.01). Description Create the actual RK integrator: initialize the Butcher' table coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(inout) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit embedded Runge-Kutta scheme. procedure, private, pass(self) :: new_Dt Compute new estimation of the time step Dt. private elementalsubroutine new_Dt (self, error, Dt) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Integrator. real(kind=R_P), intent(in) :: error Local truncation error estimation. real(kind=R_P), intent(inout) :: Dt Time step. Description Compute new estimation of the time step Dt. Source Code type :: emd_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. real ( R_P ) :: tolerance = 0._R_P !< Tolerance on the local truncation error. real ( R_P ) :: pp1_inv = 0._R_P !< 1/(p+1) where p is the accuracy order of the lower accurate scheme of the pair. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:,:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), private :: new_Dt !< Compute new estimation of the time step Dt. final :: finalize !< Finalize object. endtype emd_runge_kutta_integrator","tags":"","loc":"type/emd_runge_kutta_integrator.html","title":"emd_runge_kutta_integrator – Shu-Osher-shock-tube-problem "},{"text":"type, public :: adams_bashforth_moulton_integrator type~~adams_bashforth_moulton_integrator~~InheritsGraph type~adams_bashforth_moulton_integrator adams_bashforth_moulton_integrator type~adams_bashforth_integrator adams_bashforth_integrator type~adams_bashforth_integrator->type~adams_bashforth_moulton_integrator predictor type~adams_moulton_integrator adams_moulton_integrator type~adams_moulton_integrator->type~adams_bashforth_moulton_integrator corrector Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. Note The integrator must be created or initialized (predictor and corrector schemes selection) before used.\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = -1 Number of time steps. type( adams_bashforth_integrator ), private :: predictor Predictor solver. type( adams_moulton_integrator ), private :: corrector Corrector solver. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. Description Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth-Moulton integrator: initialize the b coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, iterations) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(in) :: self Actual ABM integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations of AM scheme. Description Integrate field with Adams-Bashforth-Moulton class scheme. Source Code type :: adams_bashforth_moulton_integrator !< FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. !< !< @note The integrator must be created or initialized (predictor and corrector schemes selection) before used. private integer ( I_P ) :: steps =- 1 !< Number of time steps. type ( adams_bashforth_integrator ) :: predictor !< Predictor solver. type ( adams_moulton_integrator ) :: corrector !< Corrector solver. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype adams_bashforth_moulton_integrator","tags":"","loc":"type/adams_bashforth_moulton_integrator.html","title":"adams_bashforth_moulton_integrator – Shu-Osher-shock-tube-problem "},{"text":"type, public :: weno_factory WENO factory aimed to create and return a concrete WENO interpolator to the client code without exposing the concrete\n interpolators classes. Type-Bound Procedures procedure, public, nopass :: create private subroutine create (constructor, interpolator) Arguments Type Intent Optional Attributes Name class( weno_constructor ), intent(in) :: constructor The concrete WENO constructor selected by client code. class( weno_interpolator ), intent(out), allocatable :: interpolator The concrete WENO interpolator. Description Create and return a concrete WENO interpolator object being an extension of the abstract weno_interpolator type.","tags":"","loc":"type/weno_factory.html","title":"weno_factory – Shu-Osher-shock-tube-problem "},{"text":"type, public, abstract :: weno_constructor Abstract type used for create new concrete WENO interpolators. Note Every concrete WENO interpolator implementations must define their own constructor type. Source Code type , abstract :: weno_constructor !< Abstract type used for create new concrete WENO interpolators. !< !< @note Every concrete WENO interpolator implementations must define their own constructor type. private endtype weno_constructor","tags":"","loc":"type/weno_constructor.html","title":"weno_constructor – Shu-Osher-shock-tube-problem "},{"text":"type, public, abstract :: weno_interpolator WENO interpolator object. Note Do not implement any real interpolator: provide the interface for the different interpolators implemented. Type-Bound Procedures procedure( abstract_destructor ), public, pass(self), deferred :: destroy elementalsubroutine abstract_destructor (self) Prototype Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(inout) :: self WENO interpolator. Description Destoy a WENO interpolator. procedure( abstract_constructor ), public, pass(self), deferred :: create subroutine abstract_constructor (self, constructor) Prototype Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(inout) :: self WENO interpolator. class( weno_constructor ), intent(in) :: constructor WENO constructor. Description Create a WENO interpolator. procedure( abstract_description ), public, pass(self), deferred :: description puresubroutine abstract_description (self, string) Prototype Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(in) :: self WENO interpolator. character(len=:), intent(out), allocatable :: string String returned. Description Return a string describing a WENO interpolator. procedure( abstract_interpolate ), public, pass(self), deferred :: interpolate puresubroutine abstract_interpolate (self, S, stencil, location, interpolation) Prototype Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(in) :: self WENO interpolator. integer(kind=I_P), intent(in) :: S Number of stencils used. real(kind=R_P), intent(in) :: stencil (1:,1-S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. character(len=*), intent(in) :: location Location of interpolated value(s): central, left, right, both. real(kind=R_P), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Description Interpolate the stecil input values computing the actual interpolation. Source Code type , abstract :: weno_interpolator !< WENO interpolator object. !< !< @note Do not implement any real interpolator: provide the interface for the different interpolators implemented. private contains procedure ( abstract_destructor ), pass ( self ), deferred , public :: destroy procedure ( abstract_constructor ), pass ( self ), deferred , public :: create procedure ( abstract_description ), pass ( self ), deferred , public :: description procedure ( abstract_interpolate ), pass ( self ), deferred , public :: interpolate endtype weno_interpolator","tags":"","loc":"type/weno_interpolator.html","title":"weno_interpolator – Shu-Osher-shock-tube-problem "},{"text":"type, public, extends(weno_constructor) :: weno_constructor_upwind type~~weno_constructor_upwind~~InheritsGraph type~weno_constructor_upwind weno_constructor_upwind weno_constructor weno_constructor weno_constructor->type~weno_constructor_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Upwind biased WENO interpolator constructor, Note The constructed WENO interpolator implements the Efficient Implementation of Weighted ENO Schemes ,\n Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0 Stencils dimension. real(kind=R_P), public :: eps = 10._R_P**(-6) Parameter for avoiding divided by zero when computing smoothness indicators. Constructor public interface weno_constructor_upwind private elementalfunction weno_constructor_upwind_init (S, eps) result(constructor) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: S Maximum stencils dimension. real(kind=R_P), intent(in), optional :: eps Parameter for avoiding divided by zero when computing smoothness indicators. Return Value type( weno_constructor_upwind ) WENO constructor. Description Create (initialize) the WENO interpolator. Source Code type , extends ( weno_constructor ) :: weno_constructor_upwind !< Upwind biased WENO interpolator constructor, !< !< @note The constructed WENO interpolator implements the *Efficient Implementation of Weighted ENO Schemes*, !< Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130. integer ( I_P ) :: S = 0 !< Stencils dimension. real ( R_P ) :: eps = 1 0._R_P ** ( - 6 ) !< Parameter for avoiding divided by zero when computing smoothness indicators. endtype weno_constructor_upwind","tags":"","loc":"type/weno_constructor_upwind.html","title":"weno_constructor_upwind – Shu-Osher-shock-tube-problem "},{"text":"type, public, extends(weno_interpolator) :: weno_interpolator_upwind type~~weno_interpolator_upwind~~InheritsGraph type~weno_interpolator_upwind weno_interpolator_upwind weno_interpolator weno_interpolator weno_interpolator->type~weno_interpolator_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Upwind biased WENO interpolator object, Note The WENO interpolator implemented is the Efficient Implementation of Weighted ENO Schemes ,\n Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130. Note The supported accuracy formal order are: 3rd, 5th, 7th corresponding to use 2, 3, 4 stencils composed of 2, 3, 4 values,\n respectively. Inherited By type~~weno_interpolator_upwind~~InheritedByGraph type~weno_interpolator_upwind weno_interpolator_upwind type~euler_1d euler_1D type~weno_interpolator_upwind->type~euler_1d weno Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: S = 0_I_P Stencil dimension. real(kind=R_P), private :: eps = 0._R_P Parameter for avoiding divided by zero when computing smoothness indicators. real(kind=R_P), private, allocatable :: weights_opt (:,:) Optimal weights                    [1:2,0:S-1]. real(kind=R_P), private, allocatable :: poly_coef (:,:,:) Polynomials coefficients           [1:2,0:S-1,0:S-1]. real(kind=R_P), private, allocatable :: smooth_coef (:,:,:) Smoothness indicators coefficients [0:S-1,0:S-1,0:S-1]. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( weno_interpolator_upwind ), intent(inout) :: self WENO interpolator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(inout) :: self WENO interpolator. Description Destoy the WENO interpolator. procedure, public, pass(self) :: create private subroutine create (self, constructor) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(inout) :: self WENO interpolator. class( weno_constructor ), intent(in) :: constructor WENO constructor. Description Create the WENO interpolator. procedure, public, pass(self) :: description private puresubroutine description (self, string) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(in) :: self WENO interpolator. character(len=:), intent(out), allocatable :: string String returned. Description Return a string describing the WENO interpolator. procedure, public, pass(self) :: interpolate private puresubroutine interpolate (self, S, stencil, location, interpolation) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(in) :: self WENO interpolator. integer, intent(in) :: S Number of stencils actually used. real(kind=R_P), intent(in) :: stencil (1:,1-S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. character(len=*), intent(in) :: location Location of interpolated value(s): left, right, both. real(kind=R_P), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Description Interpolate the stecil input values computing the actual interpolation. generic, public :: assignment(=) => assign_interpolator Overloading = assignament. pass(lhs) assign_interpolator () Arguments None Description Assignament operator. procedure, private, pass(lhs) :: assign_interpolator Assignament operator. private puresubroutine assign_interpolator (lhs, rhs) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(inout) :: lhs Left hand side. class( weno_interpolator ), intent(in) :: rhs Right hand side. Description Assign one interpolator to another. Source Code type , extends ( weno_interpolator ) :: weno_interpolator_upwind !< Upwind biased WENO interpolator object, !< !< @note The WENO interpolator implemented is the *Efficient Implementation of Weighted ENO Schemes*, !< Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130. !< !< @note The supported accuracy formal order are: 3rd, 5th, 7th corresponding to use 2, 3, 4 stencils composed of 2, 3, 4 values, !< respectively. private integer ( I_P ) :: S = 0_I_P !< Stencil dimension. real ( R_P ) :: eps = 0._R_P !< Parameter for avoiding divided by zero when computing smoothness indicators. real ( R_P ), allocatable :: weights_opt (:,:) !< Optimal weights                    [1:2,0:S-1]. real ( R_P ), allocatable :: poly_coef (:,:,:) !< Polynomials coefficients           [1:2,0:S-1,0:S-1]. real ( R_P ), allocatable :: smooth_coef (:,:,:) !< Smoothness indicators coefficients [0:S-1,0:S-1,0:S-1]. contains ! public methods procedure , pass ( self ), public :: destroy procedure , pass ( self ), public :: create procedure , pass ( self ), public :: description procedure , pass ( self ), public :: interpolate generic , public :: assignment ( = ) => assign_interpolator !< Overloading = assignament. ! private methods procedure , pass ( lhs ), private :: assign_interpolator !< Assignament operator. final :: finalize endtype weno_interpolator_upwind","tags":"","loc":"type/weno_interpolator_upwind.html","title":"weno_interpolator_upwind – Shu-Osher-shock-tube-problem "},{"text":"type, public :: pyplot Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: str logical, private :: show_legend = .false. logical, private :: use_numpy = .true. logical, private :: mplot3d = .false. Type-Bound Procedures procedure, public :: initialize private subroutine initialize (me, grid, xlabel, ylabel, zlabel, title, legend, use_numpy, figsize, font_size, axes_labelsize, xtick_labelsize, ytick_labelsize, ztick_labelsize, legend_fontsize, mplot3d) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me logical, intent(in), optional :: grid character(len=*), intent(in), optional :: xlabel character(len=*), intent(in), optional :: ylabel character(len=*), intent(in), optional :: zlabel character(len=*), intent(in), optional :: title logical, intent(in), optional :: legend logical, intent(in), optional :: use_numpy integer, intent(in), optional dimension(2) :: figsize integer, intent(in), optional :: font_size integer, intent(in), optional :: axes_labelsize integer, intent(in), optional :: xtick_labelsize integer, intent(in), optional :: ytick_labelsize integer, intent(in), optional :: ztick_labelsize integer, intent(in), optional :: legend_fontsize logical, intent(in), optional :: mplot3d Description Author Jacob Williams procedure, public :: add_plot private subroutine add_plot (me, x, y, label, linestyle, markersize, linewidth) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: markersize integer, intent(in), optional :: linewidth Description Author Jacob Williams procedure, public :: add_3d_plot private subroutine add_3d_plot (me, x, y, z, label, linestyle, markersize, linewidth) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: markersize integer, intent(in), optional :: linewidth Description Author Jacob Williams procedure, public :: add_bar private subroutine add_bar (me, left, height, label, width, bottom, color) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: left real(kind=wp), intent(in), dimension(:) :: height character(len=*), intent(in) :: label real(kind=wp), intent(in), optional dimension(:) :: width real(kind=wp), intent(in), optional dimension(:) :: bottom character(len=*), intent(in), optional :: color Description Author Jacob Williams procedure, public :: savefig private subroutine savefig (me, figfile, pyfile) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in) :: figfile character(len=*), intent(in), optional :: pyfile Description Author Jacob Williams procedure, public :: destroy private subroutine destroy (me) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me Description Author Jacob Williams procedure, public :: execute private subroutine execute (me, pyfile) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in), optional :: pyfile Description Author Jacob Williams procedure, public :: add_str private subroutine add_str (me, str) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in) :: str Description Author Jacob Williams Source Code type , public :: pyplot !!  The main pyplot class. private character ( len = :), allocatable :: str !! string buffer logical :: show_legend = . false . !! show legend into plot logical :: use_numpy = . true . !! use numpy python module logical :: mplot3d = . false . !! it is a 3d plot contains ! public methods procedure , public :: initialize !! initialize pyplot instance procedure , public :: add_plot !! add a 2d plot to pyplot instance procedure , public :: add_3d_plot !! add a 3d plot to pyplot instance procedure , public :: add_bar !! add a barplot to pyplot instance procedure , public :: savefig !! save plots of pyplot instance procedure , public :: destroy !! destroy pyplot instance ! private methods procedure :: execute !! execute pyplot commands procedure :: add_str !! add string to pytplot instance buffer end type pyplot","tags":"","loc":"type/pyplot.html","title":"pyplot – Shu-Osher-shock-tube-problem "},{"text":"type, private, abstract :: Type_Object Inherited By type~~type_object~~InheritedByGraph type~type_object Type_Object type~type_command_line_arguments_group Type_Command_Line_Arguments_Group type~type_object->type~type_command_line_arguments_group type~type_command_line_argument Type_Command_Line_Argument type~type_object->type~type_command_line_argument type~type_command_line_interface Type_Command_Line_Interface type~type_object->type~type_command_line_interface type~type_command_line_arguments_group->type~type_command_line_interface clasg type~type_command_line_argument->type~type_command_line_arguments_group cla var pantypetype_objectInheritedByGraph = svgPanZoom('#typetype_objectInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), private, allocatable :: help Help message. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilog message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). integer(kind=I4P), public :: error = 0_I4P Error traping flag. Type-Bound Procedures procedure, public :: free_object Free dynamic memory. private elementalsubroutine free_object (obj) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: obj Object data. Description Free dynamic memory. procedure, public :: errored Trig error occurence and print meaningful message. private subroutine errored (obj, error, pref, group, switch, val_str, log_value, a1, a2) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: obj Object data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Group name. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: val_str Value string. character(len=*), intent(in), optional :: log_value Logical value to be casted. integer(kind=I4P), intent(in), optional :: a1 integer(kind=I4P), intent(in), optional :: a2 CLAs group inconsistent indexes. Description Trig error occurence and print meaningful message. procedure, public :: print_version Print version. private subroutine print_version (obj, pref) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(in) :: obj Object data. character(len=*), intent(in), optional :: pref Prefixing string. Description Print version. procedure, public :: assign_object Assignment overloading. private elementalsubroutine assign_object (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: lhs Left hand side. class( Type_Object ), intent(in) :: rhs Rigth hand side. Source Code type , abstract :: Type_Object private character ( len = :), public , allocatable :: progname !< Program name. character ( len = :), public , allocatable :: version !< Program version. character ( len = :), allocatable :: help !< Help message. character ( len = :), public , allocatable :: description !< Detailed description. character ( len = :), public , allocatable :: license !< License description. character ( len = :), public , allocatable :: authors !< Authors list. character ( len = :), public , allocatable :: epilog !< Epilog message. character ( len = :), public , allocatable :: m_exclude !< Mutually exclude other CLA(s group). integer ( I4P ), public :: error = 0_I4P !< Error traping flag. contains procedure :: free_object !< Free dynamic memory. procedure :: errored !< Trig error occurence and print meaningful message. procedure :: print_version !< Print version. procedure :: assign_object !< Assignment overloading. endtype Type_Object","tags":"","loc":"type/type_object.html","title":"Type_Object – Shu-Osher-shock-tube-problem "},{"text":"type, private, extends( Type_Object ) :: Type_Command_Line_Argument type~~type_command_line_argument~~InheritsGraph type~type_command_line_argument Type_Command_Line_Argument type~type_object Type_Object type~type_object->type~type_command_line_argument Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Command line arguments (CLA). Note If not otherwise declared the action on CLA value is set to \"store\" a value.\n Free dynamic memory when finalizing. Inherited By type~~type_command_line_argument~~InheritedByGraph type~type_command_line_argument Type_Command_Line_Argument type~type_command_line_arguments_group Type_Command_Line_Arguments_Group type~type_command_line_argument->type~type_command_line_arguments_group cla type~type_command_line_interface Type_Command_Line_Interface type~type_command_line_arguments_group->type~type_command_line_interface clasg var pantypetype_command_line_argumentInheritedByGraph = svgPanZoom('#typetype_command_line_argumentInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: switch Switch name. character(len=:), private, allocatable :: switch_ab Abbreviated switch name. logical, private :: required = .false. Flag for set required argument. logical, private :: positional = .false. Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), private :: position = 0_I4P Position of positional CLA. logical, private :: passed = .false. Flag for checking if CLA has been passed to CLI. logical, private :: hidden = .false. Flag for hiding CLA, thus it does not compare into help. character(len=:), private, allocatable :: act CLA value action. character(len=:), private, allocatable :: def Default value. character(len=:), private, allocatable :: nargs Number of arguments consumed by CLA. character(len=:), private, allocatable :: choices List (comma separated) of allowable values for the argument. character(len=:), private, allocatable :: val CLA value. character(len=:), private, allocatable :: envvar Environment variable from which take value. Finalization Procedures final :: finalize_cla private elementalsubroutine finalize_cla (cla) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. Description Free dynamic memory when finalizing. Type-Bound Procedures procedure, public :: free => free_cla Free dynamic memory. private elementalsubroutine free_cla (cla) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. Description Free dynamic memory. procedure, public :: check => check_cla Check CLA data consistency. private subroutine check_cla (cla, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check CLA data consistency. procedure, public :: check_choices => check_choices_cla Check if CLA value is in allowed choices. private subroutine check_choices_cla (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. class(*), intent(in) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if CLA value is in allowed choices. procedure, public :: check_list_size => check_list_size_cla Check CLA multiple values list size consistency. private function check_list_size_cla (cla, Nv, val, pref) result(is_ok) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I4P), intent(in) :: Nv Number of values. character(len=*), intent(in) :: val First value. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. Description Check CLA multiple values list size consistency. generic, public :: get => get_cla , get_cla_list Get CLA value(s). get_cla () Arguments None Description Get CLA (single) value from CLAs list parsed. get_cla_list () Arguments None Description Get CLA multiple values from CLAs list parsed. generic, public :: get_varying => get_cla_list_varying_R8P , get_cla_list_varying_R4P , get_cla_list_varying_I8P , get_cla_list_varying_I4P , get_cla_list_varying_I2P , get_cla_list_varying_I1P , get_cla_list_varying_logical , get_cla_list_varying_char Get CLA value(s) from CLAs list parsedi, varying size list. get_cla_list_varying_R8P () Arguments None Description Get CLA multiple values from CLAs list parsed, varying size, R8P. get_cla_list_varying_R4P () Arguments None Description Get CLA multiple values from CLAs list parsed, varying size, R4P. get_cla_list_varying_I8P () Arguments None Description Get CLA multiple values from CLAs list parsed, varying size, I8P. get_cla_list_varying_I4P () Arguments None Description Get CLA multiple values from CLAs list parsed, varying size, I4P. get_cla_list_varying_I2P () Arguments None Description Get CLA multiple values from CLAs list parsed, varying size, I2P. get_cla_list_varying_I1P () Arguments None Description Get CLA multiple values from CLAs list parsed, varying size, I1P. get_cla_list_varying_logical () Arguments None Description Get CLA multiple values from CLAs list parsed, varying size, bool. get_cla_list_varying_char () Arguments None Description Get CLA multiple values from CLAs list parsed, varying size, char. procedure, public :: usage => usage_cla Get correct CLA usage. private function usage_cla (cla, pref) result(usage) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(in) :: cla CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Return Value character(len=:),\n  allocatable Usage string. Description Get correct CLA usage. procedure, public :: signature => signature_cla Get CLA signature for adding to CLI one. private function signature_cla (cla) result(signd) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(in) :: cla CLA data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLA signature for adding to the CLI one. procedure, private :: get_cla Get CLA (single) value from CLAs list parsed. private subroutine get_cla (cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val CLA value. Description Get CLA (single) value. procedure, private :: get_cla_list Get CLA multiple values from CLAs list parsed. private subroutine get_cla_list (cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. Description Get CLA (multiple) value. procedure, private :: get_cla_list_varying_R8P Get CLA multiple values from CLAs list parsed, varying size, R8P. private subroutine get_cla_list_varying_R8P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R8P). procedure, private :: get_cla_list_varying_R4P Get CLA multiple values from CLAs list parsed, varying size, R4P. private subroutine get_cla_list_varying_R4P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R4P). procedure, private :: get_cla_list_varying_I8P Get CLA multiple values from CLAs list parsed, varying size, I8P. private subroutine get_cla_list_varying_I8P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I8P). procedure, private :: get_cla_list_varying_I4P Get CLA multiple values from CLAs list parsed, varying size, I4P. private subroutine get_cla_list_varying_I4P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I4P). procedure, private :: get_cla_list_varying_I2P Get CLA multiple values from CLAs list parsed, varying size, I2P. private subroutine get_cla_list_varying_I2P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I2P). procedure, private :: get_cla_list_varying_I1P Get CLA multiple values from CLAs list parsed, varying size, I1P. private subroutine get_cla_list_varying_I1P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I1P). procedure, private :: get_cla_list_varying_logical Get CLA multiple values from CLAs list parsed, varying size, bool. private subroutine get_cla_list_varying_logical (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, logical. procedure, private :: get_cla_list_varying_char Get CLA multiple values from CLAs list parsed, varying size, char. private subroutine get_cla_list_varying_char (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, character. procedure, private :: assign_cla CLA assignment overloading. private elementalsubroutine assign_cla (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Argument ), intent(in) :: rhs Rigth hand side. generic, private :: assignment(=) => assign_cla CLA assignment overloading. assign_cla () Arguments None Description CLA assignment overloading. Source Code type , extends ( Type_Object ) :: Type_Command_Line_Argument !< Command line arguments (CLA). !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value. private character ( len = :), allocatable :: switch !< Switch name. character ( len = :), allocatable :: switch_ab !< Abbreviated switch name. logical :: required = . false . !< Flag for set required argument. logical :: positional = . false . !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ) :: position = 0_I4P !< Position of positional CLA. logical :: passed = . false . !< Flag for checking if CLA has been passed to CLI. logical :: hidden = . false . !< Flag for hiding CLA, thus it does not compare into help. character ( len = :), allocatable :: act !< CLA value action. character ( len = :), allocatable :: def !< Default value. character ( len = :), allocatable :: nargs !< Number of arguments consumed by CLA. character ( len = :), allocatable :: choices !< List (comma separated) of allowable values for the argument. character ( len = :), allocatable :: val !< CLA value. character ( len = :), allocatable :: envvar !< Environment variable from which take value. contains ! public methods procedure , public :: free => free_cla !< Free dynamic memory. procedure , public :: check => check_cla !< Check CLA data consistency. procedure , public :: check_choices => check_choices_cla !< Check if CLA value is in allowed choices. procedure , public :: check_list_size => check_list_size_cla !< Check CLA multiple values list size consistency. generic , public :: get => get_cla , get_cla_list !< Get CLA value(s). generic , public :: get_varying => & !< Get CLA value(s) from CLAs list parsedi, varying size list. #ifdef r16p get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char procedure , public :: usage => usage_cla !< Get correct CLA usage. procedure , public :: signature => signature_cla !< Get CLA signature for adding to CLI one. ! private methods procedure , private :: get_cla !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: assign_cla !< CLA assignment overloading. generic , private :: assignment ( = ) => assign_cla !< CLA assignment overloading. final :: finalize_cla !< Free dynamic memory when finalizing. endtype Type_Command_Line_Argument","tags":"","loc":"type/type_command_line_argument.html","title":"Type_Command_Line_Argument – Shu-Osher-shock-tube-problem "},{"text":"type, private, extends( Type_Object ) :: Type_Command_Line_Arguments_Group type~~type_command_line_arguments_group~~InheritsGraph type~type_command_line_arguments_group Type_Command_Line_Arguments_Group type~type_command_line_argument Type_Command_Line_Argument type~type_command_line_argument->type~type_command_line_arguments_group cla type~type_object Type_Object type~type_object->type~type_command_line_arguments_group type~type_object->type~type_command_line_argument Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Group of CLAs for building nested commands.\n Free dynamic memory when finalizing. Inherited By type~~type_command_line_arguments_group~~InheritedByGraph type~type_command_line_arguments_group Type_Command_Line_Arguments_Group type~type_command_line_interface Type_Command_Line_Interface type~type_command_line_arguments_group->type~type_command_line_interface clasg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: group Group name (command). integer(kind=I4P), private :: Na = 0_I4P Number of CLA. integer(kind=I4P), private :: Na_required = 0_I4P Number of command line arguments that CLI requires. integer(kind=I4P), private :: Na_optional = 0_I4P Number of command line arguments that are optional for CLI. type( Type_Command_Line_Argument ), private, allocatable :: cla (:) CLA list [1:Na]. logical, private :: called = .false. Flag for checking if CLAs group has been passed to CLI. Finalization Procedures final :: finalize_clasg private elementalsubroutine finalize_clasg (clasg) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. Description Free dynamic memory when finalizing. Type-Bound Procedures procedure, public :: free => free_clasg Free dynamic memory. private elementalsubroutine free_clasg (clasg) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. Description Free dynamic memory. procedure, public :: check => check_clasg Check CLAs data consistency. private subroutine check_clasg (clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check CLA data consistency. procedure, public :: check_required => check_required_clasg Check if required CLAs are passed. private subroutine check_required_clasg (clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if required CLAs are passed. procedure, public :: check_m_exclusive => check_m_exclusive_clasg Check if two mutually exclusive CLAs have been passed. private subroutine check_m_exclusive_clasg (clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if two mutually exclusive CLAs have been passed. procedure, public :: add => add_cla_clasg Add CLA to CLAs group. private subroutine add_cla_clasg (clasg, pref, cla) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. type( Type_Command_Line_Argument ), intent(in) :: cla CLA data. Description Add CLA to CLAs list. procedure, public :: passed => passed_clasg Check if a CLA has been passed. private purefunction passed_clasg (clasg, switch, position) result(passed) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Description Check if a CLA has been passed. procedure, public :: defined => defined_clasg Check if a CLA has been defined. private function defined_clasg (clasg, switch, pos) result(defined) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in) :: switch Switch name. integer(kind=I4P), intent(out), optional :: pos CLA position. Return Value logical Check if a CLA has been defined. Description Check if a CLA has been defined. procedure, public :: parse => parse_clasg Parse CLAs group arguments. private subroutine parse_clasg (clasg, pref, args) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in) :: args (:) Command line arguments. Description Parse CLAs group arguments. procedure, public :: usage => usage_clasg Get correct CLAs group usage. private function usage_clasg (clasg, pref, no_header) result(usage) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. Return Value character(len=:),\n  allocatable Usage string. Description Get correct CLAs group usage. procedure, public :: signature => signature_clasg Get CLAs group signature for adding to the CLI one. private function signature_clasg (clasg) result(signd) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLAs group signature for adding to the CLI one. procedure, private :: assign_clasg CLAs group assignment overloading. private elementalsubroutine assign_clasg (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Arguments_Group ), intent(in) :: rhs Right hand side. generic, private :: assignment(=) => assign_clasg CLAs group assignment overloading. assign_clasg () Arguments None Description CLAs group assignment overloading. Source Code type , extends ( Type_Object ) :: Type_Command_Line_Arguments_Group !< Group of CLAs for building nested commands. private character ( len = :), allocatable :: group !< Group name (command). integer ( I4P ) :: Na = 0_I4P !< Number of CLA. integer ( I4P ) :: Na_required = 0_I4P !< Number of command line arguments that CLI requires. integer ( I4P ) :: Na_optional = 0_I4P !< Number of command line arguments that are optional for CLI. type ( Type_Command_Line_Argument ), allocatable :: cla (:) !< CLA list [1:Na]. logical :: called = . false . !< Flag for checking if CLAs group has been passed to CLI. contains ! public methods procedure , public :: free => free_clasg !< Free dynamic memory. procedure , public :: check => check_clasg !< Check CLAs data consistency. procedure , public :: check_required => check_required_clasg !< Check if required CLAs are passed. procedure , public :: check_m_exclusive => check_m_exclusive_clasg !< Check if two mutually exclusive CLAs have been passed. procedure , public :: add => add_cla_clasg !< Add CLA to CLAs group. procedure , public :: passed => passed_clasg !< Check if a CLA has been passed. procedure , public :: defined => defined_clasg !< Check if a CLA has been defined. procedure , public :: parse => parse_clasg !< Parse CLAs group arguments. procedure , public :: usage => usage_clasg !< Get correct CLAs group usage. procedure , public :: signature => signature_clasg !< Get CLAs group signature for adding to the CLI one. ! private methods procedure , private :: assign_clasg !< CLAs group assignment overloading. generic , private :: assignment ( = ) => assign_clasg !< CLAs group assignment overloading. final :: finalize_clasg !< Free dynamic memory when finalizing. endtype Type_Command_Line_Arguments_Group","tags":"","loc":"type/type_command_line_arguments_group.html","title":"Type_Command_Line_Arguments_Group – Shu-Osher-shock-tube-problem "},{"text":"type, public, extends( Type_Object ) :: Type_Command_Line_Interface type~~type_command_line_interface~~InheritsGraph type~type_command_line_interface Type_Command_Line_Interface type~type_command_line_arguments_group Type_Command_Line_Arguments_Group type~type_command_line_arguments_group->type~type_command_line_interface clasg type~type_command_line_argument Type_Command_Line_Argument type~type_command_line_argument->type~type_command_line_arguments_group cla type~type_object Type_Object type~type_object->type~type_command_line_interface type~type_object->type~type_command_line_arguments_group type~type_object->type~type_command_line_argument var pantypetype_command_line_interfaceInheritsGraph = svgPanZoom('#typetype_command_line_interfaceInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Command Line Interface (CLI).\n Free dynamic memory when finalizing. Components Type Visibility Attributes Name Initial type( Type_Command_Line_Arguments_Group ), private, allocatable :: clasg (:) CLA list [1:Na]. character(len=512), private, allocatable :: args (:) Actually passed command line arguments. character(len=512), private, allocatable :: examples (:) Examples of correct usage. logical, private :: disable_hv = .false. Disable automatic 'help' and 'version' CLAs. Finalization Procedures final :: finalize private elementalsubroutine finalize (cli) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. Description Free dynamic memory when finalizing. Type-Bound Procedures procedure, public :: free Free dynamic memory. private elementalsubroutine free (cli) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. Description Free dynamic memory. procedure, public :: init Initialize CLI. private subroutine init (cli, progname, version, help, description, license, authors, examples, epilog, disable_hv) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: progname Program name. character(len=*), intent(in), optional :: version Program version. character(len=*), intent(in), optional :: help Help message introducing the CLI usage. character(len=*), intent(in), optional :: description Detailed description message introducing the program. character(len=*), intent(in), optional :: license License description. character(len=*), intent(in), optional :: authors Authors list. character(len=*), intent(in), optional :: examples (1:) Examples of correct usage. character(len=*), intent(in), optional :: epilog Epilog message. logical, intent(in), optional :: disable_hv Disable automatic insert of 'help' and 'version' CLAs. Description Initialize CLI. procedure, public :: add_group Add CLAs group CLI. private subroutine add_group (cli, help, description, exclude, group) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: help Help message. character(len=*), intent(in), optional :: description Detailed description. character(len=*), intent(in), optional :: exclude Group name of the mutually exclusive group. character(len=*), intent(in) :: group Name of the grouped CLAs. Description Add CLAs group to CLI. procedure, public :: add Add CLA to CLI. private subroutine add (cli, pref, group, group_index, switch, switch_ab, help, required, positional, position, hidden, act, def, nargs, choices, exclude, envvar, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of the grouped CLAs. integer(kind=I4P), intent(in), optional :: group_index Index of the grouped CLAs. character(len=*), intent(in), optional :: switch Switch name. character(len=*), intent(in), optional :: switch_ab Abbreviated switch name. character(len=*), intent(in), optional :: help Help message describing the CLA. logical, intent(in), optional :: required Flag for set required argument. logical, intent(in), optional :: positional Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. logical, intent(in), optional :: hidden Flag for hiding CLA, thus it does not compare into help. character(len=*), intent(in), optional :: act CLA value action. character(len=*), intent(in), optional :: def Default value. character(len=*), intent(in), optional :: nargs Number of arguments consumed by CLA. character(len=*), intent(in), optional :: choices List of allowable values for the argument. character(len=*), intent(in), optional :: exclude Switch name of the mutually exclusive CLA. character(len=*), intent(in), optional :: envvar Environment variable from which take value. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Add CLA to CLI. procedure, public :: passed Check if a CLA has been passed. private function passed (cli, group, switch, position) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Description Check if a CLA has been passed. procedure, public :: defined Check if a CLA has been defined. private function defined (cli, switch, group) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: switch Switch name. character(len=*), intent(in), optional :: group Name of group (command) of CLAs. Return Value logical Check if a CLA has been defined. Description Check if a CLA has been defined. procedure, public :: defined_group Check if a CLAs group has been defined. private function defined_group (cli, group, g) result(defined) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. integer(kind=I4P), intent(out), optional :: g Index of group. Return Value logical Check if a CLAs group has been defined. Description Check if a CLAs group has been defined. procedure, public :: set_mutually_exclusive_groups Set two CLAs group as mutually exclusive. private subroutine set_mutually_exclusive_groups (cli, group1, group2) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in) :: group1 Name of the first grouped CLAs. character(len=*), intent(in) :: group2 Name of the second grouped CLAs. Description Set two CLAs group ad mutually exclusive. procedure, public :: run_command => called_group Check if a CLAs group has been runned. private function called_group (cli, group) result(called) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. Return Value logical Check if a CLAs group has been runned. Description Check if a CLAs group has been runned. procedure, public :: parse Parse Command Line Interfaces. private subroutine parse (cli, pref, args, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Parse Command Line Interfaces by means of a previously initialized CLAs groups list. generic, public :: get => get_cla_cli , get_cla_list_cli Get CLA value(s) from CLAs list parsed. get_cla_cli () Arguments None Description Get CLA (single) value from CLAs list parsed. get_cla_list_cli () Arguments None Description Get CLA multiple values from CLAs list parsed. generic, public :: get_varying => get_cla_list_varying_R8P_cli , get_cla_list_varying_R4P_cli , get_cla_list_varying_I8P_cli , get_cla_list_varying_I4P_cli , get_cla_list_varying_I2P_cli , get_cla_list_varying_I1P_cli , get_cla_list_varying_logical_cli , get_cla_list_varying_char_cli Get CLA value(s) from CLAs list parsedi, varying size list. get_cla_list_varying_R8P_cli () Arguments None Description Get CLA multiple values from CLAs list parsed, varying size, R8P. get_cla_list_varying_R4P_cli () Arguments None Description Get CLA multiple values from CLAs list parsed, varying size, R4P. get_cla_list_varying_I8P_cli () Arguments None Description Get CLA multiple values from CLAs list parsed, varying size, I8P. get_cla_list_varying_I4P_cli () Arguments None Description Get CLA multiple values from CLAs list parsed, varying size, I4P. get_cla_list_varying_I2P_cli () Arguments None Description Get CLA multiple values from CLAs list parsed, varying size, I2P. get_cla_list_varying_I1P_cli () Arguments None Description Get CLA multiple values from CLAs list parsed, varying size, I1P. get_cla_list_varying_logical_cli () Arguments None Description Get CLA multiple values from CLAs list parsed, varying size, bool. get_cla_list_varying_char_cli () Arguments None Description Get CLA multiple values from CLAs list parsed, varying size, char. procedure, public :: usage Get CLI usage. private function usage (cli, g, pref, no_header, no_examples, no_epilog) result(usaged) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. integer(kind=I4P), intent(in) :: g Group index. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: no_examples Avoid insert examples to usage. logical, intent(in), optional :: no_epilog Avoid insert epilogue to usage. Return Value character(len=:),\n  allocatable Usage string. Description Print correct usage of CLI. procedure, public :: signature Get CLI signature. private function signature (cli) result(signd) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLI signature. procedure, public :: print_usage Print correct usage of CLI. private subroutine print_usage (cli, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Description Print correct usage of CLI. procedure, public :: save_man_page Save man page build on CLI. private subroutine save_man_page (cli, man_file, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: man_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Save man page build on the CLI. procedure, private :: check Check CLAs data consistenc. private subroutine check (cli, pref, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Check CLAs data consistency. procedure, private :: check_m_exclusive Check if two mutually exclusive CLAs group have been called. private subroutine check_m_exclusive (cli, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if two mutually exclusive CLAs group have been called. procedure, private :: get_clasg_indexes Get CLAs groups indexes. private subroutine get_clasg_indexes (cli, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. generic, private :: get_args => get_args_from_string , get_args_from_invocation Get CLAs from string.\n Get CLAs from CLI invocation. get_args_from_string () Arguments None Description Get CLAs from string. get_args_from_invocation () Arguments None Description Get CLAs from CLI invocation. procedure, private :: get_args_from_string Get CLAs from string. private subroutine get_args_from_string (cli, args, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from string. procedure, private :: get_args_from_invocation Get CLAs from CLI invocation. private subroutine get_args_from_invocation (cli, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from CLI invocation. procedure, private :: get_cla_cli Get CLA (single) value from CLAs list parsed. private subroutine get_cla_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA (single) value from CLAs list parsed. procedure, private :: get_cla_list_cli Get CLA multiple values from CLAs list parsed. private subroutine get_cla_list_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val (1:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed. procedure, private :: get_cla_list_varying_R16P_cli Get CLA multiple values from CLAs list parsed, varying size, R16P. private subroutine get_cla_list_varying_R16P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). procedure, private :: get_cla_list_varying_R8P_cli Get CLA multiple values from CLAs list parsed, varying size, R8P. private subroutine get_cla_list_varying_R8P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). procedure, private :: get_cla_list_varying_R4P_cli Get CLA multiple values from CLAs list parsed, varying size, R4P. private subroutine get_cla_list_varying_R4P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). procedure, private :: get_cla_list_varying_I8P_cli Get CLA multiple values from CLAs list parsed, varying size, I8P. private subroutine get_cla_list_varying_I8P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). procedure, private :: get_cla_list_varying_I4P_cli Get CLA multiple values from CLAs list parsed, varying size, I4P. private subroutine get_cla_list_varying_I4P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). procedure, private :: get_cla_list_varying_I2P_cli Get CLA multiple values from CLAs list parsed, varying size, I2P. private subroutine get_cla_list_varying_I2P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). procedure, private :: get_cla_list_varying_I1P_cli Get CLA multiple values from CLAs list parsed, varying size, I1P. private subroutine get_cla_list_varying_I1P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). procedure, private :: get_cla_list_varying_logical_cli Get CLA multiple values from CLAs list parsed, varying size, bool. private subroutine get_cla_list_varying_logical_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, logical. procedure, private :: get_cla_list_varying_char_cli Get CLA multiple values from CLAs list parsed, varying size, char. private subroutine get_cla_list_varying_char_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, character. procedure, private :: assign_cli CLI assignment overloading. private elementalsubroutine assign_cli (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Interface ), intent(in) :: rhs Right hand side. generic, private :: assignment(=) => assign_cli CLI assignment overloading. assign_cli () Arguments None Description CLI assignment overloading. Source Code type , extends ( Type_Object ), public :: Type_Command_Line_Interface !< Command Line Interface (CLI). private type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg (:) !< CLA list [1:Na]. #ifdef __GFORTRAN__ character ( 512 ), allocatable :: args (:) !< Actually passed command line arguments. character ( 512 ), allocatable :: examples (:) !< Examples of correct usage. #else character ( len = :), allocatable :: args (:) !< Actually passed command line arguments. character ( len = :), allocatable :: examples (:) !< Examples of correct usage (not work with gfortran). #endif logical :: disable_hv = . false . !< Disable automatic 'help' and 'version' CLAs. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: init !< Initialize CLI. procedure , public :: add_group !< Add CLAs group CLI. procedure , public :: add !< Add CLA to CLI. procedure , public :: passed !< Check if a CLA has been passed. procedure , public :: defined !< Check if a CLA has been defined. procedure , public :: defined_group !< Check if a CLAs group has been defined. procedure , public :: set_mutually_exclusive_groups !< Set two CLAs group as mutually exclusive. procedure , public :: run_command => called_group !< Check if a CLAs group has been runned. procedure , public :: parse !< Parse Command Line Interfaces. generic , public :: get => get_cla_cli , get_cla_list_cli !< Get CLA value(s) from CLAs list parsed. generic , public :: get_varying => & !< Get CLA value(s) from CLAs list parsedi, varying size list. #ifdef r16p get_cla_list_varying_R16P_cli , & #endif get_cla_list_varying_R8P_cli , & get_cla_list_varying_R4P_cli , & get_cla_list_varying_I8P_cli , & get_cla_list_varying_I4P_cli , & get_cla_list_varying_I2P_cli , & get_cla_list_varying_I1P_cli , & get_cla_list_varying_logical_cli , & get_cla_list_varying_char_cli procedure , public :: usage !< Get CLI usage. procedure , public :: signature !< Get CLI signature. procedure , public :: print_usage !< Print correct usage of CLI. procedure , public :: save_man_page !< Save man page build on CLI. ! private methods procedure , private :: check !< Check CLAs data consistenc. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs group have been called. procedure , private :: get_clasg_indexes !< Get CLAs groups indexes. generic , private :: get_args => get_args_from_string ,& !< Get CLAs from string. get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_args_from_string !< Get CLAs from string. procedure , private :: get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_cla_cli !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list_cli !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R16P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R16P. procedure , private :: get_cla_list_varying_R8P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical_cli !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char_cli !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: assign_cli !< CLI assignment overloading. generic , private :: assignment ( = ) => assign_cli !< CLI assignment overloading. final :: finalize !< Free dynamic memory when finalizing. endtype Type_Command_Line_Interface","tags":"","loc":"type/type_command_line_interface.html","title":"Type_Command_Line_Interface – Shu-Osher-shock-tube-problem "},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private subroutine assignment_integrand(lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand.","tags":"","loc":"interface/assignment_integrand.html","title":"assignment_integrand – Shu-Osher-shock-tube-problem"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function time_derivative(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function.","tags":"","loc":"interface/time_derivative.html","title":"time_derivative – Shu-Osher-shock-tube-problem"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function local_error_operator(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 solution approximations.","tags":"","loc":"interface/local_error_operator.html","title":"local_error_operator – Shu-Osher-shock-tube-problem"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function integrand_op_real(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real.","tags":"","loc":"interface/integrand_op_real.html","title":"integrand_op_real – Shu-Osher-shock-tube-problem"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function real_op_integrand(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand.","tags":"","loc":"interface/real_op_integrand.html","title":"real_op_integrand – Shu-Osher-shock-tube-problem"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function symmetric_operator(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand.","tags":"","loc":"interface/symmetric_operator.html","title":"symmetric_operator – Shu-Osher-shock-tube-problem"},{"text":"abstract interface private elementalsubroutine abstract_destructor(self) Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(inout) :: self WENO interpolator. Description Destoy a WENO interpolator.","tags":"","loc":"interface/abstract_destructor.html","title":"abstract_destructor – Shu-Osher-shock-tube-problem"},{"text":"abstract interface private subroutine abstract_constructor(self, constructor) Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(inout) :: self WENO interpolator. class( weno_constructor ), intent(in) :: constructor WENO constructor. Description Create a WENO interpolator. Note Before call this method a concrete constructor must be instantiated.","tags":"","loc":"interface/abstract_constructor.html","title":"abstract_constructor – Shu-Osher-shock-tube-problem"},{"text":"abstract interface private puresubroutine abstract_description(self, string) Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(in) :: self WENO interpolator. character(len=:), intent(out), allocatable :: string String returned. Description Return a string describing a WENO interpolator.","tags":"","loc":"interface/abstract_description.html","title":"abstract_description – Shu-Osher-shock-tube-problem"},{"text":"abstract interface private puresubroutine abstract_interpolate(self, S, stencil, location, interpolation) Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(in) :: self WENO interpolator. integer(kind=I_P), intent(in) :: S Number of stencils used. real(kind=R_P), intent(in) :: stencil (1:,1-S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. character(len=*), intent(in) :: location Location of interpolated value(s): central, left, right, both. real(kind=R_P), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Description Interpolate the stecil input values computing the actual interpolation.","tags":"","loc":"interface/abstract_interpolate.html","title":"abstract_interpolate – Shu-Osher-shock-tube-problem"},{"text":"subroutine command_line_interface() Arguments None Description Handle Command Line Interface. Called By proc~~command_line_interface~~CalledByGraph proc~command_line_interface command_line_interface program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~command_line_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(Type_Command_Line_Interface), public :: cli Command line interface handler. integer(kind=I_P), public :: error Error handler. Source Code subroutine command_line_interface () !--------------------------------------------------------------------------------------------------------------------------------- !< Handle Command Line Interface. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. integer ( I_P ) :: error !< Error handler. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration' , & examples = [ \"euler-1D --results  \" , & \"euler-1D -r -t -v -p\" , & \"euler-1D            \" , & \"euler-1D --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--order' , help = 'Order of accuracy' , choices = '1,3,5,7' , required = . false ., act = 'store' , def = '1' , error = error ) call cli % add ( switch = '--t_final' , help = 'Final time of integration' , required = . false ., act = 'store' , def = '0.178d0' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , & def = '.false.' , error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--order' , val = order , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--t_final' , val = t_final , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine command_line_interface","tags":"","loc":"proc/command_line_interface.html","title":"command_line_interface – Shu-Osher-shock-tube-problem"},{"text":"subroutine init() Arguments None Description Initialize the field. Calls proc~~init~~CallsGraph proc~init init str str proc~init->str proc~save_time_serie save_time_serie proc~init->proc~save_time_serie proc~save_time_serie->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~init~~CalledByGraph proc~init init program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~init Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, parameter :: pi = 4._R_P*atan(1._R_P) Pi greek. integer(kind=I_P), public :: i Space counter. real(kind=R_P), public :: rho_sin Sinusoidal density distribution. real(kind=R_P), public :: Dx Space step discretization. real(kind=R_P), public :: cp0 (1:Ns) Specific heat at constant pressure. real(kind=R_P), public :: cv0 (1:Ns) Specific heat at constant volume. real(kind=R_P), public, allocatable :: initial_state (:,:) Initial state of primitive variables. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. real ( R_P ) :: rho_sin !< Sinusoidal density distribution. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 2.85_R_P Dx = 1._R_P / Ni do i = 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.12_R_P ) then initial_state (:, i ) = [ 3.857143_R_P , & ! rho(s) 2.629369_R_P , & ! u 1 0.33333_R_P , & ! p 3.857143_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else rho_sin = 1._R_P + 0.2_R_P * sin ( 8._R_P * x ( i ) * 2._R_P * pi ) initial_state (:, i ) = [ rho_sin , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p rho_sin , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = 'TRA' , BC_R = 'TRA' , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = order ) call save_time_serie ( title = 'Shu-Osher shock tube problem' , & filename = 'shu-osher-order-' // trim ( str (. true ., order )) // '-grid-' // trim ( str (. true ., Ni )) // '.dat' , & t = t ) t = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init.html","title":"init – Shu-Osher-shock-tube-problem"},{"text":"subroutine finish() Arguments None Description Peform after-success finishing operations. Calls proc~~finish~~CallsGraph proc~finish finish proc~save_results save_results proc~finish->proc~save_results proc~save_time_serie save_time_serie proc~finish->proc~save_time_serie str str proc~finish->str proc~save_results->str proc~save_time_serie->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~finish~~CalledByGraph proc~finish finish program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~finish Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine finish () !--------------------------------------------------------------------------------------------------------------------------------- !< Peform after-success finishing operations. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'Shu-Osher shock tube problem' , & filename = 'shu-osher-order-' // trim ( str (. true ., order )) // '-grid-' // trim ( str (. true ., Ni ))) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finish","tags":"","loc":"proc/finish.html","title":"finish – Shu-Osher-shock-tube-problem"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. Calls proc~~save_results~~CallsGraph proc~save_results save_results str str proc~save_results->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_results~~CalledByGraph proc~save_results save_results proc~finish finish proc~finish->proc~save_results program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~finish Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: final_state (:,:) Final state. integer(kind=I_P), public :: rawfile Raw file unit for saving results. type( pyplot ), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results.html","title":"save_results – Shu-Osher-shock-tube-problem"},{"text":"subroutine save_time_serie(title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Calls proc~~save_time_serie~~CallsGraph proc~save_time_serie save_time_serie str str proc~save_time_serie->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~~CalledByGraph proc~save_time_serie save_time_serie program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~save_time_serie proc~init init program~integrate_euler_1d->proc~init proc~finish finish program~integrate_euler_1d->proc~finish proc~init->proc~save_time_serie proc~finish->proc~save_time_serie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: final_state (:,:) Final state. integer(kind=I_P), public, save :: tsfile File unit for saving time serie results. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie.html","title":"save_time_serie – Shu-Osher-shock-tube-problem"},{"text":"private purefunction output(self) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output.html","title":"output – Shu-Osher-shock-tube-problem"},{"text":"private purefunction compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. Calls proc~~compute_dt~~CallsGraph proc~compute_dt compute_dt proc~a a proc~compute_dt->proc~a Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: P (:) Primitive variables. real(kind=R_P), public :: vmax Maximum propagation speed of signals. integer(kind=I_P), public :: i Counter. Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt.html","title":"compute_dt – Shu-Osher-shock-tube-problem"},{"text":"private function dEuler_dt(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: F (:,:) Fluxes of conservative variables. real(kind=R_P), public, allocatable :: P (:,:) Primitive variables. real(kind=R_P), public, allocatable :: PR (:,:,:) Left (1) and right (2) (reconstructed) interface values of primitive variables. integer(kind=I_P), public :: i Counter. Source Code function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F, PR) do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D :: dState_dt ) select type ( dState_dt ) class is ( euler_1D ) dState_dt = self endselect !$OMP PARALLEL PRIVATE(i) SHARED(self, dState_dt, F) select type ( dState_dt ) class is ( euler_1D ) !$OMP DO do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt.html","title":"dEuler_dt – Shu-Osher-shock-tube-problem"},{"text":"private function euler_local_error(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 euler approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. integer(kind=I_P), public :: v Variables counter. Source Code function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) error = 0._R_P do i = 1 , lhs % Ni do v = 1 , lhs % Nc error = error + ( lhs % U ( v , i ) - rhs % U ( v , i )) ** 2 / lhs % U ( v , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error","tags":"","loc":"proc/euler_local_error.html","title":"euler_local_error – Shu-Osher-shock-tube-problem"},{"text":"private function euler_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D ) select type ( rhs ) class is ( euler_1D ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) * rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler","tags":"","loc":"proc/euler_multiply_euler.html","title":"euler_multiply_euler – Shu-Osher-shock-tube-problem"},{"text":"private function euler_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) * rhs enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real","tags":"","loc":"proc/euler_multiply_real.html","title":"euler_multiply_real – Shu-Osher-shock-tube-problem"},{"text":"private function real_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = rhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D ) !$OMP DO do i = 1 , rhs % Ni opr % U (:, i ) = rhs % U (:, i ) * lhs enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler","tags":"","loc":"proc/real_multiply_euler.html","title":"real_multiply_euler – Shu-Osher-shock-tube-problem"},{"text":"private function add_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D ) select type ( rhs ) class is ( euler_1D ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) + rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler","tags":"","loc":"proc/add_euler.html","title":"add_euler – Shu-Osher-shock-tube-problem"},{"text":"private function sub_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D ) select type ( rhs ) class is ( euler_1D ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) - rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler","tags":"","loc":"proc/sub_euler.html","title":"sub_euler – Shu-Osher-shock-tube-problem"},{"text":"private purefunction primitive2conservative(self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative.html","title":"primitive2conservative – Shu-Osher-shock-tube-problem"},{"text":"private purefunction conservative2primitive(self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: c (:) Species concentration. Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive.html","title":"conservative2primitive – Shu-Osher-shock-tube-problem"},{"text":"private elementalfunction p(r, a, g) result(pressure) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Description Compute the pressure for an ideal calorically perfect gas. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p.html","title":"p – Shu-Osher-shock-tube-problem"},{"text":"private elementalfunction r(p, a, g) result(density) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Description Compute the density for an ideal calorically perfect gas. Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r.html","title":"r – Shu-Osher-shock-tube-problem"},{"text":"private elementalfunction a(p, r, g) result(ss) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Description Compute the speed of sound for an ideal calorically perfect gas. Called By proc~~a~~CalledByGraph proc~a a none~eigen_vect_l eigen_vect_L none~eigen_vect_l->proc~a proc~compute_dt compute_dt proc~compute_dt->proc~a none~eigen_vect_r eigen_vect_R none~eigen_vect_r->proc~a proc~reconstruct_interfaces_states reconstruct_interfaces_states proc~reconstruct_interfaces_states->none~eigen_vect_l proc~reconstruct_interfaces_states->none~eigen_vect_r Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a.html","title":"a – Shu-Osher-shock-tube-problem"},{"text":"private elementalfunction E(p, r, u, g) result(energy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Description Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~e~~CalledByGraph proc~e E proc~riemann_solver riemann_solver proc~riemann_solver->proc~e Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e.html","title":"E – Shu-Osher-shock-tube-problem"},{"text":"private elementalfunction H(p, r, u, g) result(entalpy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Description Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By proc~~h~~CalledByGraph proc~h H none~fluxes fluxes none~fluxes->proc~h proc~riemann_solver riemann_solver proc~riemann_solver->none~fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h.html","title":"H – Shu-Osher-shock-tube-problem"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. Calls proc~~init~2~~CallsGraph proc~init~2 init interface~weno_constructor_upwind weno_constructor_upwind proc~init~2->interface~weno_constructor_upwind proc~weno_constructor_upwind_init weno_constructor_upwind_init interface~weno_constructor_upwind->proc~weno_constructor_upwind_init Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( weno_factory ), public :: factory WENO factory. class( weno_interpolator ), public, allocatable :: weno WENO interpolator. integer(kind=I_P), public :: i Space counter. Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~2.html","title":"init – Shu-Osher-shock-tube-problem"},{"text":"private puresubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. Description Destroy field. Source Code pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy.html","title":"destroy – Shu-Osher-shock-tube-problem"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Nc , 1 : lhs % Ni )) endif if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) select type ( rhs ) class is ( euler_1D ) if ( allocated ( rhs % U )) then !$OMP DO do i = 1 , lhs % Ni lhs % U (:, i ) = rhs % U (:, i ) enddo endif endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler.html","title":"euler_assign_euler – Shu-Osher-shock-tube-problem"},{"text":"private subroutine euler_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) then !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) do i = 1 , lhs % Ni lhs % U (:, i ) = rhs enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real","tags":"","loc":"proc/euler_assign_real.html","title":"euler_assign_real – Shu-Osher-shock-tube-problem"},{"text":"private puresubroutine impose_boundary_conditions(self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions.html","title":"impose_boundary_conditions – Shu-Osher-shock-tube-problem"},{"text":"private subroutine reconstruct_interfaces_states(self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Calls proc~~reconstruct_interfaces_states~~CallsGraph proc~reconstruct_interfaces_states reconstruct_interfaces_states none~eigen_vect_l eigen_vect_L proc~reconstruct_interfaces_states->none~eigen_vect_l none~eigen_vect_r eigen_vect_R proc~reconstruct_interfaces_states->none~eigen_vect_r proc~a a none~eigen_vect_l->proc~a none~eigen_vect_r->proc~a Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: C (1:2,1-self%Ng:-1+self%Ng,1:self%Ns+2) Pseudo characteristic variables. real(kind=R_P), public :: CR (1:self%Ns+2,1:2) Pseudo characteristic reconst. vars. real(kind=R_P), public :: Pm (1:self%Np,1:2) Mean of primitive variables. real(kind=R_P), public :: LPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean left eigenvectors matrix. real(kind=R_P), public :: RPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean right eigenvectors matrix. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. integer(kind=I_P), public :: f Counter. integer(kind=I_P), public :: v Counter. Functions purefunction eigen_vect_L(Ns, Np, primitive) result(L) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Left eigenvectors matrix. Description Compute left eigenvectors from primitive variables. purefunction eigen_vect_R(Ns, Np, primitive) result(R) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Right eigenvectors matrix. Description Compute right eigenvectors from primitive variables. Source Code subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- !$OMP PARALLEL PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) SHARED(self, primitive, r_primitive) select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction !$OMP DO do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction !$OMP DO do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect !$OMP END PARALLEL return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states.html","title":"reconstruct_interfaces_states – Shu-Osher-shock-tube-problem"},{"text":"private puresubroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Calls proc~~riemann_solver~~CallsGraph proc~riemann_solver riemann_solver proc~compute_inter_states compute_inter_states proc~riemann_solver->proc~compute_inter_states proc~e E proc~riemann_solver->proc~e none~fluxes fluxes proc~riemann_solver->none~fluxes proc~h H none~fluxes->proc~h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: F1 (1:3) State 1 fluxes. real(kind=R_P), public :: F4 (1:3) State 4 fluxes. real(kind=R_P), public :: u Velocity of the intermediate states. real(kind=R_P), public :: p Pressure of the intermediate states. real(kind=R_P), public :: S1 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: S4 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: lmax Maximum wave speed estimation. Functions purefunction fluxes(p, r, u, g) result(Fc) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Velocity. real(kind=R_P), intent(in) :: g Specific heats ratio. Return Value real(kind=R_P)\n  (1:3) State fluxes. Description 1D Euler fluxes from primitive variables. Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver.html","title":"riemann_solver – Shu-Osher-shock-tube-problem"},{"text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( euler_1D ), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize.html","title":"finalize – Shu-Osher-shock-tube-problem"},{"text":"private puresubroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Description Compute inter states (23*-states) from state1 and state4. Called By proc~~compute_inter_states~~CalledByGraph proc~compute_inter_states compute_inter_states proc~riemann_solver riemann_solver proc~riemann_solver->proc~compute_inter_states Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: a1 Speed of sound of state 1. real(kind=R_P), public :: a4 Speed of sound of state 4. real(kind=R_P), public :: ram Mean value of rho*a. real(kind=R_P), public, parameter :: toll = 1e-10_R_P Tollerance. Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states.html","title":"compute_inter_states – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine init(self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. Source Code elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~3.html","title":"init – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~2.html","title":"destroy – Shu-Osher-shock-tube-problem"},{"text":"private subroutine integrate(self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coefficients are initialized). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s First stages counter. integer(kind=I_P), public :: ss Second stages counter. Source Code subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! computing new time step do s = 1 , self % stages U = U + stage ( s ) * ( Dt * self % beta ( s )) enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate.html","title":"integrate – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~2.html","title":"finalize – Shu-Osher-shock-tube-problem"},{"text":"private subroutine integrate(U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. Description Integrate field with explicit Euler scheme, 1st order. Source Code subroutine integrate ( U , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit Euler scheme, 1st order. !--------------------------------------------------------------------------------------------------------------------------------- class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), optional , intent ( IN ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- U = U + U % t ( t = t ) * Dt return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~2.html","title":"integrate – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine init(self, nu, alpha) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(inout) :: self LF integrator. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. Description Create the actual leapfrog integrator: initialize the filter coefficient. Source Code elemental subroutine init ( self , nu , alpha ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual leapfrog integrator: initialize the filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( INOUT ) :: self !< LF integrator. real ( R_P ), optional , intent ( IN ) :: nu !< Williams-Robert-Asselin filter coefficient. real ( R_P ), optional , intent ( IN ) :: alpha !< Robert-Asselin filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % nu = 0.01_R_P self % alpha = 0.53_R_P if ( present ( nu )) self % nu = nu if ( present ( alpha )) self % alpha = alpha return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~4.html","title":"init – Shu-Osher-shock-tube-problem"},{"text":"private subroutine integrate(self, U, previous, Dt, t, filter) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(in) :: self LF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:2) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. class( integrand ), intent(inout), optional :: filter Filter field displacement. Description Integrate field with leapfrog class scheme. Source Code subroutine integrate ( self , U , previous , Dt , t , filter ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with leapfrog class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( IN ) :: self !< LF integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 : 2 ) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. class ( integrand ), optional , intent ( INOUT ) :: filter !< Filter field displacement. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- U = previous ( 1 ) + previous ( 2 )% t ( t = t ) * ( Dt * 2._R_P ) if ( present ( filter )) then filter = ( previous ( 1 ) - previous ( 2 ) * 2._R_P + U ) * self % nu * 0.5_R_P previous ( 2 ) = previous ( 2 ) + filter * self % alpha U = U + filter * ( self % alpha - 1._R_P ) endif previous ( 1 ) = previous ( 2 ) previous ( 2 ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~3.html","title":"integrate – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine init(self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth integrator: initialize the b coefficients. Source Code elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 1 : steps )) ; self % b = 0._R_P select case ( steps ) case ( 1 ) ! AB(1) Forward-Euler self % b ( 1 ) = 1._R_P case ( 2 ) ! AB(2) self % b ( 1 ) = - 0.5_R_P self % b ( 2 ) = 1.5_R_P case ( 3 ) ! AB(3) self % b ( 1 ) = 5._R_P / 1 2._R_P self % b ( 2 ) = - 4._R_P / 3._R_P self % b ( 3 ) = 2 3._R_P / 1 2._R_P case ( 4 ) ! AB(4) self % b ( 1 ) = - 3._R_P / 8._R_P self % b ( 2 ) = 3 7._R_P / 2 4._R_P self % b ( 3 ) = - 5 9._R_P / 2 4._R_P self % b ( 4 ) = 5 5._R_P / 2 4._R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~5.html","title":"init – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 if ( allocated ( self % b )) deallocate ( self % b ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~3.html","title":"destroy – Shu-Osher-shock-tube-problem"},{"text":"private subroutine integrate(self, U, previous, Dt, t, autoupdate) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Description Integrate field with Adams-Bashforth class scheme. Variables Type Visibility Attributes Name Initial logical, public :: autoupdate_ Perform cyclic autoupdate of previous time steps, dummy var. integer(kind=I_P), public :: s Steps counter. Source Code subroutine integrate ( self , U , previous , Dt , t , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate do s = 1 , self % steps U = U + previous ( s )% t ( t = t ( s )) * ( Dt * self % b ( s )) enddo if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~4.html","title":"integrate – Shu-Osher-shock-tube-problem"},{"text":"private subroutine update_previous(self, U, previous) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Description Cyclic update previous time steps. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Steps counter. Source Code subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do s = 1 , self % steps - 1 previous ( s ) = previous ( s + 1 ) enddo previous ( self % steps ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous","tags":"","loc":"proc/update_previous.html","title":"update_previous – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~3.html","title":"finalize – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine init(self, steps) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Moulton integrator: initialize the b coefficients. Source Code elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Moulton integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 0 : steps )) ; self % b = 0._R_P select case ( steps ) case ( 0 ) ! AM(0) Bacward-Euler self % b ( 0 ) = 1._R_P case ( 1 ) ! AM(1) self % b ( 0 ) = 0.5_R_P self % b ( 1 ) = 0.5_R_P case ( 2 ) ! AM(2) self % b ( 0 ) = - 1._R_P / 1 2._R_P self % b ( 1 ) = 2._R_P / 3._R_P self % b ( 2 ) = 5._R_P / 1 2._R_P case ( 3 ) ! AM(3) self % b ( 0 ) = 1._R_P / 2 4._R_P self % b ( 1 ) = - 5._R_P / 2 4._R_P self % b ( 2 ) = 1 9._R_P / 2 4._R_P self % b ( 3 ) = 3._R_P / 8._R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~6.html","title":"init – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = - 1 if ( allocated ( self % b )) deallocate ( self % b ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~4.html","title":"destroy – Shu-Osher-shock-tube-problem"},{"text":"private subroutine integrate(self, U, previous, Dt, t, iterations, autoupdate) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Description Integrate field with Adams-Moulton class scheme. Variables Type Visibility Attributes Name Initial logical, public :: autoupdate_ Perform cyclic autoupdate of previous time steps, dummy var. class( integrand ), public, allocatable :: delta Delta RHS for fixex point iterations. integer(kind=I_P), public :: s Steps counter. Source Code subroutine integrate ( self , U , previous , Dt , t , iterations , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Moulton class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. class ( integrand ), allocatable :: delta !< Delta RHS for fixex point iterations. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate if ( self % steps > 0 ) then if ( present ( iterations )) then ! perform fixed point iterations allocate ( delta , source = previous ( self % steps )) do s = 0 , self % steps - 1 delta = delta + previous ( s + 1 )% t ( t = t ( s + 1 )) * ( Dt * self % b ( s )) enddo do s = 1 , iterations U = delta + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps )) enddo else U = previous ( self % steps ) + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps )) do s = 0 , self % steps - 1 U = U + previous ( s + 1 )% t ( t = t ( s + 1 )) * ( Dt * self % b ( s )) enddo endif if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) else U = U + U % t ( t = t ( 1 )) * ( Dt * self % b ( 0 )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~5.html","title":"integrate – Shu-Osher-shock-tube-problem"},{"text":"private subroutine update_previous(self, U, previous) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Description Cyclic update previous time steps. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Steps counter. Source Code subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 0 , self % steps - 2 previous ( s + 1 ) = previous ( s + 2 ) enddo previous ( self % steps ) = U endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous","tags":"","loc":"proc/update_previous~2.html","title":"update_previous – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( adams_moulton_integrator ), intent(inout) :: self AB integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~4.html","title":"finalize – Shu-Osher-shock-tube-problem"},{"text":"private subroutine init(self, stages) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' low storage table coefficients. Source Code subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' low storage table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % A )) deallocate ( self % A ) ; allocate ( self % A ( 1 : stages )) ; self % A = 0._R_P if ( allocated ( self % B )) deallocate ( self % B ) ; allocate ( self % B ( 1 : stages )) ; self % B = 0._R_P if ( allocated ( self % C )) deallocate ( self % C ) ; allocate ( self % C ( 1 : stages )) ; self % C = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % B ( 1 ) = 1._R_P case ( 5 ) ! LSRK(5,4) self % A ( 1 ) = 0._R_P self % A ( 2 ) = - real ( 567301805773_I8P , kind = R_P ) / real ( 1357537059087_I8P , kind = R_P ) self % A ( 3 ) = - real ( 2404267990393_I8P , kind = R_P ) / real ( 2016746695238_I8P , kind = R_P ) self % A ( 4 ) = - real ( 3550918686646_I8P , kind = R_P ) / real ( 2091501179385_I8P , kind = R_P ) self % A ( 5 ) = - real ( 1275806237668_I8P , kind = R_P ) / real ( 842570457699_I8P , kind = R_P ) self % B ( 1 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % B ( 2 ) = real ( 5161836677717_I8P , kind = R_P ) / real ( 13612068292357_I8P , kind = R_P ) self % B ( 3 ) = real ( 1720146321549_I8P , kind = R_P ) / real ( 2090206949498_I8P , kind = R_P ) self % B ( 4 ) = real ( 3134564353537_I8P , kind = R_P ) / real ( 4481467310338_I8P , kind = R_P ) self % B ( 5 ) = real ( 2277821191437_I8P , kind = R_P ) / real ( 14882151754819_I8P , kind = R_P ) self % C ( 1 ) = 0._R_P self % C ( 2 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % C ( 3 ) = real ( 2526269341429_I8P , kind = R_P ) / real ( 6820363962896_I8P , kind = R_P ) self % C ( 4 ) = real ( 2006345519317_I8P , kind = R_P ) / real ( 3224310063776_I8P , kind = R_P ) self % C ( 5 ) = real ( 2802321613138_I8P , kind = R_P ) / real ( 2924317926251_I8P , kind = R_P ) case ( 6 ) ! LSRK(6,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.122000000000_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.691750960670_R_P ; self % B ( 2 ) = 0.477263056358_R_P ; self % C ( 2 ) = 0.122000000000_R_P self % A ( 3 ) = - 1.727127405211_R_P ; self % B ( 3 ) = 0.381941220320_R_P ; self % C ( 3 ) = 0.269115878630_R_P self % A ( 4 ) = - 0.694890150986_R_P ; self % B ( 4 ) = 0.447757195744_R_P ; self % C ( 4 ) = 0.447717183551_R_P self % A ( 5 ) = - 1.039942756197_R_P ; self % B ( 5 ) = 0.498614246822_R_P ; self % C ( 5 ) = 0.749979795490_R_P self % A ( 6 ) = - 1.531977447611_R_P ; self % B ( 6 ) = 0.186648570846_R_P ; self % C ( 6 ) = 0.898555413085_R_P case ( 7 ) ! LSRK(7,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.117322146869_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.647900745934_R_P ; self % B ( 2 ) = 0.503270262127_R_P ; self % C ( 2 ) = 0.117322146869_R_P self % A ( 3 ) = - 2.704760863204_R_P ; self % B ( 3 ) = 0.233663281658_R_P ; self % C ( 3 ) = 0.294523230758_R_P self % A ( 4 ) = - 0.460080550118_R_P ; self % B ( 4 ) = 0.283419634625_R_P ; self % C ( 4 ) = 0.305658622131_R_P self % A ( 5 ) = - 0.500581787785_R_P ; self % B ( 5 ) = 0.540367414023_R_P ; self % C ( 5 ) = 0.582864148403_R_P self % A ( 6 ) = - 1.906532255913_R_P ; self % B ( 6 ) = 0.371499414620_R_P ; self % C ( 6 ) = 0.858664273599_R_P self % A ( 7 ) = - 1.450000000000_R_P ; self % B ( 7 ) = 0.136670099385_R_P ; self % C ( 7 ) = 0.868664273599_R_P case ( 12 ) ! LSRK(12,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0650008435125904_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.0923311242368072_R_P ; self % B ( 2 ) = 0.0161459902249842_R_P ; self % C ( 2 ) = 0.0650008435125904_R_P self % A ( 3 ) = - 0.9441056581158819_R_P ; self % B ( 3 ) = 0.5758627178358159_R_P ; self % C ( 3 ) = 0.0796560563081853_R_P self % A ( 4 ) = - 4.3271273247576394_R_P ; self % B ( 4 ) = 0.1649758848361671_R_P ; self % C ( 4 ) = 0.1620416710085376_R_P self % A ( 5 ) = - 2.1557771329026072_R_P ; self % B ( 5 ) = 0.3934619494248182_R_P ; self % C ( 5 ) = 0.2248877362907778_R_P self % A ( 6 ) = - 0.9770727190189062_R_P ; self % B ( 6 ) = 0.0443509641602719_R_P ; self % C ( 6 ) = 0.2952293985641261_R_P self % A ( 7 ) = - 0.7581835342571139_R_P ; self % B ( 7 ) = 0.2074504268408778_R_P ; self % C ( 7 ) = 0.3318332506149405_R_P self % A ( 8 ) = - 1.7977525470825499_R_P ; self % B ( 8 ) = 0.6914247433015102_R_P ; self % C ( 8 ) = 0.4094724050198658_R_P self % A ( 9 ) = - 2.6915667972700770_R_P ; self % B ( 9 ) = 0.3766646883450449_R_P ; self % C ( 9 ) = 0.6356954475753369_R_P self % A ( 10 ) = - 4.6466798960268143_R_P ; self % B ( 10 ) = 0.0757190350155483_R_P ; self % C ( 10 ) = 0.6806551557645497_R_P self % A ( 11 ) = - 0.1539613783825189_R_P ; self % B ( 11 ) = 0.2027862031054088_R_P ; self % C ( 11 ) = 0.7143773712418350_R_P self % A ( 12 ) = - 0.5943293901830616_R_P ; self % B ( 12 ) = 0.2167029365631842_R_P ; self % C ( 12 ) = 0.9032588871651854_R_P case ( 13 ) ! LSRK(13,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0271990297818803_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.6160178650170565_R_P ; self % B ( 2 ) = 0.1772488819905108_R_P ; self % C ( 2 ) = 0.0271990297818803_R_P self % A ( 3 ) = - 0.4449487060774118_R_P ; self % B ( 3 ) = 0.0378528418949694_R_P ; self % C ( 3 ) = 0.0952594339119365_R_P self % A ( 4 ) = - 1.0952033345276178_R_P ; self % B ( 4 ) = 0.6086431830142991_R_P ; self % C ( 4 ) = 0.1266450286591127_R_P self % A ( 5 ) = - 1.2256030785959187_R_P ; self % B ( 5 ) = 0.2154313974316100_R_P ; self % C ( 5 ) = 0.1825883045699772_R_P self % A ( 6 ) = - 0.2740182222332805_R_P ; self % B ( 6 ) = 0.2066152563885843_R_P ; self % C ( 6 ) = 0.3737511439063931_R_P self % A ( 7 ) = - 0.0411952089052647_R_P ; self % B ( 7 ) = 0.0415864076069797_R_P ; self % C ( 7 ) = 0.5301279418422206_R_P self % A ( 8 ) = - 0.1797084899153560_R_P ; self % B ( 8 ) = 0.0219891884310925_R_P ; self % C ( 8 ) = 0.5704177433952291_R_P self % A ( 9 ) = - 1.1771530652064288_R_P ; self % B ( 9 ) = 0.9893081222650993_R_P ; self % C ( 9 ) = 0.5885784947099155_R_P self % A ( 10 ) = - 0.4078831463120878_R_P ; self % B ( 10 ) = 0.0063199019859826_R_P ; self % C ( 10 ) = 0.6160769826246714_R_P self % A ( 11 ) = - 0.8295636426191777_R_P ; self % B ( 11 ) = 0.3749640721105318_R_P ; self % C ( 11 ) = 0.6223252334314046_R_P self % A ( 12 ) = - 4.7895970584252288_R_P ; self % B ( 12 ) = 1.6080235151003195_R_P ; self % C ( 12 ) = 0.6897593128753419_R_P self % A ( 13 ) = - 0.6606671432964504_R_P ; self % B ( 13 ) = 0.0961209123818189_R_P ; self % C ( 13 ) = 0.9126827615920843_R_P case ( 14 ) ! LSRK(14,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0367762454319673_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.7188012108672410_R_P ; self % B ( 2 ) = 0.3136296607553959_R_P ; self % C ( 2 ) = 0.0367762454319673_R_P self % A ( 3 ) = - 0.7785331173421570_R_P ; self % B ( 3 ) = 0.1531848691869027_R_P ; self % C ( 3 ) = 0.1249685262725025_R_P self % A ( 4 ) = - 0.0053282796654044_R_P ; self % B ( 4 ) = 0.0030097086818182_R_P ; self % C ( 4 ) = 0.2446177702277698_R_P self % A ( 5 ) = - 0.8552979934029281_R_P ; self % B ( 5 ) = 0.3326293790646110_R_P ; self % C ( 5 ) = 0.2476149531070420_R_P self % A ( 6 ) = - 3.9564138245774565_R_P ; self % B ( 6 ) = 0.2440251405350864_R_P ; self % C ( 6 ) = 0.2969311120382472_R_P self % A ( 7 ) = - 1.5780575380587385_R_P ; self % B ( 7 ) = 0.3718879239592277_R_P ; self % C ( 7 ) = 0.3978149645802642_R_P self % A ( 8 ) = - 2.0837094552574054_R_P ; self % B ( 8 ) = 0.6204126221582444_R_P ; self % C ( 8 ) = 0.5270854589440328_R_P self % A ( 9 ) = - 0.7483334182761610_R_P ; self % B ( 9 ) = 0.1524043173028741_R_P ; self % C ( 9 ) = 0.6981269994175695_R_P self % A ( 10 ) = - 0.7032861106563359_R_P ; self % B ( 10 ) = 0.0760894927419266_R_P ; self % C ( 10 ) = 0.8190890835352128_R_P self % A ( 11 ) = 0.0013917096117681_R_P ; self % B ( 11 ) = 0.0077604214040978_R_P ; self % C ( 11 ) = 0.8527059887098624_R_P self % A ( 12 ) = - 0.0932075369637460_R_P ; self % B ( 12 ) = 0.0024647284755382_R_P ; self % C ( 12 ) = 0.8604711817462826_R_P self % A ( 13 ) = - 0.9514200470875948_R_P ; self % B ( 13 ) = 0.0780348340049386_R_P ; self % C ( 13 ) = 0.8627060376969976_R_P self % A ( 14 ) = - 7.1151571693922548_R_P ; self % B ( 14 ) = 5.5059777270269628_R_P ; self % C ( 14 ) = 0.8734213127600976_R_P case default write ( stderr , '(A,I3,A)' ) ' Error: ls_runge_kutta_integrator%init: ' , stages , ' is an invalid number-of-stages!' write ( stderr , '(A)' ) ' Valid number of stages are:' write ( stderr , '(A)' ) '   1  => LSRK(1, 1)' write ( stderr , '(A)' ) '   5  => LSRK(5, 4)' write ( stderr , '(A)' ) '   6  => LSRK(6, 4)' write ( stderr , '(A)' ) '   7  => LSRK(7, 4)' write ( stderr , '(A)' ) '   12 => LSRK(12, 4)' write ( stderr , '(A)' ) '   13 => LSRK(13, 4)' write ( stderr , '(A)' ) '   14 => LSRK(14, 4)' endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~7.html","title":"init – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % A )) deallocate ( self % A ) if ( allocated ( self % B )) deallocate ( self % B ) if ( allocated ( self % C )) deallocate ( self % C ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~5.html","title":"destroy – Shu-Osher-shock-tube-problem"},{"text":"private subroutine integrate(self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:2) Runge-Kutta registers [1:2]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit low storage Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coefficients are initialized). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s First stages counter. Source Code subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit low storage Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 : 2 ) !< Runge-Kutta registers [1:2]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages stage ( 1 ) = U stage ( 2 ) = U * 0._R_P do s = 1 , self % stages stage ( 2 ) = stage ( 2 ) * self % A ( s ) + stage ( 1 )% t ( t = t + self % C ( s ) * Dt ) * Dt stage ( 1 ) = stage ( 1 ) + stage ( 2 ) * self % B ( s ) enddo U = stage ( 1 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~6.html","title":"integrate – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~5.html","title":"finalize – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine init(self, stages, tolerance) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. real(kind=R_P), intent(in), optional :: tolerance Tolerance on the local truncation error (default 0.01). Description Create the actual RK integrator: initialize the Butcher' table coefficients. Source Code elemental subroutine init ( self , stages , tolerance ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. real ( R_P ), optional , intent ( IN ) :: tolerance !< Tolerance on the local truncation error (default 0.01). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added if ( present ( tolerance )) then self % tolerance = tolerance else self % tolerance = 0.01_R_P endif self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages , 1 : 2 )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 2 ) ! HERK(2,2) self % pp1_inv = 1._R_P / ( 2._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.5_R_P ; self % beta ( 1 , 2 ) = 5._R_P self % beta ( 2 , 1 ) = 1._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 6 ) ! CKRK(6,5) self % pp1_inv = 1._R_P / ( 5._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 7._R_P / 37 8._R_P ; self % beta ( 1 , 2 ) = 282 5._R_P / 2764 8._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 25 0._R_P / 62 1._R_P ; self % beta ( 3 , 2 ) = 1857 5._R_P / 4838 4._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 59 4._R_P ; self % beta ( 4 , 2 ) = 1352 5._R_P / 5529 6._R_P self % beta ( 5 , 1 ) = 0._R_P ; self % beta ( 5 , 2 ) = 27 7._R_P / 1433 6._R_P self % beta ( 6 , 1 ) = 51 2._R_P / 177 1._R_P ; self % beta ( 6 , 2 ) = 1._R_P / 4._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 1 0._R_P ; self % alph ( 4 , 2 ) = - 9._R_P / 1 0._R_P ; self % alph ( 4 , 3 ) = 6._R_P / 5._R_P self % alph ( 5 , 1 ) =- 1 1._R_P / 5 4._R_P ; self % alph ( 5 , 2 ) = 5._R_P / 2._R_P ; self % alph ( 5 , 3 ) =- 7 0._R_P / 2 7._R_P self % alph ( 6 , 1 ) = 163 1._R_P / 5529 6._R_P ; self % alph ( 6 , 2 ) = 17 5._R_P / 51 2._R_P ; self % alph ( 6 , 3 ) = 57 5._R_P / 1382 4._R_P self % alph ( 5 , 4 ) = 3 5._R_P / 2 7._R_P self % alph ( 6 , 4 ) = 4427 5._R_P / 11059 2._R_P ; self % alph ( 6 , 5 ) = 25 3._R_P / 409 6._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 3._R_P / 5._R_P self % gamm ( 5 ) = 1._R_P self % gamm ( 6 ) = 7._R_P / 8._R_P case ( 7 ) ! DPRK(7,4) self % pp1_inv = 1._R_P / ( 4._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 5._R_P / 38 4._R_P ; self % beta ( 1 , 2 ) = 517 9._R_P / 5760 0._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 50 0._R_P / 111 3._R_P ; self % beta ( 3 , 2 ) = 757 1._R_P / 1669 5._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 19 2._R_P ; self % beta ( 4 , 2 ) = 39 3._R_P / 64 0._R_P self % beta ( 5 , 1 ) = - 218 7._R_P / 678 4._R_P ; self % beta ( 5 , 2 ) = - 9209 7._R_P / 33920 0._R_P self % beta ( 6 , 1 ) = 1 1._R_P / 8 4._R_P ; self % beta ( 6 , 2 ) = 18 7._R_P / 210 0._R_P self % beta ( 7 , 1 ) = 0._R_P ; self % beta ( 7 , 2 ) = 1._R_P / 4 0._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 4 4._R_P / 4 5._R_P ; self % alph ( 4 , 2 ) =- 5 6._R_P / 1 5._R_P ; self % alph ( 4 , 3 ) = 3 2._R_P / 9._R_P self % alph ( 5 , 1 ) = 1937 2._R_P / 656 1._R_P ; self % alph ( 5 , 2 ) =- 2536 0._R_P / 218 7._R_P ; self % alph ( 5 , 3 ) = 6444 8._R_P / 656 1._R_P self % alph ( 6 , 1 ) = 901 7._R_P / 316 8._R_P ; self % alph ( 6 , 2 ) =- 35 5._R_P / 3 3._R_P ; self % alph ( 6 , 3 ) = 4673 2._R_P / 524 7._R_P self % alph ( 7 , 1 ) = 3 5._R_P / 38 4._R_P ; self % alph ( 7 , 2 ) = 0._R_P ; self % alph ( 7 , 3 ) = 50 0._R_P / 111 3._R_P self % alph ( 5 , 4 ) =- 21 2._R_P / 72 9._R_P self % alph ( 6 , 4 ) = 4 9._R_P / 17 6._R_P ; self % alph ( 6 , 5 ) =- 510 3._R_P / 1865 6._R_P self % alph ( 7 , 4 ) = 12 5._R_P / 19 2._R_P ; self % alph ( 7 , 5 ) =- 218 7._R_P / 678 4._R_P ; self % alph ( 7 , 6 ) = 1 1._R_P / 8 4._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 4._R_P / 5._R_P self % gamm ( 5 ) = 8._R_P / 9._R_P self % gamm ( 6 ) = 1._R_P self % gamm ( 7 ) = 1._R_P case ( 9 ) ! CMRK(9,6) self % pp1_inv = 1._R_P / ( 6._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % beta ( 1 , 2 ) = 1523166 5._R_P / 51083033 4._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 5751301 1._R_P / 20186425 0._R_P ; self % beta ( 3 , 2 ) = 5945299 1._R_P / 11605044 8._R_P self % beta ( 4 , 1 ) = 1558730 6._R_P / 35450157 1._R_P ; self % beta ( 4 , 2 ) = - 2839851 7._R_P / 12243773 8._R_P self % beta ( 5 , 1 ) = 7178302 1._R_P / 23498286 5._R_P ; self % beta ( 5 , 2 ) = 5667382 4._R_P / 13701055 9._R_P self % beta ( 6 , 1 ) = 2967200 0._R_P / 18048016 7._R_P ; self % beta ( 6 , 2 ) = 6800384 9._R_P / 42667358 3._R_P self % beta ( 7 , 1 ) = 6556762 1._R_P / 12706095 2._R_P ; self % beta ( 7 , 2 ) = 709763 1._R_P / 3756402 1._R_P self % beta ( 8 , 1 ) = - 7907457 0._R_P / 21055759 7._R_P ; self % beta ( 8 , 2 ) = - 7122642 9._R_P / 58309374 2._R_P self % beta ( 9 , 1 ) = 0._R_P ; self % beta ( 9 , 2 ) = 1._R_P / 2 0._R_P self % alph ( 2 , 1 ) = 2._R_P / 1 5._R_P self % alph ( 3 , 1 ) = 1._R_P / 2 0._R_P ; self % alph ( 3 , 2 ) = 3._R_P / 2 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 8672701 5._R_P / 19685155 3._R_P ; self % alph ( 5 , 2 ) =- 6012907 3._R_P / 5262471 2._R_P self % alph ( 6 , 1 ) =- 8686084 9._R_P / 4562896 7._R_P ; self % alph ( 6 , 2 ) = 11102288 5._R_P / 2571648 7._R_P self % alph ( 7 , 1 ) = 7775959 1._R_P / 1609646 7._R_P ; self % alph ( 7 , 2 ) =- 4925280 9._R_P / 645255 5._R_P self % alph ( 8 , 1 ) = 23756426 3._R_P / 3928029 5._R_P ; self % alph ( 8 , 2 ) =- 10052323 9._R_P / 1067794 0._R_P self % alph ( 9 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 4 , 3 ) = 9._R_P / 4 0._R_P self % alph ( 5 , 3 ) = 95743643 4._R_P / 137835237 7._R_P ; self % alph ( 5 , 4 ) = 8388683 2._R_P / 14784244 1._R_P self % alph ( 6 , 3 ) = 10804668 2._R_P / 10116766 9._R_P ; self % alph ( 6 , 4 ) =- 14175674 6._R_P / 3600546 1._R_P self % alph ( 7 , 3 ) =- 38168011 1._R_P / 5157298 4._R_P ; self % alph ( 7 , 4 ) = 87926957 9._R_P / 6678883 1._R_P self % alph ( 8 , 3 ) =- 26557484 6._R_P / 2733024 7._R_P ; self % alph ( 8 , 4 ) = 31797841 1._R_P / 1898871 3._R_P self % alph ( 9 , 3 ) = 5751301 1._R_P / 20186425 0._R_P ; self % alph ( 9 , 4 ) = 1558730 6._R_P / 35450157 1._R_P self % alph ( 6 , 5 ) = 7313986 2._R_P / 6017063 3._R_P self % alph ( 7 , 5 ) =- 9045312 1._R_P / 3372216 2._R_P ; self % alph ( 7 , 6 ) = 11117955 2._R_P / 15715582 7._R_P self % alph ( 8 , 5 ) =- 12449438 5._R_P / 3545362 7._R_P ; self % alph ( 8 , 6 ) = 8682244 4._R_P / 10013863 5._R_P self % alph ( 9 , 5 ) = 7178302 1._R_P / 23498286 5._R_P ; self % alph ( 9 , 6 ) = 2967200 0._R_P / 18048016 7._R_P self % alph ( 8 , 7 ) =- 1287352 3._R_P / 72423262 5._R_P self % alph ( 9 , 7 ) = 6556762 1._R_P / 12706095 2._R_P ; self % alph ( 9 , 8 ) =- 7907457 0._R_P / 21055759 7._R_P self % gamm ( 2 ) = 2._R_P / 1 5._R_P self % gamm ( 3 ) = 1._R_P / 5._R_P self % gamm ( 4 ) = 3._R_P / 1 0._R_P self % gamm ( 5 ) = 1 4._R_P / 2 5._R_P self % gamm ( 6 ) = 1 9._R_P / 2 5._R_P self % gamm ( 7 ) = 3522660 7._R_P / 3568827 9._R_P self % gamm ( 8 ) = 1._R_P self % gamm ( 9 ) = 1._R_P case ( 17 ) ! FRK(17,10) self % pp1_inv = 1._R_P / ( 1 0._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 1 , 2 ) = 0.033333333333333333333_R_P self % beta ( 2 , 1 ) = 0.025_R_P ; self % beta ( 2 , 2 ) = 1._R_P / 3 6._R_P self % beta ( 3 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 3 , 2 ) = 0.033333333333333333333_R_P self % beta ( 4 , 1 ) = 0._R_P ; self % beta ( 4 , 2 ) = 0._R_P self % beta ( 5 , 1 ) = 0.05_R_P ; self % beta ( 5 , 2 ) = 0.05_R_P self % beta ( 6 , 1 ) = 0._R_P ; self % beta ( 6 , 2 ) = 0._R_P self % beta ( 7 , 1 ) = 0.04_R_P ; self % beta ( 7 , 2 ) = 0.04_R_P self % beta ( 8 , 1 ) = 0._R_P ; self % beta ( 8 , 2 ) = 0._R_P self % beta ( 9 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 9 , 2 ) = 0.189237478148923490158_R_P self % beta ( 10 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 10 , 2 ) = 0.277429188517743176508_R_P self % beta ( 11 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 11 , 2 ) = 0.277429188517743176508_R_P self % beta ( 12 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 12 , 2 ) = 0.189237478148923490158_R_P self % beta ( 13 , 1 ) =- 0.04_R_P ; self % beta ( 13 , 2 ) =- 0.04_R_P self % beta ( 14 , 1 ) =- 0.05_R_P ; self % beta ( 14 , 2 ) =- 0.05_R_P self % beta ( 15 , 1 ) =- 0.033333333333333333333_R_P ; self % beta ( 15 , 2 ) =- 0.033333333333333333333_R_P self % beta ( 16 , 1 ) =- 0.025_R_P ; self % beta ( 16 , 2 ) =- 1._R_P / 3 6._R_P self % beta ( 17 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 17 , 2 ) = 0.033333333333333333333_R_P self % alph ( 2 , 1 ) = 0.1_R_P self % alph ( 3 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 3 , 2 ) = 1.454534402178273228052_R_P self % alph ( 4 , 1 ) = 0.202259190301118170324_R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 0.184024714708643575149_R_P ; self % alph ( 5 , 2 ) = 0._R_P self % alph ( 6 , 1 ) = 0.087900734020668133731_R_P ; self % alph ( 6 , 2 ) = 0._R_P self % alph ( 7 , 1 ) = 0.085970050490246030218_R_P ; self % alph ( 7 , 2 ) = 0._R_P self % alph ( 8 , 1 ) = 0.120930449125333720660_R_P ; self % alph ( 8 , 2 ) = 0._R_P self % alph ( 9 , 1 ) = 0.110854379580391483508_R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 10 , 1 ) = 0.112054414752879004829_R_P ; self % alph ( 10 , 2 ) = 0._R_P self % alph ( 11 , 1 ) = 0.113976783964185986138_R_P ; self % alph ( 11 , 2 ) = 0._R_P self % alph ( 12 , 1 ) = 0.079831452828019604635_R_P ; self % alph ( 12 , 2 ) = 0._R_P self % alph ( 13 , 1 ) = 0.985115610164857280120_R_P ; self % alph ( 13 , 2 ) = 0._R_P self % alph ( 14 , 1 ) = 0.895080295771632891049_R_P ; self % alph ( 14 , 2 ) = 0._R_P self % alph ( 15 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 15 , 2 ) = 1.454534402178273228052_R_P self % alph ( 16 , 1 ) = 0.1_R_P ; self % alph ( 16 , 2 ) = 0._R_P self % alph ( 17 , 1 ) = 0.181781300700095283888_R_P ; self % alph ( 17 , 2 ) = 0.675_R_P self % alph ( 4 , 3 ) = 0.606777570903354510974_R_P self % alph ( 5 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 5 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 6 , 3 ) = 0._R_P ; self % alph ( 6 , 4 ) = 0.410459702520260645318_R_P self % alph ( 7 , 3 ) = 0._R_P ; self % alph ( 7 , 4 ) = 0.330885963040722183948_R_P self % alph ( 8 , 3 ) = 0._R_P ; self % alph ( 8 , 4 ) = 0._R_P self % alph ( 9 , 3 ) = 0._R_P ; self % alph ( 9 , 4 ) = 0._R_P self % alph ( 10 , 3 ) = 0._R_P ; self % alph ( 10 , 4 ) = 0._R_P self % alph ( 11 , 3 ) = 0._R_P ; self % alph ( 11 , 4 ) = 0._R_P self % alph ( 12 , 3 ) = 0._R_P ; self % alph ( 12 , 4 ) = 0._R_P self % alph ( 13 , 3 ) = 0._R_P ; self % alph ( 13 , 4 ) = 0.330885963040722183948_R_P self % alph ( 14 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 14 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 15 , 3 ) = 0._R_P ; self % alph ( 15 , 4 ) = 0._R_P self % alph ( 16 , 3 ) =- 0.157178665799771163367_R_P ; self % alph ( 16 , 4 ) = 0._R_P self % alph ( 17 , 3 ) = 0.342758159847189839942_R_P ; self % alph ( 17 , 4 ) = 0._R_P self % alph ( 6 , 5 ) = 0.482713753678866489204_R_P self % alph ( 7 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 7 , 6 ) =- 0.073185637507085073678_R_P self % alph ( 8 , 5 ) = 0.260124675758295622809_R_P ; self % alph ( 8 , 6 ) = 0.032540262154909133015_R_P self % alph ( 9 , 5 ) = 0._R_P ; self % alph ( 9 , 6 ) =- 0.060576148825500558762_R_P self % alph ( 10 , 5 ) = 0._R_P ; self % alph ( 10 , 6 ) =- 0.144942775902865915672_R_P self % alph ( 11 , 5 ) = 0._R_P ; self % alph ( 11 , 6 ) =- 0.076881336420335693858_R_P self % alph ( 12 , 5 ) = 0._R_P ; self % alph ( 12 , 6 ) =- 0.052032968680060307651_R_P self % alph ( 13 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 13 , 6 ) =- 1.378964865748435675821_R_P self % alph ( 14 , 5 ) = 0._R_P ; self % alph ( 14 , 6 ) =- 0.851236239662007619739_R_P self % alph ( 15 , 5 ) =- 0.777333643644968233538_R_P ; self % alph ( 15 , 6 ) = 0._R_P self % alph ( 16 , 5 ) = 0._R_P ; self % alph ( 16 , 6 ) = 0._R_P self % alph ( 17 , 5 ) = 0.259111214548322744512_R_P ; self % alph ( 17 , 6 ) =- 0.358278966717952089048_R_P self % alph ( 8 , 7 ) =- 0.059578021181736100156_R_P self % alph ( 9 , 7 ) = 0.321763705601778390100_R_P ; self % alph ( 9 , 8 ) = 0.510485725608063031577_R_P self % alph ( 10 , 7 ) =- 0.333269719096256706589_R_P ; self % alph ( 10 , 8 ) = 0.499269229556880061353_R_P self % alph ( 11 , 7 ) = 0.239527360324390649107_R_P ; self % alph ( 11 , 8 ) = 0.397774662368094639047_R_P self % alph ( 12 , 7 ) =- 0.057695414616854888173_R_P ; self % alph ( 12 , 8 ) = 0.194781915712104164976_R_P self % alph ( 13 , 7 ) =- 0.861164195027635666673_R_P ; self % alph ( 13 , 8 ) = 5.784288136375372200229_R_P self % alph ( 14 , 7 ) = 0.398320112318533301719_R_P ; self % alph ( 14 , 8 ) = 3.639372631810356060294_R_P self % alph ( 15 , 7 ) =- 0.091089566215517606959_R_P ; self % alph ( 15 , 8 ) = 0._R_P self % alph ( 16 , 7 ) = 0._R_P ; self % alph ( 16 , 8 ) = 0._R_P self % alph ( 17 , 7 ) =- 1.045948959408833060950_R_P ; self % alph ( 17 , 8 ) = 0.930327845415626983292_R_P self % alph ( 10 , 9 ) = 0.509504608929686104236_R_P self % alph ( 11 , 9 ) = 0.010755895687360745555_R_P ; self % alph ( 11 , 10 ) =- 0.327769124164018874147_R_P self % alph ( 12 , 9 ) = 0.145384923188325069727_R_P ; self % alph ( 12 , 10 ) =- 0.078294271035167077755_R_P self % alph ( 13 , 9 ) = 3.288077619851035668904_R_P ; self % alph ( 13 , 10 ) =- 2.386339050931363840134_R_P self % alph ( 14 , 9 ) = 1.548228770398303223653_R_P ; self % alph ( 14 , 10 ) =- 2.122217147040537160260_R_P self % alph ( 15 , 9 ) = 0._R_P ; self % alph ( 15 , 10 ) = 0._R_P self % alph ( 16 , 9 ) = 0._R_P ; self % alph ( 16 , 10 ) = 0._R_P self % alph ( 17 , 9 ) = 1.779509594317081024461_R_P ; self % alph ( 17 , 10 ) = 0.1_R_P self % alph ( 12 , 11 ) =- 0.114503299361098912184_R_P self % alph ( 13 , 11 ) =- 3.254793424836439186545_R_P ; self % alph ( 13 , 12 ) =- 2.163435416864229823539_R_P self % alph ( 14 , 11 ) =- 1.583503985453261727133_R_P ; self % alph ( 14 , 12 ) =- 1.715616082859362649220_R_P self % alph ( 15 , 11 ) = 0._R_P ; self % alph ( 15 , 12 ) = 0._R_P self % alph ( 16 , 11 ) = 0._R_P ; self % alph ( 16 , 12 ) = 0._R_P self % alph ( 17 , 11 ) =- 0.282547569539044081612_R_P ; self % alph ( 17 , 12 ) =- 0.159327350119972549169_R_P self % alph ( 14 , 13 ) =- 0.024403640575012745213_R_P self % alph ( 15 , 13 ) = 0.091089566215517606959_R_P ; self % alph ( 15 , 14 ) = 0.777333643644968233538_R_P self % alph ( 16 , 13 ) = 0._R_P ; self % alph ( 16 , 14 ) = 0._R_P self % alph ( 17 , 13 ) =- 0.145515894647001510860_R_P ; self % alph ( 17 , 14 ) =- 0.259111214548322744512_R_P self % alph ( 16 , 15 ) = 0.157178665799771163367_R_P self % alph ( 17 , 15 ) =- 0.342758159847189839942_R_P ; self % alph ( 17 , 16 ) =- 0.675_R_P self % gamm ( 2 ) = 0.1_R_P self % gamm ( 3 ) = 0.539357840802981787532_R_P self % gamm ( 4 ) = 0.809036761204472681298_R_P self % gamm ( 5 ) = 0.309036761204472681298_R_P self % gamm ( 6 ) = 0.981074190219795268254_R_P self % gamm ( 7 ) = 0.833333333333333333333_R_P self % gamm ( 8 ) = 0.354017365856802376329_R_P self % gamm ( 9 ) = 0.882527661964732346425_R_P self % gamm ( 10 ) = 0.642615758240322548157_R_P self % gamm ( 11 ) = 0.357384241759677451842_R_P self % gamm ( 12 ) = 0.117472338035267653574_R_P self % gamm ( 13 ) = 0.833333333333333333333_R_P self % gamm ( 14 ) = 0.309036761204472681298_R_P self % gamm ( 15 ) = 0.539357840802981787532_R_P self % gamm ( 16 ) = 0.1_R_P self % gamm ( 17 ) = 1._R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~8.html","title":"init – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % tolerance = 0._R_P self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~6.html","title":"destroy – Shu-Osher-shock-tube-problem"},{"text":"private subroutine integrate(self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(inout) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit embedded Runge-Kutta scheme. The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. Note This method can be used after the integrator is created (i.e. the RK coefficients are initialized). Variables Type Visibility Attributes Name Initial class( integrand ), public, allocatable :: U1 First U evaluation. class( integrand ), public, allocatable :: U2 Second U evaluation. real(kind=R_P), public :: error Local truncation error estimation. integer(kind=I_P), public :: s First stages counter. integer(kind=I_P), public :: ss Second stages counter. Source Code subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit embedded Runge-Kutta scheme. !< !< The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( INOUT ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: U1 !< First U evaluation. class ( integrand ), allocatable :: U2 !< Second U evaluation. real ( R_P ) :: error !< Local truncation error estimation. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( U1 , source = U ) allocate ( U2 , source = U ) error = 1 e6 do while ( error > self % tolerance ) ! compute stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! compute new time step U1 = U U2 = U do s = 1 , self % stages U1 = U1 + stage ( s ) * ( Dt * self % beta ( s , 1 )) U2 = U2 + stage ( s ) * ( Dt * self % beta ( s , 2 )) enddo error = U2 . lterror . U1 call self % new_Dt ( error = error , Dt = Dt ) enddo U = U1 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~7.html","title":"integrate – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine new_Dt(self, error, Dt) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Integrator. real(kind=R_P), intent(in) :: error Local truncation error estimation. real(kind=R_P), intent(inout) :: Dt Time step. Description Compute new estimation of the time step Dt. The formula employed is:  Dt_{new} = 0.9 Dt_{old} \\left( \\frac{tolerance}{error} \\right)&#94;{\\frac{1}{p+1}}  Note 0.9 is a safety factor. Source Code elemental subroutine new_Dt ( self , error , Dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute new estimation of the time step Dt. !< !< The formula employed is: !< !<  Dt_{new} = 0.9 Dt_{old} \\left( \\frac{tolerance}{error} \\right)&#94;{\\frac{1}{p+1}}  !< !< @note 0.9 is a safety factor. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( IN ) :: self !< Integrator. real ( R_P ), intent ( IN ) :: error !< Local truncation error estimation. real ( R_P ), intent ( INOUT ) :: Dt !< Time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( error > self % tolerance ) Dt = 0.9_R_P * Dt * ( self % tolerance / error ) ** self % pp1_inv return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine new_Dt","tags":"","loc":"proc/new_dt.html","title":"new_Dt – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~6.html","title":"finalize – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine init(self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth-Moulton integrator: initialize the b coefficients. Source Code elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth-Moulton integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps call self % predictor % init ( steps = steps ) call self % corrector % init ( steps = steps - 1 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~9.html","title":"init – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. Description Destroy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = - 1 call self % predictor % destroy call self % corrector % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~7.html","title":"destroy – Shu-Osher-shock-tube-problem"},{"text":"private subroutine integrate(self, U, previous, Dt, t, iterations) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(in) :: self Actual ABM integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations of AM scheme. Description Integrate field with Adams-Bashforth-Moulton class scheme. Source Code subroutine integrate ( self , U , previous , Dt , t , iterations ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth-Moulton class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( IN ) :: self !< Actual ABM integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations of AM scheme. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % predictor % integrate ( U = U , previous = previous , Dt = Dt , t = t , autoupdate = . false .) call self % corrector % integrate ( U = U , previous = previous ( 2 :), Dt = Dt , t = t , iterations = iterations , autoupdate = . false .) call self % predictor % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~8.html","title":"integrate – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~7.html","title":"finalize – Shu-Osher-shock-tube-problem"},{"text":"private subroutine create(constructor, interpolator) Arguments Type Intent Optional Attributes Name class( weno_constructor ), intent(in) :: constructor The concrete WENO constructor selected by client code. class( weno_interpolator ), intent(out), allocatable :: interpolator The concrete WENO interpolator. Description Create and return a concrete WENO interpolator object being an extension of the abstract weno_interpolator type. Source Code subroutine create ( constructor , interpolator ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create and return a concrete WENO interpolator object being an extension of the abstract *weno_interpolator* type. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_constructor ), intent ( IN ) :: constructor !< The concrete WENO constructor selected by client code. class ( weno_interpolator ), allocatable , intent ( OUT ) :: interpolator !< The concrete WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( constructor ) type is ( weno_constructor_upwind ) allocate ( weno_interpolator_upwind :: interpolator ) call interpolator % create ( constructor = constructor ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine create","tags":"","loc":"proc/create.html","title":"create – Shu-Osher-shock-tube-problem"},{"text":"private elementalfunction weno_constructor_upwind_init(S, eps) result(constructor) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: S Maximum stencils dimension. real(kind=R_P), intent(in), optional :: eps Parameter for avoiding divided by zero when computing smoothness indicators. Return Value type( weno_constructor_upwind ) WENO constructor. Description Create (initialize) the WENO interpolator. Note For this class of interpolators it is sufficient to provide the maximum number of stencils used (that is also the\n dimension, i.e. number of values, of each stencil). During the actual interpolation phase the client code can specify, for each\n intepolation a different number of stencil bounded by this maximum value. This is useful for coupling the interpolator with\n algorithm like the Recursive Order Reduction (ROR) strategy. Called By proc~~weno_constructor_upwind_init~~CalledByGraph proc~weno_constructor_upwind_init weno_constructor_upwind_init interface~weno_constructor_upwind weno_constructor_upwind interface~weno_constructor_upwind->proc~weno_constructor_upwind_init proc~init~2 init proc~init~2->interface~weno_constructor_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function weno_constructor_upwind_init ( S , eps ) result ( constructor ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create (initialize) the WENO interpolator. !< !< @note For this class of interpolators it is sufficient to provide the maximum number of stencils used (that is also the !< dimension, i.e. number of values, of each stencil). During the actual interpolation phase the client code can specify, for each !< intepolation a different number of stencil bounded by this maximum value. This is useful for coupling the interpolator with !< algorithm like the Recursive Order Reduction (ROR) strategy. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: S !< Maximum stencils dimension. real ( R_P ), intent ( IN ), optional :: eps !< Parameter for avoiding divided by zero when computing smoothness indicators. type ( weno_constructor_upwind ) :: constructor !<WENO constructor. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- constructor % S = S if ( present ( eps )) constructor % eps = eps return !--------------------------------------------------------------------------------------------------------------------------------- endfunction weno_constructor_upwind_init","tags":"","loc":"proc/weno_constructor_upwind_init.html","title":"weno_constructor_upwind_init – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(inout) :: self WENO interpolator. Description Destoy the WENO interpolator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( INOUT ) :: self !< WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % S = 0_I_P self % eps = 0._R_P if ( allocated ( self % weights_opt )) deallocate ( self % weights_opt ) if ( allocated ( self % poly_coef )) deallocate ( self % poly_coef ) if ( allocated ( self % smooth_coef )) deallocate ( self % smooth_coef ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~8.html","title":"destroy – Shu-Osher-shock-tube-problem"},{"text":"private subroutine create(self, constructor) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(inout) :: self WENO interpolator. class( weno_constructor ), intent(in) :: constructor WENO constructor. Description Create the WENO interpolator. Calls proc~~create~2~~CallsGraph proc~create~2 create none~set_polynomial_coefficients set_polynomial_coefficients proc~create~2->none~set_polynomial_coefficients none~set_weights_optimal set_weights_optimal proc~create~2->none~set_weights_optimal none~set_smoothness_indicators_coefficients set_smoothness_indicators_coefficients proc~create~2->none~set_smoothness_indicators_coefficients coef coef none~set_polynomial_coefficients->coef none~set_smoothness_indicators_coefficients->coef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Subroutines subroutine set_weights_optimal() Arguments None Description Set the values of optimial weights. subroutine set_polynomial_coefficients() Arguments None Description Set the values of polynomial_coefficient. subroutine set_smoothness_indicators_coefficients() Arguments None Description Set the values of smoothness indicators coefficients. Source Code subroutine create ( self , constructor ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( INOUT ) :: self !< WENO interpolator. class ( weno_constructor ), intent ( IN ) :: constructor !< WENO constructor. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( constructor ) type is ( weno_constructor_upwind ) call self % destroy self % S = constructor % S self % eps = constructor % eps allocate ( self % weights_opt ( 1 : 2 , 0 : self % S - 1 )) allocate ( self % poly_coef ( 1 : 2 , 0 : self % S - 1 , 0 : self % S - 1 )) allocate ( self % smooth_coef ( 0 : self % S - 1 , 0 : self % S - 1 , 0 : self % S - 1 )) call set_weights_optimal call set_polynomial_coefficients call set_smoothness_indicators_coefficients endselect return !--------------------------------------------------------------------------------------------------------------------------------- contains subroutine set_weights_optimal () !------------------------------------------------------------------------------------------------------------------------------- !< Set the values of optimial weights. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- select case ( self % S ) case ( 2 ) ! 3rd order ! 1 => left interface (i-1/2) self % weights_opt ( 1 , 0 ) = 2._R_P / 3._R_P ! stencil 0 self % weights_opt ( 1 , 1 ) = 1._R_P / 3._R_P ! stencil 1 ! 2 => right interface (i+1/2) self % weights_opt ( 2 , 0 ) = 1._R_P / 3._R_P ! stencil 0 self % weights_opt ( 2 , 1 ) = 2._R_P / 3._R_P ! stencil 1 case ( 3 ) ! 5th order ! 1 => left interface (i-1/2) self % weights_opt ( 1 , 0 ) = 0.3_R_P ! stencil 0 self % weights_opt ( 1 , 1 ) = 0.6_R_P ! stencil 1 self % weights_opt ( 1 , 2 ) = 0.1_R_P ! stencil 2 ! 2 => right interface (i+1/2) self % weights_opt ( 2 , 0 ) = 0.1_R_P ! stencil 0 self % weights_opt ( 2 , 1 ) = 0.6_R_P ! stencil 1 self % weights_opt ( 2 , 2 ) = 0.3_R_P ! stencil 2 case ( 4 ) ! 7th order ! 1 => left interface (i-1/2) self % weights_opt ( 1 , 0 ) = 4._R_P / 3 5._R_P ! stencil 0 self % weights_opt ( 1 , 1 ) = 1 8._R_P / 3 5._R_P ! stencil 1 self % weights_opt ( 1 , 2 ) = 1 2._R_P / 3 5._R_P ! stencil 2 self % weights_opt ( 1 , 3 ) = 1._R_P / 3 5._R_P ! stencil 3 ! 2 => right interface (i+1/2) self % weights_opt ( 2 , 0 ) = 1._R_P / 3 5._R_P ! stencil 0 self % weights_opt ( 2 , 1 ) = 1 2._R_P / 3 5._R_P ! stencil 1 self % weights_opt ( 2 , 2 ) = 1 8._R_P / 3 5._R_P ! stencil 2 self % weights_opt ( 2 , 3 ) = 4._R_P / 3 5._R_P ! stencil 3 endselect return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_weights_optimal subroutine set_polynomial_coefficients () !------------------------------------------------------------------------------------------------------------------------------- !< Set the values of polynomial_coefficient. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- associate ( coef => self % poly_coef ) select case ( self % S ) case ( 2 ) ! 3rd order ! 1 => left interface (i-1/2) !  cell  0               ;    cell  1 coef ( 1 , 0 , 0 ) = 0.5_R_P ; coef ( 1 , 1 , 0 ) = 0.5_R_P ! stencil 0 coef ( 1 , 0 , 1 ) = - 0.5_R_P ; coef ( 1 , 1 , 1 ) = 1.5_R_P ! stencil 1 ! 2 => right interface (i+1/2) !  cell  0               ;    cell  1 coef ( 2 , 0 , 0 ) = 1.5_R_P ; coef ( 2 , 1 , 0 ) = - 0.5_R_P ! stencil 0 coef ( 2 , 0 , 1 ) = 0.5_R_P ; coef ( 2 , 1 , 1 ) = 0.5_R_P ! stencil 1 case ( 3 ) ! 5th order ! 1 => left interface (i-1/2) !  cell  0                     ;    cell  1                     ;    cell  2 coef ( 1 , 0 , 0 ) = 1._R_P / 3._R_P ; coef ( 1 , 1 , 0 ) = 5._R_P / 6._R_P ; coef ( 1 , 2 , 0 ) = - 1._R_P / 6._R_P ! stencil 0 coef ( 1 , 0 , 1 ) = - 1._R_P / 6._R_P ; coef ( 1 , 1 , 1 ) = 5._R_P / 6._R_P ; coef ( 1 , 2 , 1 ) = 1._R_P / 3._R_P ! stencil 1 coef ( 1 , 0 , 2 ) = 1._R_P / 3._R_P ; coef ( 1 , 1 , 2 ) = - 7._R_P / 6._R_P ; coef ( 1 , 2 , 2 ) = 1 1._R_P / 6._R_P ! stencil 2 ! 2 => right interface (i+1/2) !  cell  0                     ;    cell  1                     ;    cell  2 coef ( 2 , 0 , 0 ) = 1 1._R_P / 6._R_P ; coef ( 2 , 1 , 0 ) = - 7._R_P / 6._R_P ; coef ( 2 , 2 , 0 ) = 1._R_P / 3._R_P ! stencil 0 coef ( 2 , 0 , 1 ) = 1._R_P / 3._R_P ; coef ( 2 , 1 , 1 ) = 5._R_P / 6._R_P ; coef ( 2 , 2 , 1 ) = - 1._R_P / 6._R_P ! stencil 1 coef ( 2 , 0 , 2 ) = - 1._R_P / 6._R_P ; coef ( 2 , 1 , 2 ) = 5._R_P / 6._R_P ; coef ( 2 , 2 , 2 ) = 1._R_P / 3._R_P ! stencil 2 case ( 4 ) ! 7th order ! 1 => left interface (i-1/2) !  cell  0                 ;   cell  1                 ;   cell  2                  ;   cell  3 coef ( 1 , 0 , 0 ) = 1._R_P / 4._R_P ; coef ( 1 , 1 , 0 ) = 1 3._R_P / 1 2._R_P ; coef ( 1 , 2 , 0 ) = - 5._R_P / 1 2._R_P ; coef ( 1 , 3 , 0 ) = 1._R_P / 1 2._R_P ! sten 0 coef ( 1 , 0 , 1 ) =- 1._R_P / 1 2._R_P ; coef ( 1 , 1 , 1 ) = 7._R_P / 1 2._R_P ; coef ( 1 , 2 , 1 ) = 7._R_P / 1 2._R_P ; coef ( 1 , 3 , 1 ) =- 1._R_P / 1 2._R_P ! sten 1 coef ( 1 , 0 , 2 ) = 1._R_P / 1 2._R_P ; coef ( 1 , 1 , 2 ) =- 5._R_P / 1 2._R_P ; coef ( 1 , 2 , 2 ) = 1 3._R_P / 1 2._R_P ; coef ( 1 , 3 , 2 ) = 1._R_P / 4._R_P ! sten 2 coef ( 1 , 0 , 3 ) =- 1._R_P / 4._R_P ; coef ( 1 , 1 , 3 ) = 1 3._R_P / 1 2._R_P ; coef ( 1 , 2 , 3 ) =- 2 3._R_P / 1 2._R_P ; coef ( 1 , 3 , 3 ) = 2 5._R_P / 1 2._R_P ! sten 3 ! 2 => right interface (i+1/2) !  cell  0                 ;   cell  1                  ;   cell  2                 ;   cell  3 coef ( 2 , 0 , 0 ) = 2 5._R_P / 1 2._R_P ; coef ( 2 , 1 , 0 ) =- 2 3._R_P / 1 2._R_P ; coef ( 2 , 2 , 0 ) = 1 3._R_P / 1 2._R_P ; coef ( 2 , 3 , 0 ) =- 1._R_P / 4._R_P ! sten 0 coef ( 2 , 0 , 1 ) = 1._R_P / 4._R_P ; coef ( 2 , 1 , 1 ) = 1 3._R_P / 1 2._R_P ; coef ( 2 , 2 , 1 ) =- 5._R_P / 1 2._R_P ; coef ( 2 , 3 , 1 ) = 1._R_P / 1 2._R_P ! sten 1 coef ( 2 , 0 , 2 ) =- 1._R_P / 1 2._R_P ; coef ( 2 , 1 , 2 ) = 7._R_P / 1 2._R_P ; coef ( 2 , 2 , 2 ) = 7._R_P / 1 2._R_P ; coef ( 2 , 3 , 2 ) =- 1._R_P / 1 2._R_P ! sten 2 coef ( 2 , 0 , 3 ) = 1._R_P / 1 2._R_P ; coef ( 2 , 1 , 3 ) = - 5._R_P / 1 2._R_P ; coef ( 2 , 2 , 3 ) = 1 3._R_P / 1 2._R_P ; coef ( 2 , 3 , 3 ) = 1._R_P / 4._R_P ! sten 3 endselect endassociate return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_polynomial_coefficients subroutine set_smoothness_indicators_coefficients () !------------------------------------------------------------------------------------------------------------------------------- !< Set the values of smoothness indicators coefficients. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- associate ( coef => self % smooth_coef ) select case ( self % S ) case ( 2 ) ! 3rd order ! stencil 0 !      i*i             ;       (i-1)*i coef ( 0 , 0 , 0 ) = 1._R_P ; coef ( 1 , 0 , 0 ) = - 2._R_P !      /               ;       (i-1)*(i-1) coef ( 0 , 1 , 0 ) = 0._R_P ; coef ( 1 , 1 , 0 ) = 1._R_P ! stencil 1 !     (i+1)*(i+1)      ;       (i+1)*i coef ( 0 , 0 , 1 ) = 1._R_P ; coef ( 1 , 0 , 1 ) = - 2._R_P !      /               ;        i*i coef ( 0 , 1 , 1 ) = 0._R_P ; coef ( 1 , 1 , 1 ) = 1._R_P case ( 3 ) ! 5th order ! stencil 0 !      i*i                      ;       (i-1)*i                   ;       (i-2)*i coef ( 0 , 0 , 0 ) = 1 0._R_P / 3._R_P ; coef ( 1 , 0 , 0 ) = - 3 1._R_P / 3._R_P ; coef ( 2 , 0 , 0 ) = 1 1._R_P / 3._R_P !      /                        ;       (i-1)*(i-1)               ;       (i-2)*(i-1) coef ( 0 , 1 , 0 ) = 0._R_P ; coef ( 1 , 1 , 0 ) = 2 5._R_P / 3._R_P ; coef ( 2 , 1 , 0 ) = - 1 9._R_P / 3._R_P !      /                        ;        /                        ;       (i-2)*(i-2) coef ( 0 , 2 , 0 ) = 0._R_P ; coef ( 1 , 2 , 0 ) = 0._R_P ; coef ( 2 , 2 , 0 ) = 4._R_P / 3._R_P ! stencil 1 !     (i+1)*(i+1)               ;        i*(i+1)                  ;       (i-1)*(i+1) coef ( 0 , 0 , 1 ) = 4._R_P / 3._R_P ; coef ( 1 , 0 , 1 ) = - 1 3._R_P / 3._R_P ; coef ( 2 , 0 , 1 ) = 5._R_P / 3._R_P !      /                        ;        i*i                      ;       (i-1)*i coef ( 0 , 1 , 1 ) = 0._R_P ; coef ( 1 , 1 , 1 ) = 1 3._R_P / 3._R_P ; coef ( 2 , 1 , 1 ) = - 1 3._R_P / 3._R_P !      /                        ;        /                        ;       (i-1)*(i-1) coef ( 0 , 2 , 1 ) = 0._R_P ; coef ( 1 , 2 , 1 ) = 0._R_P ; coef ( 2 , 2 , 1 ) = 4._R_P / 3._R_P ! stencil 2 !     (i+2)*(i+2)               ;       (i+1)*(i+2)               ;        i*(i+2) coef ( 0 , 0 , 2 ) = 4._R_P / 3._R_P ; coef ( 1 , 0 , 2 ) = - 1 9._R_P / 3._R_P ; coef ( 2 , 0 , 2 ) = 1 1._R_P / 3._R_P !      /                        ;       (i+1)*(i+1)               ;        i*(i+1) coef ( 0 , 1 , 2 ) = 0._R_P ; coef ( 1 , 1 , 2 ) = 2 5._R_P / 3._R_P ; coef ( 2 , 1 , 2 ) = - 3 1._R_P / 3._R_P !      /                        ;        /                        ;        i*i coef ( 0 , 2 , 2 ) = 0._R_P ; coef ( 1 , 2 , 2 ) = 0._R_P ; coef ( 2 , 2 , 2 ) = 1 0._R_P / 3._R_P case ( 4 ) ! 7th order ! stencil 0 !      i*i                ;       (i-1)*i             ;       (i-2)*i              ;       (i-3)*i coef ( 0 , 0 , 0 ) = 210 7._R_P ; coef ( 1 , 0 , 0 ) =- 940 2._R_P ; coef ( 2 , 0 , 0 ) = 704 2._R_P ; coef ( 3 , 0 , 0 ) = - 185 4._R_P !      /                  ;       (i-1)*(i-1)         ;       (i-2)*(i-1)          ;       (i-3)*(i-1) coef ( 0 , 1 , 0 ) = 0._R_P ; coef ( 1 , 1 , 0 ) = 1100 3._R_P ; coef ( 2 , 1 , 0 ) =- 1724 6._R_P ; coef ( 3 , 1 , 0 ) = 464 2._R_P !      /                  ;        /                  ;       (i-2)*(i-2)          ;       (i-3)*(i-2) coef ( 0 , 2 , 0 ) = 0._R_P ; coef ( 1 , 2 , 0 ) = 0._R_P ; coef ( 2 , 2 , 0 ) = 704 3._R_P ; coef ( 3 , 2 , 0 ) = - 388 2._R_P !      /                  ;        /                  ;        /                   ;       (i-3)*(i-3) coef ( 0 , 3 , 0 ) = 0._R_P ; coef ( 1 , 3 , 0 ) = 0._R_P ; coef ( 2 , 3 , 0 ) = 0._R_P ; coef ( 3 , 3 , 0 ) = 54 7._R_P ! stencil 1 !     (i+1)*(i+1)         ;        i*(i+1)            ;       (i-1)*(i+1)          ;       (i-2)*(i+1) coef ( 0 , 0 , 1 ) = 54 7._R_P ; coef ( 1 , 0 , 1 ) =- 252 2._R_P ; coef ( 2 , 0 , 1 ) = 192 2._R_P ; coef ( 3 , 0 , 1 ) = - 49 4._R_P !       /                 ;          i*i              ;       (i-1)*i              ;       (i-2)*i coef ( 0 , 1 , 1 ) = 0._R_P ; coef ( 1 , 1 , 1 ) = 344 3._R_P ; coef ( 2 , 1 , 1 ) = - 596 6._R_P ; coef ( 3 , 1 , 1 ) = 160 2._R_P !       /                 ;          /                ;       (i-1)*(i-1)          ;       (i-2)*(i-1) coef ( 0 , 2 , 1 ) = 0._R_P ; coef ( 1 , 2 , 1 ) = 0._R_P ; coef ( 2 , 2 , 1 ) = 284 3._R_P ; coef ( 3 , 2 , 1 ) = - 164 2._R_P !       /                 ;          /                ;        /                   ;       (i-2)*(i-2) coef ( 0 , 3 , 1 ) = 0._R_P ; coef ( 1 , 3 , 1 ) = 0._R_P ; coef ( 2 , 3 , 1 ) = 0._R_P ; coef ( 3 , 3 , 1 ) = 26 7._R_P ! stencil 2 !     (i+2)*(i+2)         ;       (i+1)*(i+2)         ;            i*(i+2)         ;       (i-1)*(i+2) coef ( 0 , 0 , 2 ) = 26 7._R_P ; coef ( 1 , 0 , 2 ) =- 164 2._R_P ; coef ( 2 , 0 , 2 ) = 160 2._R_P ; coef ( 3 , 0 , 2 ) = - 49 4._R_P !      /                  ;       (i+1)*(i+1)         ;        i*(i+1)             ;       (i-1)*(i+1) coef ( 0 , 1 , 2 ) = 0._R_P ; coef ( 1 , 1 , 2 ) = 284 3._R_P ; coef ( 2 , 1 , 2 ) = - 596 6._R_P ; coef ( 3 , 1 , 2 ) = 192 2._R_P !      /                  ;        /                  ;        i*i                 ;       (i-1)*i coef ( 0 , 2 , 2 ) = 0._R_P ; coef ( 1 , 2 , 2 ) = 0._R_P ; coef ( 2 , 2 , 2 ) = 344 3._R_P ; coef ( 3 , 2 , 2 ) = - 252 2._R_P !      /                  ;        /                  ;        /                   ;       (i-1)*(i-1) coef ( 0 , 3 , 2 ) = 0._R_P ; coef ( 1 , 3 , 2 ) = 0._R_P ; coef ( 2 , 3 , 2 ) = 0._R_P ; coef ( 3 , 3 , 2 ) = 54 7._R_P ! stencil 3 !     (i+3)*(i+3)         ;       (i+2)*(i+3)         ;           (i+1)*(i+3)      ;        i*(i+3) coef ( 0 , 0 , 3 ) = 54 7._R_P ; coef ( 1 , 0 , 3 ) =- 388 2._R_P ; coef ( 2 , 0 , 3 ) = 464 2._R_P ; coef ( 3 , 0 , 3 ) = - 185 4._R_P !      /                  ;       (i+2)*(i+2)         ;       (i+1)*(i+2)          ;        i*(i+2) coef ( 0 , 1 , 3 ) = 0._R_P ; coef ( 1 , 1 , 3 ) = 704 3._R_P ; coef ( 2 , 1 , 3 ) =- 1724 6._R_P ; coef ( 3 , 1 , 3 ) = 704 2._R_P !      /                  ;        /                  ;       (i+1)*(i+1)          ;        i*(i+1) coef ( 0 , 2 , 3 ) = 0._R_P ; coef ( 1 , 2 , 3 ) = 0._R_P ; coef ( 2 , 2 , 3 ) = 1100 3._R_P ; coef ( 3 , 2 , 3 ) = - 940 2._R_P !      /                  ;        /                  ;        /                   ;        i*i coef ( 0 , 3 , 3 ) = 0._R_P ; coef ( 1 , 3 , 3 ) = 0._R_P ; coef ( 2 , 3 , 3 ) = 0._R_P ; coef ( 3 , 3 , 3 ) = 210 7._R_P endselect endassociate return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_smoothness_indicators_coefficients endsubroutine create","tags":"","loc":"proc/create~2.html","title":"create – Shu-Osher-shock-tube-problem"},{"text":"private puresubroutine description(self, string) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(in) :: self WENO interpolator. character(len=:), intent(out), allocatable :: string String returned. Description Return a string describing the WENO interpolator. Variables Type Visibility Attributes Name Initial character(len=23), public :: dummy Dummy string. character(len=1), public, parameter :: nl = new_line('a') New line character. Source Code pure subroutine description ( self , string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string describing the WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( IN ) :: self !< WENO interpolator. character ( len = :), allocatable , intent ( OUT ) :: string !< String returned. character ( len = 23 ) :: dummy !< Dummy string. character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !< New line character. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- string = 'WENO upwind-biased interpolator' // nl string = string // '  Based on the scheme proposed by Jiang and Shu \"Efficient Implementation of Weighted ENO Schemes\", see ' // & 'JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130' // nl write ( dummy , \"(I15)\" ) 2 * self % S - 1 string = string // '  Provide a formal order of accuracy equals to: ' // trim ( adjustl ( dummy )) // nl write ( dummy , \"(I15)\" ) self % S string = string // '  Use ' // trim ( adjustl ( dummy )) // ' stencils composed by ' // trim ( adjustl ( dummy )) // ' values' // nl write ( dummy , \"(E23.15)\" ) self % eps string = string // '  The eps value used for avoiding division by zero is ' // trim ( adjustl ( dummy )) // nl string = string // '  The \"interpolate\" method has the following public API' // nl string = string // '    interpolate(S, stencil, location, interpolation)' // nl string = string // '  where:' // nl string = string // '    S: integer(I_P), intent(IN), the number of stencils actually used' // nl string = string // '    stencil(1:, 1-S:-1+S): real(R_P), intent(IN), the stencils used' // nl string = string // '    location: character(*), intent(IN), the location of interpolation {left, right, both}' // nl string = string // '    interpolation(1:, 1-S:-1+S): realR_P, intent(OUT), the interpolated values' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine description","tags":"","loc":"proc/description.html","title":"description – Shu-Osher-shock-tube-problem"},{"text":"private puresubroutine interpolate(self, S, stencil, location, interpolation) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(in) :: self WENO interpolator. integer, intent(in) :: S Number of stencils actually used. real(kind=R_P), intent(in) :: stencil (1:,1-S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. character(len=*), intent(in) :: location Location of interpolated value(s): left, right, both. real(kind=R_P), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Description Interpolate the stecil input values computing the actual interpolation. Calls proc~~interpolate~~CallsGraph proc~interpolate interpolate none~compute_convolution compute_convolution proc~interpolate->none~compute_convolution none~compute_polynomials compute_polynomials proc~interpolate->none~compute_polynomials none~compute_weights compute_weights proc~interpolate->none~compute_weights stencil stencil none~compute_polynomials->stencil none~compute_weights->stencil Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: polynomials (1:2,0:S-1) Polynomial reconstructions. real(kind=R_P), public :: weights (1:2,0:S-1) Weights of the stencils. Subroutines puresubroutine compute_polynomials(f1, f2, ff, polynomials) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: f1 integer(kind=I_P), intent(in) :: f2 integer(kind=I_P), intent(in) :: ff Faces to be computed. real(kind=R_P), intent(out) :: polynomials (1:,0:) Polynomial reconstructions. Description Compute the polynomials reconstructions. puresubroutine compute_weights(f1, f2, ff, weights) Arguments Type Intent Optional Attributes Name integer, intent(in) :: f1 integer, intent(in) :: f2 integer, intent(in) :: ff Faces to be computed. real(kind=R_P), intent(out) :: weights (1:,0:) Weights of the stencils, [1:2, 0:S - 1 ]. Description Compute the stencils weights. puresubroutine compute_convolution(f1, f2, ff, interpolation) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: f1 integer(kind=I_P), intent(in) :: f2 integer(kind=I_P), intent(in) :: ff Faces to be computed. real(kind=R_P), intent(out) :: interpolation (1:) Left and right (1,2) interface value of reconstructed. Description Compute the polynomials convolution. Source Code pure subroutine interpolate ( self , S , stencil , location , interpolation ) !--------------------------------------------------------------------------------------------------------------------------------- !< Interpolate the stecil input values computing the actual interpolation. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( IN ) :: self !< WENO interpolator. integer , intent ( IN ) :: S !< Number of stencils actually used. real ( R_P ), intent ( IN ) :: stencil ( 1 :, 1 - S :) !< Stencil used for the interpolation, [1:2, 1-S:-1+S]. character ( * ), intent ( IN ) :: location !< Location of interpolated value(s): left, right, both. real ( R_P ), intent ( OUT ) :: interpolation ( 1 :) !< Result of the interpolation, [1:2]. real ( R_P ) :: polynomials ( 1 : 2 , 0 : S - 1 ) !< Polynomial reconstructions. real ( R_P ) :: weights ( 1 : 2 , 0 : S - 1 ) !< Weights of the stencils. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( location ) case ( 'both' , 'b' ) call compute_polynomials ( f1 = 1_I_P , f2 = 2_I_P , ff = 0_I_P , polynomials = polynomials ) call compute_weights ( f1 = 1_I_P , f2 = 2_I_P , ff = 0_I_P , weights = weights ) call compute_convolution ( f1 = 1_I_P , f2 = 2_I_P , ff = 0_I_P , interpolation = interpolation ) case ( 'left' , 'l' ) call compute_polynomials ( f1 = 1_I_P , f2 = 1_I_P , ff = 0_I_P , polynomials = polynomials ) call compute_weights ( f1 = 1_I_P , f2 = 1_I_P , ff = 0_I_P , weights = weights ) call compute_convolution ( f1 = 1_I_P , f2 = 1_I_P , ff = 0_I_P , interpolation = interpolation ) case ( 'right' , 'r' ) call compute_polynomials ( f1 = 2_I_P , f2 = 2_I_P , ff =- 1_I_P , polynomials = polynomials ) call compute_weights ( f1 = 2_I_P , f2 = 2_I_P , ff =- 1_I_P , weights = weights ) call compute_convolution ( f1 = 2_I_P , f2 = 2_I_P , ff =- 1_I_P , interpolation = interpolation ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- contains pure subroutine compute_polynomials ( f1 , f2 , ff , polynomials ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute the polynomials reconstructions. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: f1 , f2 , ff !< Faces to be computed. real ( R_P ), intent ( OUT ) :: polynomials ( 1 :, 0 :) !< Polynomial reconstructions. integer ( I_P ) :: s1 , s2 , f !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- polynomials = 0. do s1 = 0 , S - 1 ! stencils loop do s2 = 0 , S - 1 ! values loop do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) polynomials ( f , s1 ) = polynomials ( f , s1 ) + self % poly_coef ( f , s2 , s1 ) * stencil ( f + ff , - s2 + s1 ) enddo enddo enddo return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine compute_polynomials pure subroutine compute_weights ( f1 , f2 , ff , weights ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute the stencils weights. !------------------------------------------------------------------------------------------------------------------------------- integer , intent ( IN ) :: f1 , f2 , ff !< Faces to be computed. real ( R_P ), intent ( OUT ) :: weights ( 1 :, 0 :) !< Weights of the stencils, [1:2, 0:S - 1 ]. real ( R_P ) :: IS ( 1 : 2 , 0 : S - 1 ) !< Smoothness indicators of the stencils. real ( R_P ) :: a ( 1 : 2 , 0 : S - 1 ) !< Alpha coefficients for the weights. real ( R_P ) :: a_tot ( 1 : 2 ) !< Sum of the alpha coefficients. integer ( I_P ) :: s1 , s2 , s3 , f !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- ! computing smoothness indicators do s1 = 0 , S - 1 ! stencils loop do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) IS ( f , s1 ) = 0. do s2 = 0 , S - 1 do s3 = 0 , S - 1 IS ( f , s1 ) = IS ( f , s1 ) + self % smooth_coef ( s3 , s2 , s1 ) * stencil ( f + ff , s1 - s3 ) * stencil ( f + ff , s1 - s2 ) enddo enddo enddo enddo ! computing alfa coefficients a_tot = 0. do s1 = 0 , S - 1 ! stencil loops do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) a ( f , s1 ) = self % weights_opt ( f , s1 ) * ( 1. / ( self % eps + IS ( f , s1 )) ** S ) ; a_tot ( f ) = a_tot ( f ) + a ( f , s1 ) enddo enddo ! computing the weights do s1 = 0 , S - 1 ! stencils loop do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) weights ( f , s1 ) = a ( f , s1 ) / a_tot ( f ) enddo enddo return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine compute_weights pure subroutine compute_convolution ( f1 , f2 , ff , interpolation ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute the polynomials convolution. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: f1 , f2 , ff !< Faces to be computed. real ( R_P ), intent ( OUT ) :: interpolation ( 1 :) !< Left and right (1,2) interface value of reconstructed. integer ( I_P ) :: k , f !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- ! computing the convultion interpolation = 0. do k = 0 , S - 1 ! stencils loop do f = f1 , f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) interpolation ( f + ff ) = interpolation ( f + ff ) + weights ( f , k ) * polynomials ( f , k ) enddo enddo return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine compute_convolution endsubroutine interpolate","tags":"","loc":"proc/interpolate.html","title":"interpolate – Shu-Osher-shock-tube-problem"},{"text":"private puresubroutine assign_interpolator(lhs, rhs) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(inout) :: lhs Left hand side. class( weno_interpolator ), intent(in) :: rhs Right hand side. Description Assign one interpolator to another. Source Code pure subroutine assign_interpolator ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one interpolator to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( weno_interpolator_upwind ), intent ( INOUT ) :: lhs !< Left hand side. class ( weno_interpolator ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( weno_interpolator_upwind ) lhs % S = rhs % S lhs % eps = rhs % eps if ( allocated ( rhs % weights_opt )) lhs % weights_opt = rhs % weights_opt if ( allocated ( rhs % poly_coef )) lhs % poly_coef = rhs % poly_coef if ( allocated ( rhs % smooth_coef )) lhs % smooth_coef = rhs % smooth_coef endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_interpolator","tags":"","loc":"proc/assign_interpolator.html","title":"assign_interpolator – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( weno_interpolator_upwind ), intent(inout) :: self WENO interpolator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( weno_interpolator_upwind ), intent ( INOUT ) :: self !< WENO interpolator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~8.html","title":"finalize – Shu-Osher-shock-tube-problem"},{"text":"public interface weno_constructor_upwind Calls interface~~weno_constructor_upwind~~CallsGraph interface~weno_constructor_upwind weno_constructor_upwind proc~weno_constructor_upwind_init weno_constructor_upwind_init interface~weno_constructor_upwind->proc~weno_constructor_upwind_init Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~weno_constructor_upwind~~CalledByGraph interface~weno_constructor_upwind weno_constructor_upwind proc~init~2 init proc~init~2->interface~weno_constructor_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elementalfunction weno_constructor_upwind_init (S, eps) result(constructor) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: S Maximum stencils dimension. real(kind=R_P), intent(in), optional :: eps Parameter for avoiding divided by zero when computing smoothness indicators. Return Value type( weno_constructor_upwind ) WENO constructor. Description Create (initialize) the WENO interpolator.","tags":"","loc":"interface/weno_constructor_upwind.html","title":"weno_constructor_upwind – Shu-Osher-shock-tube-problem"},{"text":"private subroutine destroy(me) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me Source Code subroutine destroy ( me ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler if ( allocated ( me % str )) deallocate ( me % str ) end subroutine destroy","tags":"","loc":"proc/destroy~9.html","title":"destroy – Shu-Osher-shock-tube-problem"},{"text":"private subroutine add_str(me, str) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in) :: str Source Code subroutine add_str ( me , str ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler character ( len =* ), intent ( in ) :: str !! str to be added to pyplot handler buffer me % str = me % str // str // new_line ( ' ' ) end subroutine add_str","tags":"","loc":"proc/add_str.html","title":"add_str – Shu-Osher-shock-tube-problem"},{"text":"private subroutine initialize(me, grid, xlabel, ylabel, zlabel, title, legend, use_numpy, figsize, font_size, axes_labelsize, xtick_labelsize, ytick_labelsize, ztick_labelsize, legend_fontsize, mplot3d) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me logical, intent(in), optional :: grid character(len=*), intent(in), optional :: xlabel character(len=*), intent(in), optional :: ylabel character(len=*), intent(in), optional :: zlabel character(len=*), intent(in), optional :: title logical, intent(in), optional :: legend logical, intent(in), optional :: use_numpy integer, intent(in), optional dimension(2) :: figsize integer, intent(in), optional :: font_size integer, intent(in), optional :: axes_labelsize integer, intent(in), optional :: xtick_labelsize integer, intent(in), optional :: ytick_labelsize integer, intent(in), optional :: ztick_labelsize integer, intent(in), optional :: legend_fontsize logical, intent(in), optional :: mplot3d Calls proc~~initialize~~CallsGraph proc~initialize initialize proc~optional_int_to_string optional_int_to_string proc~initialize->proc~optional_int_to_string proc~integer_to_string integer_to_string proc~initialize->proc~integer_to_string proc~optional_int_to_string->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=max_int_len), public :: width_str character(len=max_int_len), public :: height_str character(len=max_int_len), public :: font_size_str character(len=max_int_len), public :: axes_labelsize_str character(len=max_int_len), public :: xtick_labelsize_str character(len=max_int_len), public :: ytick_labelsize_str character(len=max_int_len), public :: ztick_labelsize_str character(len=max_int_len), public :: legend_fontsize_str character(len=*), public, parameter :: default_font_size_str = '10' Source Code subroutine initialize ( me , grid , xlabel , ylabel , zlabel , title , legend , use_numpy , figsize , & font_size , axes_labelsize , xtick_labelsize , ytick_labelsize , ztick_labelsize , & legend_fontsize , mplot3d ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler logical , intent ( in ), optional :: grid !! activate grid drawing character ( len =* ), intent ( in ), optional :: xlabel !! label of x axis character ( len =* ), intent ( in ), optional :: ylabel !! label of y axis character ( len =* ), intent ( in ), optional :: zlabel !! label of z axis character ( len =* ), intent ( in ), optional :: title !! plot title logical , intent ( in ), optional :: legend !! plot legend logical , intent ( in ), optional :: use_numpy !! activate usage of numpy python module integer , dimension ( 2 ), intent ( in ), optional :: figsize !! dimension of the figure integer , intent ( in ), optional :: font_size !! font size integer , intent ( in ), optional :: axes_labelsize !! size of axis labels integer , intent ( in ), optional :: xtick_labelsize !! size of x axis tick lables integer , intent ( in ), optional :: ytick_labelsize !! size of y axis tick lables integer , intent ( in ), optional :: ztick_labelsize !! size of z axis tick lables integer , intent ( in ), optional :: legend_fontsize !! size of legend font logical , intent ( in ), optional :: mplot3d !! set true for 3d plots character ( len = max_int_len ) :: width_str !! figure width dummy string character ( len = max_int_len ) :: height_str !! figure height dummy string character ( len = max_int_len ) :: font_size_str !! font size dummy string character ( len = max_int_len ) :: axes_labelsize_str !! size of axis labels dummy string character ( len = max_int_len ) :: xtick_labelsize_str !! size of x axis tick labels dummy string character ( len = max_int_len ) :: ytick_labelsize_str !! size of x axis tick labels dummy string character ( len = max_int_len ) :: ztick_labelsize_str !! size of z axis tick labels dummy string character ( len = max_int_len ) :: legend_fontsize_str !! size of legend font dummy string character ( len =* ), parameter :: default_font_size_str = '10' !! the default font size for plots call me % destroy () if ( present ( legend )) then me % show_legend = legend else me % show_legend = . false . end if if ( present ( use_numpy )) then me % use_numpy = use_numpy else me % use_numpy = . true . end if if ( present ( figsize )) then call integer_to_string ( figsize ( 1 ), width_str ) call integer_to_string ( figsize ( 2 ), height_str ) end if if ( present ( mplot3d )) then me % mplot3d = mplot3d else me % mplot3d = . false . end if call optional_int_to_string ( font_size , font_size_str , default_font_size_str ) call optional_int_to_string ( axes_labelsize , axes_labelsize_str , default_font_size_str ) call optional_int_to_string ( xtick_labelsize , xtick_labelsize_str , default_font_size_str ) call optional_int_to_string ( ytick_labelsize , ytick_labelsize_str , default_font_size_str ) call optional_int_to_string ( ztick_labelsize , ztick_labelsize_str , default_font_size_str ) call optional_int_to_string ( legend_fontsize , legend_fontsize_str , default_font_size_str ) me % str = '' call me % add_str ( '#!/usr/bin/python' ) call me % add_str ( '' ) call me % add_str ( 'import matplotlib' ) call me % add_str ( 'import matplotlib.pyplot as plt' ) if ( me % mplot3d ) call me % add_str ( 'from mpl_toolkits.mplot3d import Axes3D' ) if ( me % use_numpy ) call me % add_str ( 'import numpy as np' ) call me % add_str ( '' ) call me % add_str ( 'matplotlib.rcParams[\"font.family\"] = \"Serif\"' ) call me % add_str ( 'matplotlib.rcParams[\"font.size\"] = ' // trim ( font_size_str )) call me % add_str ( 'matplotlib.rcParams[\"axes.labelsize\"] = ' // trim ( axes_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"xtick.labelsize\"] = ' // trim ( xtick_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"ytick.labelsize\"] = ' // trim ( ytick_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"legend.fontsize\"] = ' // trim ( legend_fontsize_str )) call me % add_str ( '' ) if ( present ( figsize )) then !if specifying the figure size call me % add_str ( 'fig = plt.figure(figsize=(' // trim ( width_str ) // ',' // trim ( height_str ) // '))' ) else call me % add_str ( 'fig = plt.figure()' ) end if if ( me % mplot3d ) then call me % add_str ( 'ax = fig.gca(projection=''3d'')' ) else call me % add_str ( 'ax = fig.gca()' ) end if if ( present ( grid )) then if ( grid ) call me % add_str ( 'ax.grid()' ) end if if ( present ( xlabel )) call me % add_str ( 'ax.set_xlabel(\"' // trim ( xlabel ) // '\")' ) if ( present ( ylabel )) call me % add_str ( 'ax.set_ylabel(\"' // trim ( ylabel ) // '\")' ) if ( present ( zlabel )) call me % add_str ( 'ax.set_zlabel(\"' // trim ( zlabel ) // '\")' ) if ( present ( title )) call me % add_str ( 'ax.set_title(\"' // trim ( title ) // '\")' ) call me % add_str ( '' ) end subroutine initialize","tags":"","loc":"proc/initialize.html","title":"initialize – Shu-Osher-shock-tube-problem"},{"text":"private subroutine add_plot(me, x, y, label, linestyle, markersize, linewidth) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: markersize integer, intent(in), optional :: linewidth Calls proc~~add_plot~~CallsGraph proc~add_plot add_plot proc~vec_to_string vec_to_string proc~add_plot->proc~vec_to_string proc~optional_int_to_string optional_int_to_string proc~add_plot->proc~optional_int_to_string proc~integer_to_string integer_to_string proc~optional_int_to_string->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: xstr character(len=:), public, allocatable :: ystr character(len=max_int_len), public :: imark character(len=max_int_len), public :: iline character(len=*), public, parameter :: xname = 'x' character(len=*), public, parameter :: yname = 'y' Source Code subroutine add_plot ( me , x , y , label , linestyle , markersize , linewidth ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler real ( wp ), dimension (:), intent ( in ) :: x !! x values real ( wp ), dimension (:), intent ( in ) :: y !! y values character ( len =* ), intent ( in ) :: label !! plot label character ( len =* ), intent ( in ) :: linestyle !! style of the plot line integer , intent ( in ), optional :: markersize !! size of the plot markers integer , intent ( in ), optional :: linewidth !! width of the plot line character ( len = :), allocatable :: xstr !! x values strinfied character ( len = :), allocatable :: ystr !! y values strinfied character ( len = max_int_len ) :: imark !! actual markers size character ( len = max_int_len ) :: iline !! actual line width character ( len =* ), parameter :: xname = 'x' !! x variable name for script character ( len =* ), parameter :: yname = 'y' !! y variable name for script if ( allocated ( me % str )) then !convert the arrays to strings: call vec_to_string ( x , xstr , me % use_numpy ) call vec_to_string ( y , ystr , me % use_numpy ) !get optional inputs (if not present, set default value): call optional_int_to_string ( markersize , imark , '3' ) call optional_int_to_string ( linewidth , iline , '3' ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) call me % add_str ( '' ) !write the plot statement: call me % add_str ( 'ax.plot(' // & trim ( xname ) // ',' // & trim ( yname ) // ',' // & '\"' // trim ( linestyle ) // '\",' // & 'linewidth=' // trim ( adjustl ( iline )) // ',' // & 'markersize=' // trim ( adjustl ( imark )) // ',' // & 'label=\"' // trim ( label ) // '\")' ) call me % add_str ( '' ) else error stop 'Error in add_plot: pyplot class not properly initialized.' end if end subroutine add_plot","tags":"","loc":"proc/add_plot.html","title":"add_plot – Shu-Osher-shock-tube-problem"},{"text":"private subroutine add_3d_plot(me, x, y, z, label, linestyle, markersize, linewidth) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: markersize integer, intent(in), optional :: linewidth Calls proc~~add_3d_plot~~CallsGraph proc~add_3d_plot add_3d_plot proc~vec_to_string vec_to_string proc~add_3d_plot->proc~vec_to_string proc~optional_int_to_string optional_int_to_string proc~add_3d_plot->proc~optional_int_to_string proc~integer_to_string integer_to_string proc~optional_int_to_string->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: xstr character(len=:), public, allocatable :: ystr character(len=:), public, allocatable :: zstr character(len=max_int_len), public :: imark character(len=max_int_len), public :: iline character(len=*), public, parameter :: xname = 'x' character(len=*), public, parameter :: yname = 'y' character(len=*), public, parameter :: zname = 'z' Source Code subroutine add_3d_plot ( me , x , y , z , label , linestyle , markersize , linewidth ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler real ( wp ), dimension (:), intent ( in ) :: x !! x values real ( wp ), dimension (:), intent ( in ) :: y !! y values real ( wp ), dimension (:), intent ( in ) :: z !! z values character ( len =* ), intent ( in ) :: label !! plot label character ( len =* ), intent ( in ) :: linestyle !! style of the plot line integer , intent ( in ), optional :: markersize !! size of the plot markers integer , intent ( in ), optional :: linewidth !! width of the plot line character ( len = :), allocatable :: xstr !! x values strinfied character ( len = :), allocatable :: ystr !! y values strinfied character ( len = :), allocatable :: zstr !! z values strinfied character ( len = max_int_len ) :: imark !! actual markers size character ( len = max_int_len ) :: iline !! actual line width character ( len =* ), parameter :: xname = 'x' !! x variable name for script character ( len =* ), parameter :: yname = 'y' !! y variable name for script character ( len =* ), parameter :: zname = 'z' !! z variable name for script if ( allocated ( me % str )) then !convert the arrays to strings: call vec_to_string ( x , xstr , me % use_numpy ) call vec_to_string ( y , ystr , me % use_numpy ) call vec_to_string ( z , zstr , me % use_numpy ) !get optional inputs (if not present, set default value): call optional_int_to_string ( markersize , imark , '3' ) call optional_int_to_string ( linewidth , iline , '3' ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) call me % add_str ( trim ( zname ) // ' = ' // zstr ) call me % add_str ( '' ) !write the plot statement: call me % add_str ( 'ax.plot(' // & trim ( xname ) // ',' // & trim ( yname ) // ',' // & trim ( zname ) // ',' // & '\"' // trim ( linestyle ) // '\",' // & 'linewidth=' // trim ( adjustl ( iline )) // ',' // & 'markersize=' // trim ( adjustl ( imark )) // ',' // & 'label=\"' // trim ( label ) // '\")' ) call me % add_str ( '' ) else error stop 'Error in add_3d_plot: pyplot class not properly initialized.' end if end subroutine add_3d_plot","tags":"","loc":"proc/add_3d_plot.html","title":"add_3d_plot – Shu-Osher-shock-tube-problem"},{"text":"private subroutine add_bar(me, left, height, label, width, bottom, color) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: left real(kind=wp), intent(in), dimension(:) :: height character(len=*), intent(in) :: label real(kind=wp), intent(in), optional dimension(:) :: width real(kind=wp), intent(in), optional dimension(:) :: bottom character(len=*), intent(in), optional :: color Calls proc~~add_bar~~CallsGraph proc~add_bar add_bar proc~vec_to_string vec_to_string proc~add_bar->proc~vec_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: xstr character(len=:), public, allocatable :: ystr character(len=:), public, allocatable :: wstr character(len=:), public, allocatable :: bstr character(len=:), public, allocatable :: plt_str character(len=*), public, parameter :: xname = 'x' character(len=*), public, parameter :: yname = 'y' character(len=*), public, parameter :: wname = 'w' character(len=*), public, parameter :: bname = 'b' Source Code subroutine add_bar ( me , left , height , label , width , bottom , color ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler real ( wp ), dimension (:), intent ( in ) :: left !! left bar values real ( wp ), dimension (:), intent ( in ) :: height !! height bar values character ( len =* ), intent ( in ) :: label !! plot label real ( wp ), dimension (:), intent ( in ), optional :: width !! width values real ( wp ), dimension (:), intent ( in ), optional :: bottom !! bottom values character ( len =* ), intent ( in ), optional :: color !! plot color character ( len = :), allocatable :: xstr !! x axis values stringified character ( len = :), allocatable :: ystr !! y axis values stringified character ( len = :), allocatable :: wstr !! width values stringified character ( len = :), allocatable :: bstr !! bottom values stringified character ( len = :), allocatable :: plt_str !! plot string character ( len =* ), parameter :: xname = 'x' !! x axis name character ( len =* ), parameter :: yname = 'y' !! y axis name character ( len =* ), parameter :: wname = 'w' !! width name character ( len =* ), parameter :: bname = 'b' !! bottom name if ( allocated ( me % str )) then !convert the arrays to strings: call vec_to_string ( left , xstr , me % use_numpy ) call vec_to_string ( height , ystr , me % use_numpy ) if ( present ( width )) call vec_to_string ( width , wstr , me % use_numpy ) if ( present ( bottom )) call vec_to_string ( bottom , bstr , me % use_numpy ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) if ( present ( width )) call me % add_str ( trim ( wname ) // ' = ' // wstr ) if ( present ( bottom )) call me % add_str ( trim ( bname ) // ' = ' // bstr ) call me % add_str ( '' ) !create the plot string: plt_str = 'ax.bar(' // & 'left=' // trim ( xname ) // ',' // & 'height=' // trim ( yname ) // ',' if ( present ( width )) plt_str = plt_str // 'width=' // trim ( wname ) // ',' if ( present ( bottom )) plt_str = plt_str // 'bottom=' // trim ( bstr ) // ',' if ( present ( color )) plt_str = plt_str // 'color=\"' // trim ( color ) // '\",' plt_str = plt_str // 'label=\"' // trim ( label ) // '\")' !write the plot statement: call me % add_str ( plt_str ) call me % add_str ( '' ) else error stop 'Error in add_bar: pyplot class not properly initialized.' end if end subroutine add_bar","tags":"","loc":"proc/add_bar.html","title":"add_bar – Shu-Osher-shock-tube-problem"},{"text":"private subroutine optional_int_to_string(int_value, string_value, default_value) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: int_value character(len=*), intent(out) :: string_value character(len=*), intent(in) :: default_value Calls proc~~optional_int_to_string~~CallsGraph proc~optional_int_to_string optional_int_to_string proc~integer_to_string integer_to_string proc~optional_int_to_string->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~optional_int_to_string~~CalledByGraph proc~optional_int_to_string optional_int_to_string proc~add_3d_plot add_3d_plot proc~add_3d_plot->proc~optional_int_to_string proc~initialize initialize proc~initialize->proc~optional_int_to_string proc~add_plot add_plot proc~add_plot->proc~optional_int_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine optional_int_to_string ( int_value , string_value , default_value ) integer , intent ( in ), optional :: int_value !! integer value character ( len =* ), intent ( out ) :: string_value !! integer value stringified character ( len =* ), intent ( in ) :: default_value !! default integer value if ( present ( int_value )) then call integer_to_string ( int_value , string_value ) else string_value = default_value end if end subroutine optional_int_to_string","tags":"","loc":"proc/optional_int_to_string.html","title":"optional_int_to_string – Shu-Osher-shock-tube-problem"},{"text":"private subroutine integer_to_string(i, s) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: i character(len=*), intent(out) :: s Called By proc~~integer_to_string~~CalledByGraph proc~integer_to_string integer_to_string proc~optional_int_to_string optional_int_to_string proc~optional_int_to_string->proc~integer_to_string proc~initialize initialize proc~initialize->proc~integer_to_string proc~initialize->proc~optional_int_to_string proc~add_3d_plot add_3d_plot proc~add_3d_plot->proc~optional_int_to_string proc~add_plot add_plot proc~add_plot->proc~optional_int_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: istat Source Code subroutine integer_to_string ( i , s ) integer , intent ( in ), optional :: i !! integer value character ( len =* ), intent ( out ) :: s !! integer value stringified integer :: istat !! IO status write ( s , int_fmt , iostat = istat ) i if ( istat /= 0 ) then error stop 'Error converting integer to string' else s = adjustl ( s ) end if end subroutine integer_to_string","tags":"","loc":"proc/integer_to_string.html","title":"integer_to_string – Shu-Osher-shock-tube-problem"},{"text":"private subroutine vec_to_string(v, str, use_numpy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: v character(len=:), intent(out), allocatable :: str logical, intent(in) :: use_numpy Called By proc~~vec_to_string~~CalledByGraph proc~vec_to_string vec_to_string proc~add_plot add_plot proc~add_plot->proc~vec_to_string proc~add_bar add_bar proc~add_bar->proc~vec_to_string proc~add_3d_plot add_3d_plot proc~add_3d_plot->proc~vec_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: istat character(len=max_real_len), public :: tmp Source Code subroutine vec_to_string ( v , str , use_numpy ) real ( wp ), dimension (:), intent ( in ) :: v !! real values character ( len = :), allocatable , intent ( out ) :: str !! real values stringified logical , intent ( in ) :: use_numpy !! activate numpy python module usage integer :: i !! counter integer :: istat !! IO status character ( len = max_real_len ) :: tmp !! dummy string str = '[' do i = 1 , size ( v ) write ( tmp , real_fmt , iostat = istat ) v ( i ) if ( istat /= 0 ) error stop 'Error in vec_to_string' str = str // trim ( adjustl ( tmp )) if ( i < size ( v )) str = str // ',' end do str = str // ']' !convert to numpy array if necessary: if ( use_numpy ) str = 'np.array(' // str // ')' end subroutine vec_to_string","tags":"","loc":"proc/vec_to_string.html","title":"vec_to_string – Shu-Osher-shock-tube-problem"},{"text":"private subroutine execute(me, pyfile) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in), optional :: pyfile Variables Type Visibility Attributes Name Initial integer, public :: istat integer, public :: iunit character(len=:), public, allocatable :: file logical, public :: scratch Source Code subroutine execute ( me , pyfile ) class ( pyplot ), intent ( inout ) :: me !! pytplot handler character ( len =* ), intent ( in ), optional :: pyfile !! name of the python script to generate integer :: istat !! IO status integer :: iunit !! IO unit character ( len = :), allocatable :: file !! file name logical :: scratch !! if a scratch file is to be used if ( allocated ( me % str )) then scratch = (. not . present ( pyfile )) !file name to use: if ( scratch ) then file = trim ( tmp_file ) !use the default else file = trim ( pyfile ) !use the user-specified name end if !open the file: open ( newunit = iunit , file = file , status = 'REPLACE' , iostat = istat ) if ( istat /= 0 ) error stop 'Error opening file.' !write to the file: write ( iunit , '(A)' ) me % str !run the file using python: call execute_command_line ( python_exe // ' ' // file ) !close the file: if ( scratch ) then close ( iunit , status = 'DELETE' , iostat = istat ) else close ( iunit , iostat = istat ) end if if ( istat /= 0 ) error stop 'Error closing file.' !cleanup: if ( allocated ( file )) deallocate ( file ) end if end subroutine execute","tags":"","loc":"proc/execute.html","title":"execute – Shu-Osher-shock-tube-problem"},{"text":"private subroutine savefig(me, figfile, pyfile) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in) :: figfile character(len=*), intent(in), optional :: pyfile Source Code subroutine savefig ( me , figfile , pyfile ) class ( pyplot ), intent ( inout ) :: me !! pyplot handler character ( len =* ), intent ( in ) :: figfile !! file name for the figure character ( len =* ), intent ( in ), optional :: pyfile !! name of the Python script to generate if ( allocated ( me % str )) then !finish up the string: if ( me % show_legend ) then call me % add_str ( 'ax.legend(loc=\"best\")' ) call me % add_str ( '' ) end if call me % add_str ( 'plt.savefig(\"' // trim ( figfile ) // '\")' ) !run it: call me % execute ( pyfile ) else error stop 'error in savefig: pyplot class not properly initialized.' end if end subroutine savefig","tags":"","loc":"proc/savefig.html","title":"savefig – Shu-Osher-shock-tube-problem"},{"text":"private purefunction Upper_Case(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be converted. Return Value character(len=len(string)) Converted string. Description Convert the lower case characters of a string to upper case one. Called By proc~~upper_case~~CalledByGraph proc~upper_case Upper_Case proc~add add proc~add->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. character(len=26), public, parameter :: upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' Upper case alphabet. character(len=26), public, parameter :: lower_alphabet = 'abcdefghijklmnopqrstuvwxyz' Lower case alphabet. Source Code pure function Upper_Case ( string ) ! elemental function Upper_Case(string) ! 1513-209 (S) The result of an elemental function must be a nonpointer, nonallocatable scalar, and its type parameters must be constant expressions. !--------------------------------------------------------------------------------------------------------------------------------- !< Convert the lower case characters of a string to upper case one. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len =* ), intent ( IN ) :: string !< String to be converted. character ( len = len ( string )) :: Upper_Case !< Converted string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. character ( len = 26 ), parameter :: upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( len = 26 ), parameter :: lower_alphabet = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Upper_Case = string do n1 = 1 , len ( string ) n2 = index ( lower_alphabet , string ( n1 : n1 )) if ( n2 > 0 ) Upper_Case ( n1 : n1 ) = upper_alphabet ( n2 : n2 ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction Upper_Case","tags":"","loc":"proc/upper_case.html","title":"Upper_Case – Shu-Osher-shock-tube-problem"},{"text":"private function check_list_size_cla(cla, Nv, val, pref) result(is_ok) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I4P), intent(in) :: Nv Number of values. character(len=*), intent(in) :: val First value. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. Description Check CLA multiple values list size consistency. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code function check_list_size_cla ( cla , Nv , val , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA multiple values list size consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), intent ( IN ) :: Nv !< Number of values. character ( * ), intent ( IN ) :: val !< First value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical :: is_ok !< Check result. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref is_ok = . true . if ( Nv == 1 ) then if ( trim ( adjustl ( val )) == '' ) then ! there is no real value, but only for nargs=+ this is a real error is_ok = . false . if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction check_list_size_cla","tags":"","loc":"proc/check_list_size_cla.html","title":"check_list_size_cla – Shu-Osher-shock-tube-problem"},{"text":"private function usage_cla(cla, pref) result(usage) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(in) :: cla CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Return Value character(len=:),\n  allocatable Usage string. Description Get correct CLA usage. Calls proc~~usage_cla~~CallsGraph proc~usage_cla usage_cla cton cton proc~usage_cla->cton str str proc~usage_cla->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: a Counter. Source Code function usage_cla ( cla , pref ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLA usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: usage !< Usage string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then prefd = '' ; if ( present ( pref )) prefd = pref if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then usage = '' select case ( cla % nargs ) case ( '+' ) usage = usage // ' value#1 [value#2...]' case ( '*' ) usage = usage // ' [value#1 value#2...]' case default do a = 1 , cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) usage = usage // ' value#' // trim ( str (. true ., a )) enddo endselect if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // usage // ', ' // trim ( adjustl ( cla % switch_ab )) // usage else usage = '   ' // trim ( adjustl ( cla % switch )) // usage endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ' value, ' // trim ( adjustl ( cla % switch_ab )) // ' value' else usage = '   ' // trim ( adjustl ( cla % switch )) // ' value' endif endif else usage = '  value' endif if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif elseif ( cla % act == action_store_star ) then usage = '  [value]' if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ', ' // trim ( adjustl ( cla % switch_ab )) else usage = '   ' // trim ( adjustl ( cla % switch )) endif endif usage = prefd // usage if ( cla % positional ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( str (. true ., cla % position )) // '-th argument' if ( allocated ( cla % envvar )) then if ( cla % envvar /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'environment variable name \"' // trim ( adjustl ( cla % envvar )) // '\"' endif endif if (. not . cla % required ) then if ( cla % def /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'default value ' // trim ( adjustl ( cla % def )) endif endif if ( cla % m_exclude /= '' ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'mutually exclude \"' // cla % m_exclude // '\"' usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( adjustl ( cla % help )) else usage = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_cla","tags":"","loc":"proc/usage_cla.html","title":"usage_cla – Shu-Osher-shock-tube-problem"},{"text":"private function signature_cla(cla) result(signd) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(in) :: cla CLA data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLA signature for adding to the CLI one. Calls proc~~signature_cla~~CallsGraph proc~signature_cla signature_cla cton cton proc~signature_cla->cton str str proc~signature_cla->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: nargs Number of arguments consumed by CLA. integer(kind=I4P), public :: a Counter. Source Code function signature_cla ( cla ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then select case ( cla % nargs ) case ( '+' ) signd = ' value#1 [value#2 value#3...]' case ( '*' ) signd = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) signd = '' do a = 1 , nargs signd = signd // ' value#' // trim ( str (. true ., a )) enddo endselect else signd = ' value' endif if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) // signd else signd = ' [' // trim ( adjustl ( cla % switch )) // signd // ']' endif else if ( cla % required ) then signd = ' value' else signd = ' [value]' endif endif elseif ( cla % act == action_store_star ) then signd = ' [value]' else if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) else signd = ' [' // trim ( adjustl ( cla % switch )) // ']' endif endif else signd = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_cla","tags":"","loc":"proc/signature_cla.html","title":"signature_cla – Shu-Osher-shock-tube-problem"},{"text":"private purefunction passed_clasg(clasg, switch, position) result(passed) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Description Check if a CLA has been passed. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: a CLA counter. Source Code pure function passed_clasg ( clasg , switch , position ) result ( passed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if ( clasg % Na > 0 ) then if ( present ( switch )) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then passed = clasg % cla ( a )% passed exit endif endif enddo elseif ( present ( position )) then passed = clasg % cla ( position )% passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed_clasg","tags":"","loc":"proc/passed_clasg.html","title":"passed_clasg – Shu-Osher-shock-tube-problem"},{"text":"private function defined_clasg(clasg, switch, pos) result(defined) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in) :: switch Switch name. integer(kind=I4P), intent(out), optional :: pos CLA position. Return Value logical Check if a CLA has been defined. Description Check if a CLA has been defined. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: a CLA counter. Source Code function defined_clasg ( clasg , switch , pos ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( OUT ) :: pos !< CLA position. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if ( present ( pos )) pos = 0 if ( clasg % Na > 0 ) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_clasg","tags":"","loc":"proc/defined_clasg.html","title":"defined_clasg – Shu-Osher-shock-tube-problem"},{"text":"private function usage_clasg(clasg, pref, no_header) result(usage) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. Return Value character(len=:),\n  allocatable Usage string. Description Get correct CLAs group usage. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: a Counters. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function usage_clasg ( clasg , pref , no_header ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAs group usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref usage = clasg % progname ; if ( clasg % group /= '' ) usage = clasg % progname // ' ' // clasg % group usage = prefd // clasg % help // ' ' // usage // clasg % signature () if ( clasg % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // clasg % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( clasg % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif if ( clasg % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , clasg % Na if (. not . clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_clasg","tags":"","loc":"proc/usage_clasg.html","title":"usage_clasg – Shu-Osher-shock-tube-problem"},{"text":"private function signature_clasg(clasg) result(signd) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLAs group signature for adding to the CLI one. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: a Counters. Source Code function signature_clasg ( clasg ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs group signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = '' do a = 1 , clasg % Na signd = signd // clasg % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_clasg","tags":"","loc":"proc/signature_clasg.html","title":"signature_clasg – Shu-Osher-shock-tube-problem"},{"text":"private function passed(cli, group, switch, position) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Description Check if a CLA has been passed. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g Counter. Source Code function passed ( cli , group , switch , position ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if (. not . present ( group )) then if ( present ( switch )) then passed = cli % clasg ( 0 )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( 0 )% passed ( position = position ) endif else if ( cli % defined_group ( group = group , g = g )) then if ( present ( switch )) then passed = cli % clasg ( g )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( g )% passed ( position = position ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed","tags":"","loc":"proc/passed.html","title":"passed – Shu-Osher-shock-tube-problem"},{"text":"private function defined_group(cli, group, g) result(defined) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. integer(kind=I4P), intent(out), optional :: g Index of group. Return Value logical Check if a CLAs group has been defined. Description Check if a CLAs group has been defined. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: gg integer(kind=I4P), public :: ggg Counters. Source Code function defined_group ( cli , group , g ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. integer ( I4P ), optional , intent ( OUT ) :: g !< Index of group. logical :: defined !< Check if a CLAs group has been defined. integer ( I4P ) :: gg , ggg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . do gg = 0 , size ( cli % clasg , dim = 1 ) - 1 ggg = gg if ( allocated ( cli % clasg ( gg )% group )) defined = ( cli % clasg ( gg )% group == group ) if ( defined ) exit enddo if ( present ( g )) g = ggg return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_group","tags":"","loc":"proc/defined_group.html","title":"defined_group – Shu-Osher-shock-tube-problem"},{"text":"private function called_group(cli, group) result(called) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. Return Value logical Check if a CLAs group has been runned. Description Check if a CLAs group has been runned. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g Counter. Source Code function called_group ( cli , group ) result ( called ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been runned. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: called !< Check if a CLAs group has been runned. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- called = . false . if ( cli % defined_group ( group = group , g = g )) called = cli % clasg ( g )% called return !--------------------------------------------------------------------------------------------------------------------------------- endfunction called_group","tags":"","loc":"proc/called_group.html","title":"called_group – Shu-Osher-shock-tube-problem"},{"text":"private function defined(cli, switch, group) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: switch Switch name. character(len=*), intent(in), optional :: group Name of group (command) of CLAs. Return Value logical Check if a CLA has been defined. Description Check if a CLA has been defined. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g Counter. Source Code function defined ( cli , switch , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if (. not . present ( group )) then defined = cli % clasg ( 0 )% defined ( switch = switch ) else if ( cli % defined_group ( group = group , g = g )) defined = cli % clasg ( g )% defined ( switch = switch ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined","tags":"","loc":"proc/defined.html","title":"defined – Shu-Osher-shock-tube-problem"},{"text":"private function usage(cli, g, pref, no_header, no_examples, no_epilog) result(usaged) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. integer(kind=I4P), intent(in) :: g Group index. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: no_examples Avoid insert examples to usage. logical, intent(in), optional :: no_epilog Avoid insert epilogue to usage. Return Value character(len=:),\n  allocatable Usage string. Description Print correct usage of CLI. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: no_headerd Avoid insert header to usage. logical, public :: no_examplesd Avoid insert examples to usage. logical, public :: no_epilogd Avoid insert epilogue to usage. integer(kind=I4P), public :: gi Counter. integer(kind=I4P), public :: e Counter. Source Code function usage ( cli , g , pref , no_header , no_examples , no_epilog ) result ( usaged ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage of CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. integer ( I4P ), intent ( IN ) :: g !< Group index. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( IN ) :: no_examples !< Avoid insert examples to usage. logical , optional , intent ( IN ) :: no_epilog !< Avoid insert epilogue to usage. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: usaged !< Usage string. logical :: no_headerd !< Avoid insert header to usage. logical :: no_examplesd !< Avoid insert examples to usage. logical :: no_epilogd !< Avoid insert epilogue to usage. integer ( I4P ) :: gi !< Counter. integer ( I4P ) :: e !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- no_headerd = . false . ; if ( present ( no_header )) no_headerd = no_header no_examplesd = . false . ; if ( present ( no_examples )) no_examplesd = no_examples no_epilogd = . false . ; if ( present ( no_epilog )) no_epilogd = no_epilog prefd = '' ; if ( present ( pref )) prefd = pref if ( g > 0 ) then ! usage of a specific command usaged = cli % clasg ( g )% usage ( pref = prefd , no_header = no_headerd ) else ! usage of whole CLI if ( no_headerd ) then usaged = '' else usaged = prefd // cli % help // cli % progname // ' ' // cli % signature () if ( cli % description /= '' ) usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // cli % description endif if ( cli % clasg ( 0 )% Na > 0 ) usaged = usaged // new_line ( 'a' ) // cli % clasg ( 0 )% usage ( pref = prefd , no_header = . true .) if ( size ( cli % clasg , dim = 1 ) > 1 ) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Commands:' do gi = 1 , size ( cli % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // cli % clasg ( gi )% group usaged = usaged // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // cli % clasg ( gi )% description enddo usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'For more detailed commands help try:' do gi = 1 , size ( cli % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // cli % progname // ' ' // cli % clasg ( gi )% group // ' -h,--help' enddo endif endif if ( allocated ( cli % examples ). and .(. not . no_examplesd )) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Examples:' do e = 1 , size ( cli % examples , dim = 1 ) usaged = usaged // new_line ( 'a' ) // prefd // '   ' // trim ( cli % examples ( e )) enddo endif if ( cli % epilog /= '' . and .(. not . no_epilogd )) usaged = usaged // new_line ( 'a' ) // prefd // cli % epilog return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage","tags":"","loc":"proc/usage.html","title":"usage – Shu-Osher-shock-tube-problem"},{"text":"private function signature(cli) result(signd) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLI signature. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g Counter. Source Code function signature ( cli ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLI signature. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = cli % clasg ( 0 )% signature () if ( size ( cli % clasg , dim = 1 ) > 1 ) then signd = signd // ' {' // cli % clasg ( 1 )% group do g = 2 , size ( cli % clasg , dim = 1 ) - 1 signd = signd // ',' // cli % clasg ( g )% group enddo signd = signd // '} ...' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature","tags":"","loc":"proc/signature.html","title":"signature – Shu-Osher-shock-tube-problem"},{"text":"private puresubroutine tokenize(strin, delimiter, toks, Nt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strin String to be tokenized. character(len=*), intent(in) :: delimiter Delimiter of tokens. character(len=len(strin)), intent(out), allocatable :: toks (:) Tokens. integer(kind=I4P), intent(out), optional :: Nt Number of tokens. Description Tokenize a string in order to parse it. Note The dummy array containing tokens must allocatable and its character elements must have the same length of the input\n string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with\n only one element set to char(0). Called By proc~~tokenize~~CalledByGraph proc~tokenize tokenize proc~get_cla_list_varying_r4p get_cla_list_varying_R4P proc~get_cla_list_varying_r4p->proc~tokenize proc~get_cla_list get_cla_list proc~get_cla_list->proc~tokenize proc~get_cla_list_varying_r16p get_cla_list_varying_R16P proc~get_cla_list_varying_r16p->proc~tokenize proc~get_cla_list_varying_i8p get_cla_list_varying_I8P proc~get_cla_list_varying_i8p->proc~tokenize none~sanitize_args sanitize_args none~sanitize_args->proc~tokenize proc~get_cla_list_varying_char get_cla_list_varying_char proc~get_cla_list_varying_char->proc~tokenize proc~check_choices_cla check_choices_cla proc~check_choices_cla->proc~tokenize proc~get_cla_list_varying_i4p get_cla_list_varying_I4P proc~get_cla_list_varying_i4p->proc~tokenize proc~get_cla_list_varying_i1p get_cla_list_varying_I1P proc~get_cla_list_varying_i1p->proc~tokenize proc~get_cla_list_varying_i2p get_cla_list_varying_I2P proc~get_cla_list_varying_i2p->proc~tokenize proc~get_cla_list_varying_r8p get_cla_list_varying_R8P proc~get_cla_list_varying_r8p->proc~tokenize proc~get_args_from_string get_args_from_string proc~get_args_from_string->proc~tokenize proc~get_args_from_string->none~sanitize_args proc~get_cla_list_varying_logical get_cla_list_varying_logical proc~get_cla_list_varying_logical->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=len(strin)), public :: strsub Temporary string. integer(kind=I4P), public :: dlen Delimiter length. integer(kind=I4P), public :: c Counter. integer(kind=I4P), public :: n Counter. integer(kind=I4P), public :: t Counter. Source Code pure subroutine tokenize ( strin , delimiter , toks , Nt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to char(0). !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( IN ) :: strin !< String to be tokenized. character ( len =* ), intent ( IN ) :: delimiter !< Delimiter of tokens. character ( len = len ( strin )), intent ( OUT ), allocatable :: toks (:) !< Tokens. integer ( I4P ), intent ( OUT ), optional :: Nt !< Number of tokens. character ( len = len ( strin )) :: strsub !< Temporary string. integer ( I4P ) :: dlen !< Delimiter length. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: n !< Counter. integer ( I4P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialization if ( allocated ( toks )) deallocate ( toks ) strsub = strin dlen = len ( delimiter ) if ( dlen > len ( strin )) then allocate ( toks ( 1 : 1 )) ; toks ( 1 ) = char ( 0 ) ; if ( present ( Nt )) Nt = 1 ; return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenization do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tokenize","tags":"","loc":"proc/tokenize.html","title":"tokenize – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine free_object(obj) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: obj Object data. Description Free dynamic memory. Source Code elemental subroutine free_object ( obj ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: obj !< Object data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( obj % progname )) deallocate ( obj % progname ) if ( allocated ( obj % version )) deallocate ( obj % version ) if ( allocated ( obj % help )) deallocate ( obj % help ) if ( allocated ( obj % description )) deallocate ( obj % description ) if ( allocated ( obj % license )) deallocate ( obj % license ) if ( allocated ( obj % authors )) deallocate ( obj % authors ) if ( allocated ( obj % epilog )) deallocate ( obj % epilog ) if ( allocated ( obj % m_exclude )) deallocate ( obj % m_exclude ) obj % error = 0_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_object","tags":"","loc":"proc/free_object.html","title":"free_object – Shu-Osher-shock-tube-problem"},{"text":"private subroutine errored(obj, error, pref, group, switch, val_str, log_value, a1, a2) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: obj Object data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Group name. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: val_str Value string. character(len=*), intent(in), optional :: log_value Logical value to be casted. integer(kind=I4P), intent(in), optional :: a1 integer(kind=I4P), intent(in), optional :: a2 CLAs group inconsistent indexes. Description Trig error occurence and print meaningful message. Calls proc~~errored~~CallsGraph proc~errored errored str str proc~errored->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code subroutine errored ( obj , error , pref , group , switch , val_str , log_value , a1 , a2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Trig error occurence and print meaningful message. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: obj !< Object data. integer ( I4P ), intent ( IN ) :: error !< Error occurred. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Group name. character ( * ), optional , intent ( IN ) :: switch !< CLA switch name. character ( * ), optional , intent ( IN ) :: val_str !< Value string. character ( * ), optional , intent ( IN ) :: log_value !< Logical value to be casted. integer ( I4P ), optional , intent ( IN ) :: a1 , a2 !< CLAs group inconsistent indexes. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- obj % error = error if ( obj % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref select type ( obj ) class is ( Type_Command_Line_Argument ) select case ( obj % error ) case ( error_cla_optional_no_def ) if ( obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str ( n = obj % position )) // & '-th\" positional option has not a default value!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // obj % switch // '\" has not a default value!' endif case ( error_cla_required_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // obj % switch // '\" cannot exclude others' // & ', it being requiredi, only optional ones can!' case ( error_cla_positional_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str ( n = obj % position )) // & '-th\" positional option cannot exclude others, only optional named options can!' case ( error_cla_named_no_name ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a non positional optiona must have a switch name!' case ( error_cla_positional_no_position ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a positional option must have a position number different from 0!' case ( error_cla_positional_no_store ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a positional option must have action set to \"' // action_store // '\"!' case ( error_cla_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: the options \"' // obj % switch // '\" and \"' // obj % m_exclude // '\" are mutually' // & ' exclusive, but both have been passed!' case ( error_cla_not_in_choices ) if ( obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: value of \"' // trim ( str ( n = obj % position )) // & '-th\" positional option must be chosen in:' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: value of named option \"' // obj % switch // '\" must be chosen in:' endif write ( stderr , '(A)' ) prefd // '(' // obj % choices // ')' write ( stderr , '(A)' ) prefd // '\"' // trim ( val_str ) // '\" has been passed!' case ( error_cla_missing_required ) if (. not . obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" is required!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option is required!' endif case ( error_cla_casting_logical ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: cannot convert \"' // log_value // '\" of option \"' // obj % switch // & '\" to logical type!' case ( error_cla_choices_logical ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: cannot use \"choices\" value check for option \"' // obj % switch // & '\" it being of logical type! The choices is, by definition of logical, limited to \".true.\" or \".false.\"' case ( error_cla_no_list ) if (. not . obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" has not \"nargs\" value' // & ' but an array has been passed to \"get\" method!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has not \"nargs\" value but an array has been passed to \"get\" method!' endif case ( error_cla_nargs_insufficient ) if (. not . obj % positional ) then if ( obj % nargs == '+' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" requires at least ' // & '1 argument but no one remains!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" requires ' // & trim ( adjustl ( obj % nargs )) // ' arguments but no enough ones remain!' endif else if ( obj % nargs == '+' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option requires at least 1 argument but no one remains' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option requires ' // & trim ( adjustl ( obj % nargs )) // ' arguments but no enough ones remain!' endif endif case ( error_cla_value_missing ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" needs a value that is not passed!' case ( error_cla_unknown ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: switch \"' // trim ( adjustl ( switch )) // '\" is unknown!' case ( error_cla_envvar_positional ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has \"envvar\" value that is not allowed for positional option!' case ( error_cla_envvar_not_store ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" is an envvar with action different from \"' // action_store // '\" that is not allowed!' case ( error_cla_envvar_nargs ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" is an envvar that is not allowed for list valued option!' case ( error_cla_store_star_positional ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has \"' // action_store_star // '\" action that is not allowed for positional option!' case ( error_cla_store_star_nargs ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for list valued option!' case ( error_cla_store_star_envvar ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for environment variable option!' case ( error_cla_action_unknown ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has unknown \"' // obj % act // '\" action!' endselect class is ( Type_Command_Line_Arguments_Group ) select case ( obj % error ) case ( error_clasg_consistency ) if ( obj % group /= '' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: group (command) name: \"' // obj % group // '\" consistency error:' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: consistency error:' endif write ( stderr , '(A)' ) prefd // ' \"' // trim ( str (. true ., a1 )) // '-th\" option has the same switch or abbreviated switch of \"' & // trim ( str (. true ., a2 )) // '-th\" option:' write ( stderr , '(A)' ) prefd // ' CLA(' // trim ( str (. true ., a1 )) // ') switches = ' // obj % cla ( a1 )% switch // ' ' // & obj % cla ( a1 )% switch_ab write ( stderr , '(A)' ) prefd // ' CLA(' // trim ( str (. true ., a2 )) // ') switches = ' // obj % cla ( a2 )% switch // ' ' // & obj % cla ( a2 )% switch_ab case ( error_clasg_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: the group \"' // obj % group // '\" and \"' // obj % m_exclude // '\" are mutually' // & ' exclusive, but both have been called!' endselect class is ( Type_Command_Line_Interface ) select case ( obj % error ) case ( error_cli_missing_cla ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: there is no option \"' // trim ( adjustl ( switch )) // '\"!' case ( error_cli_missing_selection_cla ) write ( stderr , '(A)' ) prefd // obj % progname // & ': error: to get an option value one of switch \"name\" or \"position\" must be provided!' case ( error_cli_missing_group ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: ther is no group (command) named \"' // trim ( adjustl ( group )) // '\"!' case ( error_cli_too_few_clas ) ! write(stderr,'(A)')prefd//obj%progname//': error: too few arguments ('//trim(str(.true.,Na))//')'//& ! ' respect the required ('//trim(str(.true.,obj%Na_required))//')' endselect endselect write ( stderr , '(A)' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine errored","tags":"","loc":"proc/errored.html","title":"errored – Shu-Osher-shock-tube-problem"},{"text":"private subroutine print_version(obj, pref) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(in) :: obj Object data. character(len=*), intent(in), optional :: pref Prefixing string. Description Print version. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code subroutine print_version ( obj , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print version. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( IN ) :: obj !< Object data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref write ( stdout , '(A)' ) prefd // obj % progname // ' version ' // obj % version if ( obj % license /= '' ) then write ( stdout , '(A)' ) prefd // obj % license endif if ( obj % authors /= '' ) then write ( stdout , '(A)' ) prefd // obj % authors endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_version","tags":"","loc":"proc/print_version.html","title":"print_version – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine assign_object(lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: lhs Left hand side. class( Type_Object ), intent(in) :: rhs Rigth hand side. Source Code elemental subroutine assign_object ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: lhs !< Left hand side. class ( Type_Object ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members if ( allocated ( rhs % progname )) lhs % progname = rhs % progname if ( allocated ( rhs % version )) lhs % version = rhs % version if ( allocated ( rhs % help )) lhs % help = rhs % help if ( allocated ( rhs % description )) lhs % description = rhs % description if ( allocated ( rhs % license )) lhs % license = rhs % license if ( allocated ( rhs % authors )) lhs % authors = rhs % authors if ( allocated ( rhs % epilog )) lhs % epilog = rhs % epilog if ( allocated ( rhs % m_exclude )) lhs % m_exclude = rhs % m_exclude lhs % error = rhs % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_object","tags":"","loc":"proc/assign_object.html","title":"assign_object – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine free_cla(cla) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. Description Free dynamic memory. Source Code elemental subroutine free_cla ( cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cla % free_object ! Type_Command_Line_Argument members if ( allocated ( cla % switch )) deallocate ( cla % switch ) if ( allocated ( cla % switch_ab )) deallocate ( cla % switch_ab ) if ( allocated ( cla % act )) deallocate ( cla % act ) if ( allocated ( cla % def )) deallocate ( cla % def ) if ( allocated ( cla % nargs )) deallocate ( cla % nargs ) if ( allocated ( cla % choices )) deallocate ( cla % choices ) if ( allocated ( cla % val )) deallocate ( cla % val ) if ( allocated ( cla % envvar )) deallocate ( cla % envvar ) cla % required = . false . cla % positional = . false . cla % position = 0_I4P cla % passed = . false . cla % hidden = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_cla","tags":"","loc":"proc/free_cla.html","title":"free_cla – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine finalize_cla(cla) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. Description Free dynamic memory when finalizing. Source Code elemental subroutine finalize_cla ( cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cla % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_cla","tags":"","loc":"proc/finalize_cla.html","title":"finalize_cla – Shu-Osher-shock-tube-problem"},{"text":"private subroutine check_cla(cla, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check CLA data consistency. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code subroutine check_cla ( cla , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( allocated ( cla % envvar )) then if ( cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_envvar_positional ) return endif if (. not . allocated ( cla % act )) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return else if ( cla % act /= action_store ) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return endif endif if ( allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_envvar_nargs ) return endif endif if ( allocated ( cla % act )) then if ( cla % act == action_store_star . and . cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_store_star_positional ) return endif if ( cla % act == action_store_star . and . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_store_star_nargs ) return endif if ( cla % act == action_store_star . and . allocated ( cla % envvar )) then call cla % errored ( pref = prefd , error = error_cla_store_star_envvar ) return endif if ( cla % act /= action_store . and . & cla % act /= action_store_star . and . & cla % act /= action_store_true . and . & cla % act /= action_store_false . and .& cla % act /= action_print_help . and . & cla % act /= action_print_vers ) then call cla % errored ( pref = prefd , error = error_cla_action_unknown ) return endif endif if ((. not . cla % required ). and .(. not . allocated ( cla % def ))) then call cla % errored ( pref = prefd , error = error_cla_optional_no_def ) return endif if (( cla % required ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_required_m_exclude ) return endif if (( cla % positional ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_positional_m_exclude ) return endif if ((. not . cla % positional ). and .(. not . allocated ( cla % switch ))) then call cla % errored ( pref = prefd , error = error_cla_named_no_name ) return elseif (( cla % positional ). and .( cla % position == 0_I4P )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_position ) return elseif (( cla % positional ). and .( cla % act /= action_store )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_store ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_cla","tags":"","loc":"proc/check_cla.html","title":"check_cla – Shu-Osher-shock-tube-problem"},{"text":"private subroutine check_choices_cla(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. class(*), intent(in) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if CLA value is in allowed choices. Note This procedure can be called if and only if cla%choices has been allocated. Calls proc~~check_choices_cla~~CallsGraph proc~check_choices_cla check_choices_cla cton cton proc~check_choices_cla->cton proc~tokenize tokenize proc~check_choices_cla->proc~tokenize str str proc~check_choices_cla->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. character(len=len(cla%choices)), public, allocatable :: toks (:) Tokens for parsing choices list. integer(kind=I4P), public :: Nc Number of choices. logical, public :: val_in Flag for checking if val is in the choosen range. character(len=:), public, allocatable :: val_str Value in string form. character(len=:), public, allocatable :: tmp Temporary string for avoiding GNU gfrotran bug. integer(kind=I4P), public :: c Counter. Source Code subroutine check_choices_cla ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if CLA value is in allowed choices. !< !< @note This procedure can be called if and only if cla%choices has been allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. class ( * ), intent ( IN ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len ( cla % choices )), allocatable :: toks (:) !< Tokens for parsing choices list. integer ( I4P ) :: Nc !< Number of choices. logical :: val_in !< Flag for checking if val is in the choosen range. character ( len = :), allocatable :: val_str !< Value in string form. character ( len = :), allocatable :: tmp !< Temporary string for avoiding GNU gfrotran bug. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- val_in = . false . val_str = '' tmp = cla % choices call tokenize ( strin = tmp , delimiter = ',' , toks = toks , Nt = Nc ) select type ( val ) #ifdef r16p type is ( real ( R16P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R16P )) val_in = . true . enddo #endif type is ( real ( R8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R8P )) val_in = . true . enddo type is ( real ( R4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R4P )) val_in = . true . enddo type is ( integer ( I8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I8P )) val_in = . true . enddo type is ( integer ( I4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I4P )) val_in = . true . enddo type is ( integer ( I2P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I2P )) val_in = . true . enddo type is ( integer ( I1P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I1P )) val_in = . true . enddo type is ( character ( * )) val_str = val do c = 1 , Nc if ( val == toks ( c )) val_in = . true . enddo type is ( logical ) prefd = '' ; if ( present ( pref )) prefd = pref call cla % errored ( pref = prefd , error = error_cla_choices_logical ) endselect if (. not . val_in . and .( cla % error == 0 )) then prefd = '' ; if ( present ( pref )) prefd = pref call cla % errored ( pref = prefd , error = error_cla_not_in_choices , val_str = val_str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_choices_cla","tags":"","loc":"proc/check_choices_cla.html","title":"check_choices_cla – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla(cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val CLA value. Description Get CLA (single) value. Calls proc~~get_cla~~CallsGraph proc~get_cla get_cla cton cton proc~get_cla->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code subroutine get_cla ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if ( cla % act == action_store . or . cla % act == action_store_star ) then if ( cla % passed . and . allocated ( cla % val )) then select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I1P ) type is ( logical ) read ( cla % val , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % val ) type is ( character ( * )) val = cla % val endselect elseif ( allocated ( cla % def )) then ! using default value select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I1P ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) type is ( character ( * )) val = cla % def endselect endif if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val , pref = prefd ) elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla","tags":"","loc":"proc/get_cla.html","title":"get_cla – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list(cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. Description Get CLA (multiple) value. Calls proc~~get_cla_list~~CallsGraph proc~get_cla_list get_cla_list proc~tokenize tokenize proc~get_cla_list->proc~tokenize cton cton proc~get_cla_list->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsV ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsD ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect endif elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list","tags":"","loc":"proc/get_cla_list.html","title":"get_cla_list – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_R16P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R16P). Calls proc~~get_cla_list_varying_r16p~~CallsGraph proc~get_cla_list_varying_r16p get_cla_list_varying_R16P proc~tokenize tokenize proc~get_cla_list_varying_r16p->proc~tokenize cton cton proc~get_cla_list_varying_r16p->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_R16P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return if ( Nv == 1 ) then if ( trim ( adjustl ( valsD ( 1 ))) == '' ) then if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif return endif endif allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P","tags":"","loc":"proc/get_cla_list_varying_r16p.html","title":"get_cla_list_varying_R16P – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_R8P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R8P). Calls proc~~get_cla_list_varying_r8p~~CallsGraph proc~get_cla_list_varying_r8p get_cla_list_varying_R8P proc~tokenize tokenize proc~get_cla_list_varying_r8p->proc~tokenize cton cton proc~get_cla_list_varying_r8p->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_R8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P","tags":"","loc":"proc/get_cla_list_varying_r8p.html","title":"get_cla_list_varying_R8P – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_R4P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R4P). Calls proc~~get_cla_list_varying_r4p~~CallsGraph proc~get_cla_list_varying_r4p get_cla_list_varying_R4P proc~tokenize tokenize proc~get_cla_list_varying_r4p->proc~tokenize cton cton proc~get_cla_list_varying_r4p->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_R4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P","tags":"","loc":"proc/get_cla_list_varying_r4p.html","title":"get_cla_list_varying_R4P – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_I8P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I8P). Calls proc~~get_cla_list_varying_i8p~~CallsGraph proc~get_cla_list_varying_i8p get_cla_list_varying_I8P proc~tokenize tokenize proc~get_cla_list_varying_i8p->proc~tokenize cton cton proc~get_cla_list_varying_i8p->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_I8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P","tags":"","loc":"proc/get_cla_list_varying_i8p.html","title":"get_cla_list_varying_I8P – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_I4P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I4P). Calls proc~~get_cla_list_varying_i4p~~CallsGraph proc~get_cla_list_varying_i4p get_cla_list_varying_I4P proc~tokenize tokenize proc~get_cla_list_varying_i4p->proc~tokenize cton cton proc~get_cla_list_varying_i4p->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_I4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P","tags":"","loc":"proc/get_cla_list_varying_i4p.html","title":"get_cla_list_varying_I4P – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_I2P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I2P). Calls proc~~get_cla_list_varying_i2p~~CallsGraph proc~get_cla_list_varying_i2p get_cla_list_varying_I2P proc~tokenize tokenize proc~get_cla_list_varying_i2p->proc~tokenize cton cton proc~get_cla_list_varying_i2p->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_I2P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P","tags":"","loc":"proc/get_cla_list_varying_i2p.html","title":"get_cla_list_varying_I2P – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_I1P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I1P). Calls proc~~get_cla_list_varying_i1p~~CallsGraph proc~get_cla_list_varying_i1p get_cla_list_varying_I1P proc~tokenize tokenize proc~get_cla_list_varying_i1p->proc~tokenize cton cton proc~get_cla_list_varying_i1p->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_I1P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P","tags":"","loc":"proc/get_cla_list_varying_i1p.html","title":"get_cla_list_varying_I1P – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_logical(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, logical. Calls proc~~get_cla_list_varying_logical~~CallsGraph proc~get_cla_list_varying_logical get_cla_list_varying_logical proc~tokenize tokenize proc~get_cla_list_varying_logical->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_logical ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, logical. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical","tags":"","loc":"proc/get_cla_list_varying_logical.html","title":"get_cla_list_varying_logical – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_char(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, character. Calls proc~~get_cla_list_varying_char~~CallsGraph proc~get_cla_list_varying_char get_cla_list_varying_char proc~tokenize tokenize proc~get_cla_list_varying_char->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_char ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, character. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsV ( v ))) enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsD ( v ))) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char","tags":"","loc":"proc/get_cla_list_varying_char.html","title":"get_cla_list_varying_char – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine assign_cla(lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Argument ), intent(in) :: rhs Rigth hand side. Source Code elemental subroutine assign_cla ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Argument ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % required = rhs % required lhs % positional = rhs % positional lhs % position = rhs % position lhs % passed = rhs % passed lhs % hidden = rhs % hidden return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cla","tags":"","loc":"proc/assign_cla.html","title":"assign_cla – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine free_clasg(clasg) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. Description Free dynamic memory. Source Code elemental subroutine free_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call clasg % free_object ! Type_Command_Line_Arguments_Group members if ( allocated ( clasg % group )) deallocate ( clasg % group ) if ( allocated ( clasg % cla )) then call clasg % cla % free deallocate ( clasg % cla ) endif clasg % Na = 0_I4P clasg % Na_required = 0_I4P clasg % Na_optional = 0_I4P clasg % called = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_clasg","tags":"","loc":"proc/free_clasg.html","title":"free_clasg – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine finalize_clasg(clasg) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. Description Free dynamic memory when finalizing. Source Code elemental subroutine finalize_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call clasg % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_clasg","tags":"","loc":"proc/finalize_clasg.html","title":"finalize_clasg – Shu-Osher-shock-tube-problem"},{"text":"private subroutine check_clasg(clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check CLA data consistency. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: a integer(kind=I4P), public :: aa Counters. Source Code subroutine check_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a , aa !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! verifing if CLAs switches are unique CLA_unique : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then do aa = 1 , clasg % Na if (( a /= aa ). and .(. not . clasg % cla ( aa )% positional )) then if (( clasg % cla ( a )% switch == clasg % cla ( aa )% switch ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch ). or .& ( clasg % cla ( a )% switch == clasg % cla ( aa )% switch_ab ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch_ab )) then call clasg % errored ( pref = prefd , error = error_clasg_consistency , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! updating mutually exclusive relations CLA_exclude : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % defined ( switch = clasg % cla ( a )% m_exclude , pos = aa )) then clasg % cla ( aa )% m_exclude = clasg % cla ( a )% switch endif endif endif enddo CLA_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_clasg","tags":"","loc":"proc/check_clasg.html","title":"check_clasg – Shu-Osher-shock-tube-problem"},{"text":"private subroutine check_required_clasg(clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if required CLAs are passed. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: a Counter. Source Code subroutine check_required_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLAs are passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( clasg % called ) then do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) then if (. not . clasg % cla ( a )% passed ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_missing_required ) clasg % error = clasg % cla ( a )% error write ( stdout , '(A)' ) clasg % usage ( pref = prefd ) return endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_required_clasg","tags":"","loc":"proc/check_required_clasg.html","title":"check_required_clasg – Shu-Osher-shock-tube-problem"},{"text":"private subroutine check_m_exclusive_clasg(clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if two mutually exclusive CLAs have been passed. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: a Counter. Source Code subroutine check_m_exclusive_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs have been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref do a = 1 , clasg % Na if ( clasg % cla ( a )% passed ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % passed ( switch = clasg % cla ( a )% m_exclude )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_m_exclude ) clasg % error = clasg % cla ( a )% error return endif endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive_clasg","tags":"","loc":"proc/check_m_exclusive_clasg.html","title":"check_m_exclusive_clasg – Shu-Osher-shock-tube-problem"},{"text":"private subroutine add_cla_clasg(clasg, pref, cla) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. type( Type_Command_Line_Argument ), intent(in) :: cla CLA data. Description Add CLA to CLAs list. Note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name\n or directly passed in case of positional CLA. Variables Type Visibility Attributes Name Initial type( Type_Command_Line_Argument ), public, allocatable :: cla_list_new (:) New (extended) CLA list. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: c Counter. Source Code subroutine add_cla_clasg ( clasg , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. type ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. type ( Type_Command_Line_Argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % Na > 0_I4P ) then if (. not . cla % positional ) then allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , clasg % Na cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( clasg % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , clasg % Na + 1 cla_list_new ( c ) = clasg % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = clasg % cla ) clasg % Na = clasg % Na + 1 if ( cla % required ) then clasg % Na_required = clasg % Na_required + 1 else clasg % Na_optional = clasg % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) prefd = '' ; if ( present ( pref )) prefd = pref call clasg % check ( pref = prefd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_cla_clasg","tags":"","loc":"proc/add_cla_clasg.html","title":"add_cla_clasg – Shu-Osher-shock-tube-problem"},{"text":"private subroutine parse_clasg(clasg, pref, args) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in) :: args (:) Command line arguments. Description Parse CLAs group arguments. Calls proc~~parse_clasg~~CallsGraph proc~parse_clasg parse_clasg cton cton proc~parse_clasg->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=500), public :: envvar Environment variables buffer. integer(kind=I4P), public :: arg Argument counter. integer(kind=I4P), public :: a Counter. integer(kind=I4P), public :: aa Counter. integer(kind=I4P), public :: aaa Counter. integer(kind=I4P), public :: nargs Number of arguments consumed by a CLA. character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if switch is a defined CLA. logical, public :: found_val Flag for checking if switch value is found. Source Code subroutine parse_clasg ( clasg , pref , args ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAs group arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), intent ( IN ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , clasg % Na ! loop ver CLAs group clas named options if (. not . clasg % cla ( a )% positional ) then if ( trim ( adjustl ( clasg % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( clasg % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( clasg % cla ( a )% act == action_store ) then found_val = . false . if ( allocated ( clasg % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = clasg % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then clasg % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) then clasg % cla ( a )% val = clasg % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( clasg % cla ( a )% nargs )) then clasg % cla ( a )% val = '' select case ( clasg % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( clasg % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) enddo arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_value_missing ) clasg % error = clasg % cla ( a )% error return endif arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( clasg % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . endif endif if (. not . found ) then ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) clasg % cla ( a )% val = clasg % cla ( a )% def endif elseif ( clasg % cla ( a )% act == action_print_help ) then clasg % error = status_clasg_print_h elseif ( clasg % cla ( a )% act == action_print_vers ) then clasg % error = status_clasg_print_v endif clasg % cla ( a )% passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . clasg % cla ( arg )% positional ) then ! current argument (arg-th) is not positional... there is a problem! call clasg % cla ( arg )% errored ( pref = prefd , error = error_cla_unknown , switch = trim ( adjustl ( args ( arg )))) clasg % error = clasg % cla ( arg )% error return else ! positional CLA always stores a value clasg % cla ( arg )% val = trim ( adjustl ( args ( arg ))) clasg % cla ( arg )% passed = . true . endif endif enddo call clasg % check_m_exclusive ( pref = prefd ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_clasg","tags":"","loc":"proc/parse_clasg.html","title":"parse_clasg – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine assign_clasg(lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Arguments_Group ), intent(in) :: rhs Right hand side. Source Code elemental subroutine assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Arguments_Group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % called = rhs % called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_clasg","tags":"","loc":"proc/assign_clasg.html","title":"assign_clasg – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine free(cli) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. Description Free dynamic memory. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g Counter. Source Code elemental subroutine free ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cli % free_object ! Type_Command_Line_Interface members if ( allocated ( cli % clasg )) then do g = 0 , size ( cli % clasg , dim = 1 ) - 1 call cli % clasg ( g )% free enddo deallocate ( cli % clasg ) endif if ( allocated ( cli % examples )) deallocate ( cli % examples ) cli % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free.html","title":"free – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine finalize(cli) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. Description Free dynamic memory when finalizing. Source Code elemental subroutine finalize ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~9.html","title":"finalize – Shu-Osher-shock-tube-problem"},{"text":"private subroutine init(cli, progname, version, help, description, license, authors, examples, epilog, disable_hv) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: progname Program name. character(len=*), intent(in), optional :: version Program version. character(len=*), intent(in), optional :: help Help message introducing the CLI usage. character(len=*), intent(in), optional :: description Detailed description message introducing the program. character(len=*), intent(in), optional :: license License description. character(len=*), intent(in), optional :: authors Authors list. character(len=*), intent(in), optional :: examples (1:) Examples of correct usage. character(len=*), intent(in), optional :: epilog Epilog message. logical, intent(in), optional :: disable_hv Disable automatic insert of 'help' and 'version' CLAs. Description Initialize CLI. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prog_invocation Complete program invocation. integer(kind=I4P), public :: invocation_length Length of invocation. integer(kind=I4P), public :: retrieval_status Retrieval status. Source Code subroutine init ( cli , progname , version , help , description , license , authors , examples , epilog , disable_hv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: progname !< Program name. character ( * ), optional , intent ( IN ) :: version !< Program version. character ( * ), optional , intent ( IN ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( IN ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( IN ) :: license !< License description. character ( * ), optional , intent ( IN ) :: authors !< Authors list. character ( * ), optional , intent ( IN ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( IN ) :: epilog !< Epilog message. logical , optional , intent ( IN ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free if ( present ( progname )) then cli % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then cli % progname = prog_invocation else cli % progname = 'program' endif endif cli % version = 'unknown' ; if ( present ( version )) cli % version = version cli % help = 'usage: ' ; if ( present ( help )) cli % help = help cli % description = '' ; if ( present ( description )) cli % description = description cli % license = '' ; if ( present ( license )) cli % license = license cli % authors = '' ; if ( present ( authors )) cli % authors = authors cli % epilog = '' ; if ( present ( epilog )) cli % epilog = epilog if ( present ( disable_hv )) cli % disable_hv = disable_hv if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( cli % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: cli % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif cli % examples = examples endif ! initialize only the first default group allocate ( cli % clasg ( 0 : 0 )) call cli % clasg ( 0 )% assign_object ( cli ) cli % clasg ( 0 )% group = '' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~10.html","title":"init – Shu-Osher-shock-tube-problem"},{"text":"private subroutine add_group(cli, help, description, exclude, group) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: help Help message. character(len=*), intent(in), optional :: description Detailed description. character(len=*), intent(in), optional :: exclude Group name of the mutually exclusive group. character(len=*), intent(in) :: group Name of the grouped CLAs. Description Add CLAs group to CLI. Variables Type Visibility Attributes Name Initial type( Type_Command_Line_Arguments_Group ), public, allocatable :: clasg_list_new (:) New (extended) CLAs group list. character(len=:), public, allocatable :: helpd Help message. character(len=:), public, allocatable :: descriptiond Detailed description. character(len=:), public, allocatable :: excluded Group name of the mutually exclusive group. integer(kind=I4P), public :: Ng Number of groups. integer(kind=I4P), public :: gi Group index Source Code subroutine add_group ( cli , help , description , exclude , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLAs group to CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: help !< Help message. character ( * ), optional , intent ( IN ) :: description !< Detailed description. character ( * ), optional , intent ( IN ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( IN ) :: group !< Name of the grouped CLAs. type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. integer ( I4P ) :: gi !< Group index !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cli % defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( cli % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) !    clasg_list_new(0:Ng-1) = cli%clasg(0:Ng-1) ! Not working on Intel Fortran 15.0.2 do gi = 0 , Ng - 1 clasg_list_new ( gi ) = cli % clasg ( gi ) enddo call clasg_list_new ( Ng )% assign_object ( cli ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( cli % clasg ) allocate ( cli % clasg ( 0 : Ng )) cli % clasg = clasg_list_new deallocate ( clasg_list_new ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_group","tags":"","loc":"proc/add_group.html","title":"add_group – Shu-Osher-shock-tube-problem"},{"text":"private subroutine set_mutually_exclusive_groups(cli, group1, group2) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in) :: group1 Name of the first grouped CLAs. character(len=*), intent(in) :: group2 Name of the second grouped CLAs. Description Set two CLAs group ad mutually exclusive. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g1 integer(kind=I4P), public :: g2 Counters. Source Code subroutine set_mutually_exclusive_groups ( cli , group1 , group2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set two CLAs group ad mutually exclusive. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( IN ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 , g2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( cli % defined_group ( group = group1 , g = g1 ). and . cli % defined_group ( group = group2 , g = g2 )) then cli % clasg ( g1 )% m_exclude = group2 cli % clasg ( g2 )% m_exclude = group1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_mutually_exclusive_groups","tags":"","loc":"proc/set_mutually_exclusive_groups.html","title":"set_mutually_exclusive_groups – Shu-Osher-shock-tube-problem"},{"text":"private subroutine add(cli, pref, group, group_index, switch, switch_ab, help, required, positional, position, hidden, act, def, nargs, choices, exclude, envvar, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of the grouped CLAs. integer(kind=I4P), intent(in), optional :: group_index Index of the grouped CLAs. character(len=*), intent(in), optional :: switch Switch name. character(len=*), intent(in), optional :: switch_ab Abbreviated switch name. character(len=*), intent(in), optional :: help Help message describing the CLA. logical, intent(in), optional :: required Flag for set required argument. logical, intent(in), optional :: positional Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. logical, intent(in), optional :: hidden Flag for hiding CLA, thus it does not compare into help. character(len=*), intent(in), optional :: act CLA value action. character(len=*), intent(in), optional :: def Default value. character(len=*), intent(in), optional :: nargs Number of arguments consumed by CLA. character(len=*), intent(in), optional :: choices List of allowable values for the argument. character(len=*), intent(in), optional :: exclude Switch name of the mutually exclusive CLA. character(len=*), intent(in), optional :: envvar Environment variable from which take value. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Add CLA to CLI. Note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name\n or directly passed in case of positional CLA. Note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. Note If CLA belongs to a not yet present group it is created on the fly. Calls proc~~add~~CallsGraph proc~add add proc~upper_case Upper_Case proc~add->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( Type_Command_Line_Argument ), public :: cla CLA data. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: g Counter. Source Code subroutine add ( cli , pref , group , group_index , switch , switch_ab , help , required , positional , position , hidden , act , def , nargs ,& choices , exclude , envvar , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( IN ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( IN ) :: help !< Help message describing the CLA. logical , optional , intent ( IN ) :: required !< Flag for set required argument. logical , optional , intent ( IN ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical , optional , intent ( IN ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( IN ) :: act !< CLA value action. character ( * ), optional , intent ( IN ) :: def !< Default value. character ( * ), optional , intent ( IN ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( IN ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( IN ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( IN ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. type ( Type_Command_Line_Argument ) :: cla !< CLA data. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initializing CLA call cla % assign_object ( cli ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % required = . false . ; if ( present ( required )) cla % required = required cla % positional = . false . ; if ( present ( positional )) cla % positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % hidden = . false . ; if ( present ( hidden )) cla % hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( def )) cla % val = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar prefd = '' ; if ( present ( pref )) prefd = pref call cla % check ( pref = prefd ) ; cli % error = cla % error if ( cli % error /= 0 ) then if ( present ( error )) error = cli % error return endif ! adding CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call cli % clasg ( 0 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( 0 )% error elseif ( present ( group )) then if ( cli % defined_group ( group = group , g = g )) then call cli % clasg ( g )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( g )% error else call cli % add_group ( group = group ) call cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( cli % clasg , dim = 1 ) - 1 ) then call cli % clasg ( group_index )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( group_index )% error endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add","tags":"","loc":"proc/add.html","title":"add – Shu-Osher-shock-tube-problem"},{"text":"private subroutine check(cli, pref, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Check CLAs data consistency. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: g integer(kind=I4P), public :: gg Counters. Source Code subroutine check ( cli , pref , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLAs data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref do g = 0 , size ( cli % clasg , dim = 1 ) - 1 ! check group consistency call cli % clasg ( g )% check ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( present ( error )) error = cli % error if ( cli % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( cli % clasg ( g )% m_exclude /= '' ) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) cli % clasg ( gg )% m_exclude = cli % clasg ( g )% group endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check","tags":"","loc":"proc/check.html","title":"check – Shu-Osher-shock-tube-problem"},{"text":"private subroutine check_m_exclusive(cli, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if two mutually exclusive CLAs group have been called. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: g integer(kind=I4P), public :: gg Counters. Source Code subroutine check_m_exclusive ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs group have been called. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do g = 1 , size ( cli % clasg , dim = 1 ) - 1 if ( cli % clasg ( g )% called . and .( cli % clasg ( g )% m_exclude /= '' )) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) then if ( cli % clasg ( gg )% called ) then prefd = '' ; if ( present ( pref )) prefd = pref call cli % clasg ( g )% errored ( pref = prefd , error = error_clasg_m_exclude ) cli % error = cli % clasg ( g )% error exit endif endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive","tags":"","loc":"proc/check_m_exclusive.html","title":"check_m_exclusive – Shu-Osher-shock-tube-problem"},{"text":"private subroutine parse(cli, pref, args, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Parse Command Line Interfaces by means of a previously initialized CLAs groups list. Note The leading and trailing white spaces are removed from CLA values. Note If the args argument is passed the command line arguments are taken from it and not from the actual program CLI\n invocations. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: g Counter for CLAs group. integer(kind=I4P), public, allocatable :: ai (:,:) Counter for CLAs grouped. Source Code subroutine parse ( cli , pref , args , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse Command Line Interfaces by means of a previously initialized CLAs groups list. !< !< @note The leading and trailing white spaces are removed from CLA values. !< !< @note If the *args* argument is passed the command line arguments are taken from it and not from the actual program CLI !< invocations. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: args !< String containing command line arguments. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter for CLAs group. integer ( I4P ), allocatable :: ai (:,:) !< Counter for CLAs grouped. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! add help and version switches if not done by user if (. not . cli % disable_hv ) then do g = 0 , size ( cli % clasg , dim = 1 ) - 1 if (. not .( cli % defined ( group = cli % clasg ( g )% group , switch = '--help' ). and . cli % defined ( group = cli % clasg ( g )% group , switch = '-h' ))) & call cli % add ( pref = prefd , & group_index = g , & switch = '--help' , & switch_ab = '-h' , & help = 'Print this help message' , & required = . false ., & def = '' , & act = 'print_help' ) if (. not .( cli % defined ( group = cli % clasg ( g )% group , switch = '--version' ). and . cli % defined ( group = cli % clasg ( g )% group , switch = '-v' ))) & call cli % add ( pref = prefd , & group_index = g , & switch = '--version' , & switch_ab = '-v' , & help = 'Print version' , & required = . false ., & def = '' , & act = 'print_version' ) enddo endif ! add hidden CLA '--' for getting the rid of eventual trailing CLAs garbage do g = 0 , size ( cli % clasg , dim = 1 ) - 1 if (. not . cli % defined ( group = cli % clasg ( g )% group , switch = '--' )) & call cli % add ( pref = prefd , & group_index = g , & switch = '--' , & required = . false ., & hidden = . true ., & nargs = '*' , & def = '' , & act = 'store' ) enddo ! parsing passed CLAs grouping in indexes if ( present ( args )) then call cli % get_args ( args = args , ai = ai ) else call cli % get_args ( ai = ai ) endif ! checking CLI consistency call cli % check ( pref = prefd ) if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! parsing cli do g = 0 , size ( ai , dim = 1 ) - 1 if ( ai ( g , 1 ) > 0 ) call cli % clasg ( g )% parse ( pref = prefd , args = cli % args ( ai ( g , 1 ): ai ( g , 2 ))) cli % error = cli % clasg ( g )% error if ( cli % error /= 0 ) exit enddo if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! trapping the special cases of version/help printing if ( cli % error == status_clasg_print_v ) then call cli % print_version ( pref = prefd ) stop elseif ( cli % error == status_clasg_print_h ) then write ( stdout , '(A)' ) cli % usage ( pref = prefd , g = g ) stop endif ! checking if all required CLAs have been passed do g = 0 , size ( ai , dim = 1 ) - 1 call cli % clasg ( g )% check_required ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( cli % error > 0 ) exit enddo if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! check mutually exclusive interaction call cli % check_m_exclusive ( pref = prefd ) if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse","tags":"","loc":"proc/parse.html","title":"parse – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_clasg_indexes(cli, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Na Number of command line arguments passed. integer(kind=I4P), public :: a Counter for CLAs. integer(kind=I4P), public :: aa Counter for CLAs. integer(kind=I4P), public :: g Counter for CLAs group. logical, public :: found Flag for inquiring if a named group is found. Source Code subroutine get_clasg_indexes ( cli , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. integer ( I4P ) :: g !< Counter for CLAs group. logical :: found !< Flag for inquiring if a named group is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( ai ( 0 : size ( cli % clasg , dim = 1 ) - 1 , 1 : 2 )) ai = 0 if ( allocated ( cli % args )) then Na = size ( cli % args , dim = 1 ) a = 0 found = . false . search_named : do while ( a < Na ) a = a + 1 if ( cli % defined_group ( group = trim ( cli % args ( a )), g = g )) then found = . true . cli % clasg ( g )% called = . true . ai ( g , 1 ) = a + 1 aa = a do while ( aa < Na ) aa = aa + 1 if ( cli % defined_group ( group = trim ( cli % args ( aa )))) then a = aa - 1 ai ( g , 2 ) = a exit else ai ( g , 2 ) = aa endif enddo elseif (. not . found ) then ai ( 0 , 2 ) = a endif enddo search_named if ( ai ( 0 , 2 ) > 0 ) then ai ( 0 , 1 ) = 1 cli % clasg ( 0 )% called = . true . elseif ( all ( ai == 0 )) then cli % clasg ( 0 )% called = . true . endif else cli % clasg ( 0 )% called = . true . endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_clasg_indexes","tags":"","loc":"proc/get_clasg_indexes.html","title":"get_clasg_indexes – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_args_from_string(cli, args, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from string. Calls proc~~get_args_from_string~~CallsGraph proc~get_args_from_string get_args_from_string none~sanitize_args sanitize_args proc~get_args_from_string->none~sanitize_args proc~tokenize tokenize proc~get_args_from_string->proc~tokenize none~sanitize_args->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=len_trim(args)), public :: argsd Dummy string containing command line arguments. character(len=len_trim(args)), public, allocatable :: toks (:) CLAs tokenized. integer(kind=I4P), public :: Nt Number of tokens. integer(kind=I4P), public :: Na Number of command line arguments passed. integer(kind=I4P), public :: a Counter for CLAs. integer(kind=I4P), public :: t Counter for tokens. integer(kind=I4P), public :: c Counter for characters inside tokens. Functions function sanitize_args(argsin, delimiter) result(sanitized) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: argsin Arguments string. character(len=*), intent(in) :: delimiter Delimiter enclosing string argument. Return Value character(len=len_trim(argsin)) Arguments string sanitized. Description Sanitize arguments string. Source Code subroutine get_args_from_string ( cli , args , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from string. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: args !< String containing command line arguments. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. character ( len = len_trim ( args )) :: argsd !< Dummy string containing command line arguments. character ( len = len_trim ( args )), allocatable :: toks (:) !< CLAs tokenized. integer ( I4P ) :: Nt !< Number of tokens. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: t !< Counter for tokens. integer ( I4P ) :: c !< Counter for characters inside tokens. #ifndef __GFORTRAN__ integer ( I4P ) :: length !< Maxium lenght of arguments string. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! prepare cli arguments list if ( allocated ( cli % args )) deallocate ( cli % args ) ! sanitize arguments string argsd = trim ( args ) if ( index ( args , \"'\" ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = \"'\" ) elseif ( index ( args , '\"' ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = '\"' ) endif ! tokenize arguments string; the previously sanitized white spaces inside tokens are restored call tokenize ( strin = argsd , delimiter = ' ' , toks = toks , Nt = Nt ) Na = 0 find_number_of_valid_arguments : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then Na = Na + 1 do c = 1 , len ( toks ( t )) if ( toks ( t )( c : c ) == \"'\" ) toks ( t )( c : c ) = \" \" enddo endif enddo find_number_of_valid_arguments if ( Na > 0 ) then ! allocate cli arguments list #ifdef __GFORTRAN__ allocate ( cli % args ( 1 : Na )) #else length = 0 find_longest_arg : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) length = max ( length , len_trim ( adjustl ( toks ( t )))) enddo find_longest_arg allocate ( character ( length ) :: cli % args ( 1 : Na )) #endif ! construct arguments list a = 0 get_args : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then a = a + 1 cli % args ( a ) = trim ( adjustl ( toks ( t ))) endif enddo get_args endif call cli % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- contains function sanitize_args ( argsin , delimiter ) result ( sanitized ) !------------------------------------------------------------------------------------------------------------------------------- !< Sanitize arguments string. !< !< Substitute white spaces enclosed into string-arguments, i.e. 'string argument with spaces...' or !< \"string argument with spaces...\" with a safe equivalent for tokenization against white spaces, i.e. the finally tokenized !< string is string'argument'with'spaces... !< !< @note The white spaces are reintroduce later. !------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: argsin !< Arguments string. character ( * ), intent ( IN ) :: delimiter !< Delimiter enclosing string argument. character ( len = len_trim ( argsin )) :: sanitized !< Arguments string sanitized. character ( len = len_trim ( argsin )), allocatable :: tok (:) !< Arguments string tokens. integer ( I4P ) :: Nt !< Number of command line arguments passed. integer ( I4P ) :: t , tt !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- call tokenize ( strin = trim ( argsin ), delimiter = delimiter , toks = tok , Nt = Nt ) do t = 2 , Nt , 2 do tt = 1 , len_trim ( adjustl ( tok ( t ))) if ( tok ( t )( tt : tt ) == ' ' ) tok ( t )( tt : tt ) = \"'\" enddo enddo sanitized = '' do t = 1 , Nt sanitized = trim ( sanitized ) // \" \" // trim ( adjustl ( tok ( t ))) enddo sanitized = trim ( adjustl ( sanitized )) return !------------------------------------------------------------------------------------------------------------------------------- endfunction sanitize_args endsubroutine get_args_from_string","tags":"","loc":"proc/get_args_from_string.html","title":"get_args_from_string – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_args_from_invocation(cli, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from CLI invocation. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Na Number of command line arguments passed. character(len=max_val_len), public :: switch Switch name. integer(kind=I4P), public :: a Counter for CLAs. integer(kind=I4P), public :: aa Counter for CLAs. Source Code subroutine get_args_from_invocation ( cli , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from CLI invocation. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. character ( max_val_len ) :: switch !< Switch name. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( cli % args )) deallocate ( cli % args ) Na = command_argument_count () if ( Na > 0 ) then #ifdef __GFORTRAN__ allocate ( cli % args ( 1 : Na )) #else aa = 0 find_longest_arg : do a = 1 , Na call get_command_argument ( a , switch ) aa = max ( aa , len_trim ( switch )) enddo find_longest_arg allocate ( character ( aa ) :: cli % args ( 1 : Na )) #endif get_args : do a = 1 , Na call get_command_argument ( a , switch ) cli % args ( a ) = trim ( adjustl ( switch )) enddo get_args endif call cli % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_args_from_invocation","tags":"","loc":"proc/get_args_from_invocation.html","title":"get_args_from_invocation – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA (single) value from CLAs list parsed. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( cli % error == 0. and . cli % clasg ( g )% called ) then if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( position )% error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_cli","tags":"","loc":"proc/get_cla_cli.html","title":"get_cla_cli – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val (1:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_cli","tags":"","loc":"proc/get_cla_list_cli.html","title":"get_cla_list_cli – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_R16P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_R16P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P_cli","tags":"","loc":"proc/get_cla_list_varying_r16p_cli.html","title":"get_cla_list_varying_R16P_cli – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_R8P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_R8P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P_cli","tags":"","loc":"proc/get_cla_list_varying_r8p_cli.html","title":"get_cla_list_varying_R8P_cli – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_R4P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_R4P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P_cli","tags":"","loc":"proc/get_cla_list_varying_r4p_cli.html","title":"get_cla_list_varying_R4P_cli – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_I8P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_I8P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P_cli","tags":"","loc":"proc/get_cla_list_varying_i8p_cli.html","title":"get_cla_list_varying_I8P_cli – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_I4P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_I4P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P_cli","tags":"","loc":"proc/get_cla_list_varying_i4p_cli.html","title":"get_cla_list_varying_I4P_cli – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_I2P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_I2P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P_cli","tags":"","loc":"proc/get_cla_list_varying_i2p_cli.html","title":"get_cla_list_varying_I2P_cli – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_I1P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_I1P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P_cli","tags":"","loc":"proc/get_cla_list_varying_i1p_cli.html","title":"get_cla_list_varying_I1P_cli – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_logical_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, logical. Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_logical_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, logical. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical_cli","tags":"","loc":"proc/get_cla_list_varying_logical_cli.html","title":"get_cla_list_varying_logical_cli – Shu-Osher-shock-tube-problem"},{"text":"private subroutine get_cla_list_varying_char_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, character. Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_char_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, character. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char_cli","tags":"","loc":"proc/get_cla_list_varying_char_cli.html","title":"get_cla_list_varying_char_cli – Shu-Osher-shock-tube-problem"},{"text":"private subroutine print_usage(cli, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Description Print correct usage of CLI. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code subroutine print_usage ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage of CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref write ( stdout , '(A)' ) cli % usage ( pref = prefd , g = 0 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_usage","tags":"","loc":"proc/print_usage.html","title":"print_usage – Shu-Osher-shock-tube-problem"},{"text":"private subroutine save_man_page(cli, man_file, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: man_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Save man page build on the CLI. Calls proc~~save_man_page~~CallsGraph proc~save_man_page save_man_page strz strz proc~save_man_page->strz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: man Man page. integer(kind=I4P), public :: idate (1:8) Integer array for handling the date. integer(kind=I4P), public :: e Counter. integer(kind=I4P), public :: u Unit file handler. character(len=*), public, parameter :: month (12) = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"] Source Code subroutine save_man_page ( cli , man_file , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save man page build on the CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: man_file !< Output file name for saving man page. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: man !< Man page. integer ( I4P ) :: idate ( 1 : 8 ) !< Integer array for handling the date. integer ( I4P ) :: e !< Counter. integer ( I4P ) :: u !< Unit file handler. character ( * ), parameter :: month ( 12 ) = [ \"Jan\" ,& \"Feb\" ,& \"Mar\" ,& \"Apr\" ,& \"May\" ,& \"Jun\" ,& \"Jul\" ,& \"Aug\" ,& \"Sep\" ,& \"Oct\" ,& \"Nov\" ,& \"Dec\" ] !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call date_and_time ( values = idate ) man = '.TH ' // cli % progname // ' \"1\" \"' // month ( idate ( 2 )) // ' ' // trim ( adjustl ( strz ( 4 , idate ( 1 )))) // '\" \"version ' // cli % version // & '\" \"' // cli % progname // ' Manual\"' man = man // new_line ( 'a' ) // '.SH NAME' man = man // new_line ( 'a' ) // cli % progname // ' - manual page for ' // cli % progname // ' version ' // cli % version man = man // new_line ( 'a' ) // '.SH SYNOPSIS' man = man // new_line ( 'a' ) // '.B ' // cli % progname // new_line ( 'a' ) // trim ( adjustl ( cli % signature ())) if ( cli % description /= '' ) man = man // new_line ( 'a' ) // '.SH DESCRIPTION' // new_line ( 'a' ) // cli % description if ( cli % clasg ( 0 )% Na > 0 ) then man = man // new_line ( 'a' ) // '.SH OPTIONS' man = man // new_line ( 'a' ) // cli % usage ( no_header = . true ., no_examples = . true ., no_epilog = . true ., g = 0 ) endif if ( allocated ( cli % examples )) then man = man // new_line ( 'a' ) // '.SH EXAMPLES' man = man // new_line ( 'a' ) // '.PP' man = man // new_line ( 'a' ) // '.nf' man = man // new_line ( 'a' ) // '.RS' do e = 1 , size ( cli % examples , dim = 1 ) man = man // new_line ( 'a' ) // trim ( cli % examples ( e )) enddo man = man // new_line ( 'a' ) // '.RE' man = man // new_line ( 'a' ) // '.fi' man = man // new_line ( 'a' ) // '.PP' endif if ( cli % authors /= '' ) man = man // new_line ( 'a' ) // '.SH AUTHOR' // new_line ( 'a' ) // cli % authors if ( cli % license /= '' ) man = man // new_line ( 'a' ) // '.SH COPYRIGHT' // new_line ( 'a' ) // cli % license open ( newunit = u , file = trim ( adjustl ( man_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) man else write ( u , \"(A)\" ) man endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_man_page","tags":"","loc":"proc/save_man_page.html","title":"save_man_page – Shu-Osher-shock-tube-problem"},{"text":"private elementalsubroutine assign_cli(lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Interface ), intent(in) :: rhs Right hand side. Source Code elemental subroutine assign_cli ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Interface ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Interface members if ( allocated ( rhs % clasg )) lhs % clasg = rhs % clasg if ( allocated ( rhs % examples )) lhs % examples = rhs % examples lhs % disable_hv = rhs % disable_hv return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cli","tags":"","loc":"proc/assign_cli.html","title":"assign_cli – Shu-Osher-shock-tube-problem"},{"text":"Uses: IR_Precision foodie wenoof module~~type_euler_1d~~UsesGraph module~type_euler_1d type_euler_1D IR_Precision IR_Precision IR_Precision->module~type_euler_1d module~foodie foodie module~foodie->module~type_euler_1d module~wenoof wenoof module~wenoof->module~type_euler_1d module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_moulton iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta module~type_weno_interpolator_upwind type_weno_interpolator_upwind module~type_weno_interpolator_upwind->module~wenoof module~type_weno_interpolator type_weno_interpolator module~type_weno_interpolator->module~wenoof module~type_weno_interpolator->module~type_weno_interpolator_upwind module~wenoof_kinds wenoof_kinds module~wenoof_kinds->module~type_weno_interpolator_upwind module~wenoof_kinds->module~type_weno_interpolator var panmoduletype_euler_1dUsesGraph = svgPanZoom('#moduletype_euler_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Euler 1D field that is a concrete extension of the abstract integrand type. Used By module~~type_euler_1d~~UsedByGraph module~type_euler_1d type_euler_1D program~integrate_euler_1d integrate_euler_1D module~type_euler_1d->program~integrate_euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: euler_1D Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type( weno_interpolator_upwind ), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalizations Procedures final :: finalize Destroy field. Type-Bound Procedures procedure, public, pass(self) :: init Init field. procedure, public, pass(self) :: destroy Destroy field. procedure, public, pass(self) :: output Extract Euler field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. procedure, public, pass(lhs) :: local_error => euler_local_error ||euler-euler||. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. procedure, public, pass(lhs) :: add => add_euler Euler + Euler operator. procedure, public, pass(lhs) :: sub => sub_euler Euler - Euler. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. Description Euler 1D PDEs system field. Functions private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). private purefunction compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. private function dEuler_dt (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. private function euler_local_error (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 euler approximations. private function euler_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. private function euler_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. private function real_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. private function add_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. private function sub_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. private purefunction primitive2conservative (self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. private purefunction conservative2primitive (self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. private elementalfunction p (r, a, g) result(pressure) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Description Compute the pressure for an ideal calorically perfect gas. private elementalfunction r (p, a, g) result(density) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Description Compute the density for an ideal calorically perfect gas. private elementalfunction a (p, r, g) result(ss) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Description Compute the speed of sound for an ideal calorically perfect gas. private elementalfunction E (p, r, u, g) result(energy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Description Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n private elementalfunction H (p, r, u, g) result(entalpy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Description Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Subroutines private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. private puresubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. Description Destroy field. private subroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. private subroutine euler_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. private puresubroutine impose_boundary_conditions (self, primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. private puresubroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. private subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( euler_1D ), intent(inout) :: self Euler field. Description Destroy field. private puresubroutine compute_inter_states (r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Description Compute inter states (23*-states) from state1 and state4.","tags":"","loc":"module/type_euler_1d.html","title":"type_euler_1D – Shu-Osher-shock-tube-problem"},{"text":"Uses: foodie_kinds module~~foodie_adt_integrand~~UsesGraph module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_adt_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define the abstract type integrand for building FOODIE ODE integrators. Used By module~~foodie_adt_integrand~~UsedByGraph module~foodie_adt_integrand foodie_adt_integrand module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie foodie module~foodie_adt_integrand->module~foodie module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_adt_integrandUsedByGraph = svgPanZoom('#modulefoodie_adt_integrandUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private subroutine assignment_integrand (lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function time_derivative (self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function local_error_operator (lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 solution approximations. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function integrand_op_real (lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function real_op_integrand (lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function symmetric_operator (lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. Derived Types type, public, abstract :: integrand Components Type Visibility Attributes Name Initial class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. Type-Bound Procedures procedure(time_derivative), public, pass(self), deferred :: t Time derivative, residuals. procedure(local_error_operator), public, pass(lhs), deferred :: local_error ||integrand - integrand||. procedure(symmetric_operator), public, pass(lhs), deferred :: integrand_multiply_integrand Integrand * integrand operator. procedure(integrand_op_real), public, pass(lhs), deferred :: integrand_multiply_real Integrand * real operator. procedure(real_op_integrand), public, pass(rhs), deferred :: real_multiply_integrand Real * integrand operator. procedure(symmetric_operator), public, pass(lhs), deferred :: add Integrand + integrand operator. procedure(symmetric_operator), public, pass(lhs), deferred :: sub Integrand - integrand operator. procedure(assignment_integrand), public, pass(lhs), deferred :: assign_integrand Integrand = integrand. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. generic, public :: operator(+) => add Overloading + operator. generic, public :: operator(-) => sub Overloading - operator. generic, public :: operator(*) => integrand_multiply_integrand, real_multiply_integrand, integrand_multiply_real Overloading * operator. generic, public :: assignment(=) => assign_integrand Overloading = assignament. Description Abstract type for building FOODIE ODE integrators.","tags":"","loc":"module/foodie_adt_integrand.html","title":"foodie_adt_integrand – Shu-Osher-shock-tube-problem"},{"text":"Uses: foodie_kinds foodie_adt_integrand module~~foodie_integrator_tvd_runge_kutta~~UsesGraph module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_adt_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. The integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP)\n one. The schemes are explicit and defined through the Butcher's table syntax, see[1] . Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form:  U&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta&#94;s K&#94;s  where Ns is the number of stages used and K&#94;s is the s&#94;{th} stage computed as:  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are\n given in the Butcher table form: gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns}\n  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns}\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns}\n ------------|-------------------------------------------------------------\n             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: gamma&#94;1    | 0                 0                 ...        0\n  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0\n ------------|-------------------------------------------------------------\n             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} Moreover the following relation always holds:\n  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: 1 stage, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. 0 | 0\n ---|---\n    | 1 2 stages, SSP, 2nd order This scheme is an optmial SSP(2, 2) without low-storage algorithm, see [2]. 0 | 0     0\n  1 | 1     0\n ---|-----------\n    | 1/2   1/2 3 stages, SSP, 3rd order This scheme is an optmial SSP(3, 3) without low-storage algorithm, see [2]. 0   | 0     0     0\n  1   | 1     0     0\n  1/2 | 1/4   1/4   0\n -----|-----------------\n      | 1/6   1/6   1/3 5 stages, SSP, 4th order This scheme is an optmial SSP(5, 4) without low-storage algorithm, see [2]. 0                | 0                  0                  0                  0                  0\n  0.39175222700392 | 0.39175222700392   0                  0                  0                  0\n  0.58607968896780 | 0.21766909633821   0.36841059262959   0                  0                  0\n  0.47454236302687 | 0.08269208670950   0.13995850206999   0.25189177424738   0                  0\n  0.93501063100924 | 0.06796628370320   0.11503469844438   0.20703489864929   0.54497475021237   0\n ------------------|---------------------------------------------------------------------------------------------\n                   | 0.14681187618661   0.24848290924556   0.10425883036650   0.27443890091960   0.22600748319395 Bibliography [1] Coefficients for the study of Runge-Kutta integration processes , Butcher, J.C., J. Austral. Math. Soc., Vol. 3,\n pages: 185–201, 1963. [2] High Order Strong Stability Preserving Time Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of\n Scientific Computing, vol. 38, N. 3, 2009, pp. 251-289. Used By module~~foodie_integrator_tvd_runge_kutta~~UsedByGraph module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie foodie module~foodie_integrator_tvd_runge_kutta->module~foodie program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d->program~integrate_euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: tvd_runge_kutta_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Finalizations Procedures final :: finalize Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. Description FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. Subroutines private elementalsubroutine init (self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. private subroutine integrate (self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object.","tags":"","loc":"module/foodie_integrator_tvd_runge_kutta.html","title":"foodie_integrator_tvd_runge_kutta – Shu-Osher-shock-tube-problem"},{"text":"Uses: foodie_kinds foodie_adt_integrand module~~foodie_integrator_euler_explicit~~UsesGraph module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_adt_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Forward Explicit Euler scheme implemented is:  U&#94;{n+1} = U&#94;n +\\Delta t R(t, U&#94;n)  Note The value of \\Delta t must be provided, it not being computed by the integrator. Used By module~~foodie_integrator_euler_explicit~~UsedByGraph module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie foodie module~foodie_integrator_euler_explicit->module~foodie program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d->program~integrate_euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: euler_explicit_integrator Type-Bound Procedures procedure, public, nopass :: integrate Integrate integrand field. Description FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. Subroutines private subroutine integrate (U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. Description Integrate field with explicit Euler scheme, 1st order.","tags":"","loc":"module/foodie_integrator_euler_explicit.html","title":"foodie_integrator_euler_explicit – Shu-Osher-shock-tube-problem"},{"text":"FOODIE kinds: definition of reals and integer kind parameters of FOODIE library. Used By module~~foodie_kinds~~UsedByGraph module~foodie_kinds foodie_kinds module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie foodie module~foodie_adt_integrand->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton->module~foodie program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_kindsUsedByGraph = svgPanZoom('#modulefoodie_kindsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: R8P = selected_real_kind(15,307) 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6,37) 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision.","tags":"","loc":"module/foodie_kinds.html","title":"foodie_kinds – Shu-Osher-shock-tube-problem"},{"text":"Uses: foodie_kinds foodie_adt_integrand module~~foodie_integrator_leapfrog~~UsesGraph module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_adt_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the leapfrog class scheme implemented (see [3]) is:  U&#94;{n+2} = U&#94;{n} + 2\\Delta t \\cdot R(t&#94;{n+1}, U&#94;{n+1})  Optionally, the Robert-Asselin-Williams (RAW) filter (see [3]) is applied to the computed integration steps:\n  \\Delta = \\frac{\\nu}{2}(U&#94;{n} - 2 U&#94;{n+1} + U&#94;{n+2}) \n  U&#94;{n+1} = U&#94;{n+1} + \\Delta * \\alpha \n  U&#94;{n+2} = U&#94;{n+2} + \\Delta * (\\alpha-1) \n Note that for \\alpha=1 the filter reverts back to the standard Robert-Asselin scheme.\n The filter coefficients should be taken as \\nu \\in (0,1] and \\alpha \\in (0.5,1]. The default values are \\nu=0.01 \\alpha=0.53 Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit. The filter coefficients \\nu,\\,\\alpha  define the actual scheme. Bibliography [1] The integration of a low order spectral form of the primitive meteorological equations , Robert, A. J., J. Meteor. Soc.\n Japan,vol. 44, pages 237–245, 1966. [2] Frequency filter for time integrations , Asselin, R., Monthly Weather Review, vol. 100, pages 487–490, 1972. [3] The RAW filter: An improvement to the Robert–Asselin filter in semi-implicit integrations , Williams, P.D., Monthly\n Weather Review, vol. 139(6), pages 1996–2007, June 2011. Used By module~~foodie_integrator_leapfrog~~UsedByGraph module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie foodie module~foodie_integrator_leapfrog->module~foodie program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d->program~integrate_euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: leapfrog_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), private :: nu = 0.01_R_P Robert-Asselin filter coefficient. real(kind=R_P), private :: alpha = 0.53_R_P Robert-Asselin-Williams filter coefficient. Type-Bound Procedures procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. Description FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Subroutines private elementalsubroutine init (self, nu, alpha) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(inout) :: self LF integrator. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. Description Create the actual leapfrog integrator: initialize the filter coefficient. private subroutine integrate (self, U, previous, Dt, t, filter) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(in) :: self LF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:2) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. class( integrand ), intent(inout), optional :: filter Filter field displacement. Description Integrate field with leapfrog class scheme.","tags":"","loc":"module/foodie_integrator_leapfrog.html","title":"foodie_integrator_leapfrog – Shu-Osher-shock-tube-problem"},{"text":"Uses: foodie_kinds foodie_adt_integrand module~~foodie_integrator_adams_bashforth~~UsesGraph module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_adt_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 4rd order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Bashforth class scheme implemented is:  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s}{ b_s \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  where N_s is the number of previous steps considered. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit. The coefficients b_s define the actual scheme, that is selected accordingly to the number of steps used. Currently, the following schemes are available: 1 step, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order.\n The b coefficient is:\n b = \\left[b_1\\right] = \\left[1\\right]\n The scheme is:\n  U&#94;{n+1} = U&#94;n + \\Delta t R(t&#94;n,U&#94;n)  2 steps This scheme is 2nd order.\n The b coefficients are:\n b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] =\n       \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+2} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right]  3 steps This scheme is 3rd order.\n The b coefficients are:\n b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] =\n       \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+3} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1})\n +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right]  4 steps This scheme is 4th order.\n The b coefficients are:\n b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 & b_4 \\end{array}} \\right] =\n       \\left[ {\\begin{array}{*{20}{c}} -\\frac{9}{24} & \\frac{37}{24} & -\\frac{59}{24} & \\frac{55}{24} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+4} = U&#94;{n+3} +\\Delta t \\left[ \\frac{55}{24}R(t&#94;{n+3}, U&#94;{n+3}) - \\frac{59}{24}R(t&#94;{n+2}, U&#94;{n+2})\n +\\frac{37}{24} R(t&#94;{n+1}, U&#94;{n+1}) - \\frac{9}{24} R(t&#94;{n}, U&#94;{n}) \\right]  Bibliography Used By module~~foodie_integrator_adams_bashforth~~UsedByGraph module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_integrator_adams_bashforth_moulton->module~foodie module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_adams_bashforthUsedByGraph = svgPanZoom('#modulefoodie_integrator_adams_bashforthUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: adams_bashforth_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps. real(kind=R_P), private, allocatable :: b (:) b coefficients. Finalizations Procedures final :: finalize Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, pass(self) :: update_previous Cyclic update previous time steps. Description FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 4rd order accurate. Subroutines private elementalsubroutine init (self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth integrator: initialize the b coefficients. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Destroy the integrator. private subroutine integrate (self, U, previous, Dt, t, autoupdate) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Description Integrate field with Adams-Bashforth class scheme. private subroutine update_previous (self, U, previous) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Description Cyclic update previous time steps. private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Finalize object.","tags":"","loc":"module/foodie_integrator_adams_bashforth.html","title":"foodie_integrator_adams_bashforth – Shu-Osher-shock-tube-problem"},{"text":"Uses: foodie_kinds foodie_adt_integrand module~~foodie_integrator_adams_moulton~~UsesGraph module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_adt_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 4rd order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Moulton class scheme implemented is:  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s-1}{ b_s \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } +\n b_{N_S}\\cdot R(t&#94;{n+N_s}, U&#94;{n+N_s}) \\right]  where N_s is the number of previous steps considered. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are implicit. The coefficients b_s define the actual scheme, that is selected accordingly to the number of steps used. Currently, the following schemes are available: 0 step, Implicit Backward Euler, 1st order This scheme is TVD and reverts to Implicit Backward Euler, it being 1st order.\n The b coefficient is:\n b = \\left[b_0\\right] = \\left[1\\right]\n The scheme is:\n  U&#94;{n} = U&#94;{n-1} + \\Delta t R(t&#94;{n},U&#94;{n})  1 step This scheme is 2nd order.\n The b coefficients are:\n b = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 \\end{array}} \\right] =\n       \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2} & \\frac{1}{2} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+1} = U&#94;{n} +\\Delta t \\left[ \\frac{1}{2} R(t&#94;{n+1}, U&#94;{n+1})+\\frac{1}{2} R(t&#94;{n}, U&#94;{n}) \\right]  2 steps This scheme is 3rd order.\n The b coefficients are:\n b = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 \\end{array}} \\right] =\n       \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{12} & \\frac{2}{3} & \\frac{5}{12} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+2} = U&#94;{n+1} +\\Delta t \\left[ \\frac{5}{12}R(t&#94;{n+2}, U&#94;{n+2}) + \\frac{2}{3}R(t&#94;{n+1}, U&#94;{n+1})\n -\\frac{1}{12} R(t&#94;{n}, U&#94;{n})  \\right]  3 steps This scheme is 4th order.\n The b coefficients are:\n b = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 & b_3 \\end{array}} \\right] =\n       \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{24} & -\\frac{5}{24} & \\frac{19}{24} & \\frac{9}{24} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+3} = U&#94;{n+2} +\\Delta t \\left[ \\frac{9}{24}R(t&#94;{n+3}, U&#94;{n+3}) + \\frac{19}{24}R(t&#94;{n+2}, U&#94;{n+2})\n -\\frac{5}{24} R(t&#94;{n+1}, U&#94;{n+1}) + \\frac{1}{24} R(t&#94;{n}, U&#94;{n}) \\right]  Bibliography Used By module~~foodie_integrator_adams_moulton~~UsedByGraph module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_adams_moultonUsedByGraph = svgPanZoom('#modulefoodie_integrator_adams_moultonUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: adams_moulton_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = -1 Number of time steps. real(kind=R_P), private, allocatable :: b (:) b coefficients. Finalizations Procedures final :: finalize Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, pass(self) :: update_previous Cyclic update previous time steps. Description FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 3rd order accurate. Subroutines private elementalsubroutine init (self, steps) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Moulton integrator: initialize the b coefficients. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. Description Destroy the integrator. private subroutine integrate (self, U, previous, Dt, t, iterations, autoupdate) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Description Integrate field with Adams-Moulton class scheme. private subroutine update_previous (self, U, previous) Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Description Cyclic update previous time steps. private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( adams_moulton_integrator ), intent(inout) :: self AB integrator. Description Finalize object.","tags":"","loc":"module/foodie_integrator_adams_moulton.html","title":"foodie_integrator_adams_moulton – Shu-Osher-shock-tube-problem"},{"text":"Uses: iso_fortran_env foodie_kinds foodie_adt_integrand module~~foodie_integrator_low_storage_runge_kutta~~UsesGraph module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. The integrators provided have the low storage property allowing for an efficient use of the memory.\n Following Williamson approach [1], the LSRK(5,4)2N (solution 3) scheme of Carpenter et al. [2] is implemented. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form: \\begin{matrix}\n K_1 = U&#94;n \\\\\n K_2 = 0 \\\\\n\\left.\\begin{matrix}\n K_2 = A_s K_2 + \\Delta t R(t&#94;n + C_s \\Delta t, K_1) \\\\\n K_1 = K_1 + B_s K_2\n\\end{matrix}\\right\\} s=1,2,...N_s\\\\\nU&#94;{n+1} = K_1\n\\end{matrix} where Ns is the number of stages used and K_1, K_2 are the 2 registers used for stages computation. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus A_1=C_1=0. The coefficients A_s, B_s, C_s are given in the Williamson low storage table\n form. The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: 1 stage, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. It is not a real low storage scheme, this being\n meaningless for a first order scheme. However it is added for safety reason. Stage A B C 1 0 1 0 5 stages, SSP, 4th order This scheme is a low storage RK(5, 4), based on the solution 3 proposed in [2]. Stage A B C 1 0 1432997174477/9575080441755 0 2 -567301805773 /1357537059087 5161836677717/13612068292357 1432997174477/9575080441755 3 -2404267990393/2016746695238 1720146321549/2090206949498 2526269341429/6820363962896 4 -3550918686646/2091501179385 3134564353537/4481467310338 2006345519317/3224310063776 5 -1275806237668/842570457699 2277821191437/14882151754819 2802321613138/2924317926251 6 stages, 4th order This scheme is a low storage RK(6, 4), by [3]. Stage A B C 1 0 0.122000000000 0 2 -0.691750960670 0.477263056358 0.122000000000 3 -1.727127405211 0.381941220320 0.269115878630 4 -0.694890150986 0.447757195744 0.447717183551 5 -1.039942756197 0.498614246822 0.749979795490 6 -1.531977447611 0.186648570846 0.898555413085 7 stages, 4th order This scheme is a low storage RK(7, 4), by [3]. Stage A B C 1 0 0.117322146869 0 2 -0.647900745934 0.503270262127 0.117322146869 3 -2.704760863204 0.233663281658 0.294523230758 4 -0.460080550118 0.283419634625 0.305658622131 5 -0.500581787785 0.540367414023 0.582864148403 6 -1.906532255913 0.371499414620 0.858664273599 7 -1.450000000000 0.136670099385 0.868664273599 12 stages, 4th order This scheme is a low storage RK(12, 4), by [4]. Stage A B C 1 0 0.0650008435125904 0 2 -0.0923311242368072 0.0161459902249842 0.0650008435125904 3 -0.9441056581158819 0.5758627178358159 0.0796560563081853 4 -4.3271273247576394 0.1649758848361671 0.1620416710085376 5 -2.1557771329026072 0.3934619494248182 0.2248877362907778 6 -0.9770727190189062 0.0443509641602719 0.2952293985641261 7 -0.7581835342571139 0.2074504268408778 0.3318332506149405 8 -1.7977525470825499 0.6914247433015102 0.4094724050198658 9 -2.6915667972700770 0.3766646883450449 0.6356954475753369 10 -4.6466798960268143 0.0757190350155483 0.6806551557645497 11 -0.1539613783825189 0.2027862031054088 0.7143773712418350 12 -0.5943293901830616 0.2167029365631842 0.9032588871651854 13 stages, 4th order This scheme is a low storage RK(13, 4), by [4]. Stage A B C 1 0 0.0271990297818803 0 2 -0.6160178650170565 0.1772488819905108 0.0271990297818803 3 -0.4449487060774118 0.0378528418949694 0.0952594339119365 4 -1.0952033345276178 0.6086431830142991 0.1266450286591127 5 -1.2256030785959187 0.2154313974316100 0.1825883045699772 6 -0.2740182222332805 0.2066152563885843 0.3737511439063931 7 -0.0411952089052647 0.0415864076069797 0.5301279418422206 8 -0.1797084899153560 0.0219891884310925 0.5704177433952291 9 -1.1771530652064288 0.9893081222650993 0.5885784947099155 10 -0.4078831463120878 0.0063199019859826 0.6160769826246714 11 -0.8295636426191777 0.3749640721105318 0.6223252334314046 12 -4.7895970584252288 1.6080235151003195 0.6897593128753419 13 -0.6606671432964504 0.0961209123818189 0.9126827615920843 14 stages, 4th order This scheme is a low storage RK(14, 4), by [4]. Stage A B C 1 0 0.0367762454319673 0 2 -0.7188012108672410 0.3136296607553959 0.0367762454319673 3 -0.7785331173421570 0.1531848691869027 0.1249685262725025 4 -0.0053282796654044 0.0030097086818182 0.2446177702277698 5 -0.8552979934029281 0.3326293790646110 0.2476149531070420 6 -3.9564138245774565 0.2440251405350864 0.2969311120382472 7 -1.5780575380587385 0.3718879239592277 0.3978149645802642 8 -2.0837094552574054 0.6204126221582444 0.5270854589440328 9 -0.7483334182761610 0.1524043173028741 0.6981269994175695 10 -0.7032861106563359 0.0760894927419266 0.8190890835352128 11 0.0013917096117681 0.0077604214040978 0.8527059887098624 12 -0.0932075369637460 0.0024647284755382 0.8604711817462826 13 -0.9514200470875948 0.0780348340049386 0.8627060376969976 14 -7.1151571693922548 5.5059777270269628 0.8734213127600976 Bibliography [1] Low-Storage Runge-Kutta Schemes , J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48–56. [2] Fourth-Order 2N-Storage Runge-Kutta Schemes , Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112,\n June 1994. [3] High-accuracy large-step explicit Runge–Kutta (HALE-RK) schemes for computational aeroacoustics , Vasanth Allampalli and\n Ray Hixon and M. Nallasamy and Scott D. Sawyer, Journal of Computational Physics, vol. 228, 2009, pp. 3837–3850. [4] Efficient low-storage Runge–Kutta schemes with optimized stability regions , Jens Niegemann and Richard Diehl and Kurt\n Busch, Journal of Computational Physics, vol. 231, 2012, pp. 364–372. Used By module~~foodie_integrator_low_storage_runge_kutta~~UsedByGraph module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d->program~integrate_euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: ls_runge_kutta_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: A (:) Low storage A coefficients. real(kind=R_P), public, allocatable :: B (:) Low storage B coefficients. real(kind=R_P), public, allocatable :: C (:) Low storage C coefficients. Finalizations Procedures final :: finalize Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. Description FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. Subroutines private subroutine init (self, stages) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' low storage table coefficients. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. private subroutine integrate (self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:2) Runge-Kutta registers [1:2]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit low storage Runge-Kutta scheme. private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object.","tags":"","loc":"module/foodie_integrator_low_storage_runge_kutta.html","title":"foodie_integrator_low_storage_runge_kutta – Shu-Osher-shock-tube-problem"},{"text":"Uses: foodie_adt_integrand foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_moulton foodie_integrator_emd_runge_kutta foodie_integrator_euler_explicit foodie_integrator_leapfrog foodie_integrator_low_storage_runge_kutta foodie_integrator_tvd_runge_kutta module~~foodie~~UsesGraph module~foodie foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_moulton iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta var panmodulefoodieUsesGraph = svgPanZoom('#modulefoodieUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. FOODIE is a KISS library for solving systems of Ordinary Differential Equation (ODE) into the Initial Values Problems (IVP)\n contest. The mathematical formulation of the problem is: U_t = R(t,U)\n U_0 = F(0) where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function and F is the (vectorial) initial conditions function. FOODIE is aimed to the time-like integration of the above system of ODE. To this aim, different numerical schemes are provided: explicit Adams-Bashforth class of schemes: 1 step, namely the explicit forward Euler scheme, 1st order accurate; 2 steps, 2nd order accurate; 3 steps, 3rd order accurate; 4 steps, 4th order accurate; forward explicit Euler scheme, a 1st order accurate; explicit Leapfrog : Unfiltered, 2nd order accurate, (mostly) unstable; Robert-Asselin filtered, 1st order accurate; Robert-Asselin-Williams filter, 2nd order accurate; explicit low storage Runge-Kutta 2N class schemes: LS(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; LS(5,4): 5 stages, 4th order accurate; explicit TVD or SSP Runge-Kutta class schemes: TVD(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; SSP(2,2): 2 stages, 2nd order accurate; SSP(3,3): 3 stages, 3rd order accurate; SSP(5,4): 5 stages, 4th order accurate; explicit embedded Runge-Kutta class schemes: DP(7,4): 7 stages, 4th order accurate, Dormand and Prince scheme; implicit Adams-Moulton class of schemes: 0 step, namely the implicit backward Euler scheme, 1st order accurate; 1 step, 2nd order accurate; 2 steps, 3rd order accurate; 3 steps, 4th order accurate; predictor-corrector Adams-Bashforth-Moulton class of schemes: P=AB(1)-C=AM(0) step, namely the explicit/implicit forward/backward Euler scheme, 1st order accurate; P=AB(2)-C=AM(1) step, 2nd order accurate; P=AB(3)-C=AM(2) steps, 3rd order accurate; P=AB(4)-C=AM(3) steps, 4th order accurate; Usage FOODIE schemes must be applied to only subclass extensions of the abstract class integrand . To use FOODIE you must: extend integrand abstract class provided by FOODIE implementing your concrete integrand field For example for the Lorenz' ODE system type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODIE integrand class. private real ( R_P ), dimension (:), allocatable :: state !< Solution vector. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivate, resiuduals function. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz oprator. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. ... endtype lorenz use one of the provided FOODIE integrator For example using the forward explicit Euler scheme to the above Lorenz' ODE system use foodie , only : euler_explicit_integrator use type_lorenz , only : lorenz type ( euler_explicit_integrator ) :: euler_integrator type ( lorenz ) :: attractor real :: dt = 0.01 do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt ) enddo Used By module~~foodie~~UsedByGraph module~foodie foodie program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d->program~integrate_euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"module/foodie.html","title":"foodie – Shu-Osher-shock-tube-problem"},{"text":"Uses: foodie_kinds foodie_adt_integrand module~~foodie_integrator_emd_runge_kutta~~UsesGraph module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_adt_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 6th order accurate. The integrators provided have the embedded pairs property allowing for automatic step size control.\n The schemes are explicit and defined through the extended Butcher's table syntax, see[1] . Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form:  U_p&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_p&#94;s K&#94;s \n  U_{p+1}&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_{p+1}&#94;s K&#94;s  p is the lower accuracy order scheme and p+1 is the higher one; Ns is the number of stages used and K&#94;s is\n the s&#94;{th} stage computed as:  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are\n given in the extended Butcher table form: gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns}\n  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns}\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns}\n ------------|-------------------------------------------------------------\n             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns}\n             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: gamma&#94;1    | 0                 0                 ...        0\n  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0\n ------------|-------------------------------------------------------------\n             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns}\n             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} Moreover the following relation always holds:\n  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: 2 stages, 2th order This scheme is due to Heun-Euler. 0  | 0\n  1  | 1     0\n ----------------\n     | 1/2   1/2\n     | 1      0 6 stages, 5th order This scheme is due to Cash and Karp, see [3]. 0    | 0\n  1/5    | 1/5\n  3/10 | 3/40            9/40\n  3/5    | 3/10          -9/10        6/5\n  1    | -11/54        5/2          -70/27      35/27\n  7/8    | 1631/55296    175/512      575/13824   44275/110592     253/4096     0\n ----------------------------------------------------------------------------------------\n       | 37/378        0           250/621      125/594          0            512/1771\n       | 2825/27648    0           18575/48384  13525/55296      277/14336    1/4 7 stages, 4th order This scheme is due to Dormand and Prince, see [1]. 0    | 0\n  1/5  | 1/5\n  3/10 | 3/40          9/40\n  4/5  | 44/45        -56/15        32/9\n  8/9  | 19372/6561   -25360/2187   64448/6561   -212/729\n  1    | 9017/3168    -355/33       46732/5247    49/176      -5103/18656\n  1    | 35/384        0            500/1113      125/192     -2187/6784      11/84      0\n --------------------------------------------------------------------------------------------\n       | 5179/57600    0            7571/16695    393/640     -92097/339200   187/2100   1/40\n       | 35/384        0            500/1113      125/192     -2187/6784      11/84      0 9 stages, 6th order This scheme is due to Calvo et al., see [2]. 0                 | 0\n  2/15              | 2/15\n  1/5               | 1/20                  3/20\n  3/10              | 3/40                  0                      9/40\n  14/25             | 86727015/196851553    -60129073/52624712     957436434/1378352377    83886832/147842441\n  19/25             | -86860849/45628967    111022885/25716487     108046682/101167669     -141756746/36005461\n  35226607/35688279 | 77759591/16096467     -49252809/6452555      -381680111/51572984     879269579/66788831\n  1                 | 237564263/39280295    -100523239/10677940    -265574846/27330247     317978411/18988713\n  1                 | 17572349/289262523    0                      57513011/201864250      15587306/354501571\n --------------------------------------------------------------------------------------------------------------\n                    | 17572349/289262523    0                      57513011/201864250      15587306/354501571\n                    | 15231665/510830334    0                      59452991/116050448      -28398517/122437738\n ...continued...\n  0                 |\n  2/15              |\n  1/5               |\n  3/10              |\n  14/25             |\n  19/25             | 73139862/60170633\n  35226607/35688279 | -90453121/33722162     111179552/157155827\n  1                 | -124494385/35453627    86822444/100138635     -12873523/724232625\n  1                 | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0\n -----------------------------------------------------------------------------------------------------------------------\n                    | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0\n                    | 56673824/137010559     68003849/426673583     7097631/37564021       -71226429/583093742    1/20 17 stages, 10th order This scheme is due to Feagin, see [4]. 0                        |  0\n  0.1                      |  0.1\n  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052\n  0.809036761204472681298  |  0.202259190301118170324  0                        0.606777570903354510974\n  0.309036761204472681298  |  0.184024714708643575149  0                        0.197966831227192369068\n  0.981074190219795268254  |  0.087900734020668133731  0                        0\n  0.833333333333333333333  |  0.085970050490246030218  0                        0\n  0.354017365856802376329  |  0.120930449125333720660  0                        0\n  0.882527661964732346425  |  0.110854379580391483508  0                        0\n  0.642615758240322548157  |  0.112054414752879004829  0                        0\n  0.357384241759677451842  |  0.113976783964185986138  0                        0\n  0.117472338035267653574  |  0.079831452828019604635  0                        0\n  0.833333333333333333333  |  0.985115610164857280120  0                        0\n  0.309036761204472681298  |  0.895080295771632891049  0                        0.197966831227192369068\n  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052  0\n  0.1                      |  0.1                      0                       -0.157178665799771163367\n  1                        |  0.181781300700095283888  0.675                    0.342758159847189839942\n ------------------------------------------------------------------------------------------------------\n                           |  0.033333333333333333333  0.025                    0.033333333333333333333\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  | -0.072954784731363262918\n  0.981074190219795268254  |  0.410459702520260645318  0.482713753678866489204\n  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -0.073185637507085073678\n  0.354017365856802376329  |  0                        0.260124675758295622809  0.032540262154909133015\n  0.882527661964732346425  |  0                        0                       -0.060576148825500558762\n  0.642615758240322548157  |  0                        0                       -0.144942775902865915672\n  0.357384241759677451842  |  0                        0                       -0.076881336420335693858\n  0.117472338035267653574  |  0                        0                       -0.052032968680060307651\n  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -1.378964865748435675821\n  0.309036761204472681298  | -0.072954784731363262918  0                       -0.851236239662007619739\n  0.539357840802981787532  |  0                       -0.777333643644968233538  0\n  0.1                      |  0                        0                        0\n  1                        |  0                        0.259111214548322744512 -0.358278966717952089048\n ------------------------------------------------------------------------------------------------------\n                           |  0                        0.05                     0\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  | -0.059578021181736100156\n  0.882527661964732346425  |  0.321763705601778390100  0.510485725608063031577\n  0.642615758240322548157  | -0.333269719096256706589  0.499269229556880061353  0.509504608929686104236\n  0.357384241759677451842  |  0.239527360324390649107  0.397774662368094639047  0.010755895687360745555\n  0.117472338035267653574  | -0.057695414616854888173  0.194781915712104164976  0.145384923188325069727\n  0.833333333333333333333  | -0.861164195027635666673  5.784288136375372200229  3.288077619851035668904\n  0.309036761204472681298  |  0.398320112318533301719  3.639372631810356060294  1.548228770398303223653\n  0.539357840802981787532  | -0.091089566215517606959  0                        0\n  0.1                      |  0                        0                        0\n  1                        | -1.045948959408833060950  0.930327845415626983292  1.779509594317081024461\n ------------------------------------------------------------------------------------------------------\n                           |  0.04                     0                        0.189237478148923490158\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  |\n  0.882527661964732346425  |\n  0.642615758240322548157  |\n  0.357384241759677451842  | -0.327769124164018874147\n  0.117472338035267653574  | -0.078294271035167077755 -0.114503299361098912184\n  0.833333333333333333333  | -2.386339050931363840134 -3.254793424836439186545 -2.163435416864229823539\n  0.309036761204472681298  | -2.122217147040537160260 -1.583503985453261727133 -1.715616082859362649220\n  0.539357840802981787532  |  0                        0                        0\n  0.1                      |  0                        0                        0\n  1                        |  0.1                     -0.282547569539044081612 -0.159327350119972549169\n ------------------------------------------------------------------------------------------------------\n                           |  0.277429188517743176508  0.277429188517743176508  0.189237478148923490158\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  |\n  0.882527661964732346425  |\n  0.642615758240322548157  |\n  0.357384241759677451842  |\n  0.117472338035267653574  |\n  0.833333333333333333333  |\n  0.309036761204472681298  | -0.024403640575012745213\n  0.539357840802981787532  |  0.091089566215517606959  0.777333643644968233538\n  0.1                      |  0                        0                        0.157178665799771163367\n  1                        | -0.145515894647001510860 -0.259111214548322744512 -0.342758159847189839942 -0.675\n -------------------------------------------------------------------------------------------------------------\n                           | -0.04                    -0.05                    -0.033333333333333333333 -0.025\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  |\n  0.882527661964732346425  |\n  0.642615758240322548157  |\n  0.357384241759677451842  |\n  0.117472338035267653574  |\n  0.833333333333333333333  |\n  0.309036761204472681298  |\n  0.539357840802981787532  |\n  0.1                      |\n  1                        |\n ---------------------------------------------------\n                           | 0.033333333333333333333 Bibliography [1] A family of embedded Runge-Kutta formulae , Dormand, J. R., Prince, P. J. (1980), Journal of Computational and\n Applied Mathematics 6 (1): 19–26, doi:10.1016/0771-050X(80)90013-3. [2] A New Embedded Pair of Runge-Kutta Formulas of orders 5 and 6 , M. Calvo, J.I. Montijano, L. Randez, Computers & Mathematics\n with Applications, Volume 20, Issue 1, 1990, Pages 15–24, ISSN 0898-1221, http://dx.doi.org/10.1016/0898-1221(90)90064-Q. [3] A variable order Runge-Kutta method for initial value problems with rapidly varying right-hand sides , J. R. Cash,\n A. H. Karp, ACM Transactions on Mathematical Software, vol. 16,  pp. 201–222, 1990, doi:10.1145/79505.79507. [4] A tenth-order Runge-Kutta method with error estimate , Feagin, T., Proceedings of the IAENG Conf. on Scientific\n Computing. 2007. Used By module~~foodie_integrator_emd_runge_kutta~~UsedByGraph module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie foodie module~foodie_integrator_emd_runge_kutta->module~foodie program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d->program~integrate_euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: emd_runge_kutta_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), public :: tolerance = 0._R_P Tolerance on the local truncation error. real(kind=R_P), public :: pp1_inv = 0._R_P 1/(p+1) where p is the accuracy order of the lower accurate scheme of the pair. integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:,:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Finalizations Procedures final :: finalize Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. procedure, private, pass(self) :: new_Dt Compute new estimation of the time step Dt. Description FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. Subroutines private elementalsubroutine init (self, stages, tolerance) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. real(kind=R_P), intent(in), optional :: tolerance Tolerance on the local truncation error (default 0.01). Description Create the actual RK integrator: initialize the Butcher' table coefficients. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destroy the integrator. private subroutine integrate (self, U, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(inout) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit embedded Runge-Kutta scheme. private elementalsubroutine new_Dt (self, error, Dt) Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Integrator. real(kind=R_P), intent(in) :: error Local truncation error estimation. real(kind=R_P), intent(inout) :: Dt Time step. Description Compute new estimation of the time step Dt. private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object.","tags":"","loc":"module/foodie_integrator_emd_runge_kutta.html","title":"foodie_integrator_emd_runge_kutta – Shu-Osher-shock-tube-problem"},{"text":"Uses: foodie_kinds foodie_adt_integrand foodie_integrator_adams_bashforth foodie_integrator_adams_moulton module~~foodie_integrator_adams_bashforth_moulton~~UsesGraph module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton var panmodulefoodie_integrator_adams_bashforth_moultonUsesGraph = svgPanZoom('#modulefoodie_integrator_adams_bashforth_moultonUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order\n accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Bashforth-Moulton class scheme implemented is: predictor  U&#94;{n+N_s&#94;p} = U&#94;{n+N_s&#94;p-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s&#94;p}{ b_s&#94;p \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  corrector  U&#94;{n+N_s&#94;c} = U&#94;{n+N_s&#94;c-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s&#94;c}{ b_s&#94;c \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } \\right]  where N_s&#94;p is the number of previous steps considered for the predictor and N_s&#94;c is the number of previous steps\nconsidered for the corrector. Note The value of \\Delta t must be provided, it not being computed by the integrator. The coefficients b_s&#94;{p,c} define the actual scheme, that is selected accordingly to the number of steps used. The predictor and corrector schemes should have the same formal order of accuracy, thus N_s&#94;p=N_s&#94;c+1\n should hold. Currently, the following schemes are available: P=AB(1)-C=AM(0) step, Explicit/Implicit Farward/Backward Euler, 1st order This scheme is TVD and reverts to Explicit/Implicit Farward/Backward Euler, it being 1st order.\n The b coefficient is:\n b&#94;p = \\left[b_1\\right] = \\left[1\\right]\n b&#94;c = \\left[b_0\\right] = \\left[1\\right]\n The scheme is:\n  U&#94;{n+1,p} = U&#94;{n} + \\Delta t R(t&#94;{n},U&#94;{n}) \n  U&#94;{n+1,c} = U&#94;{n} + \\Delta t R(t&#94;{n+1},U&#94;{n+1,p})  P=AB(2)-C=AM(1) steps This scheme is 2nd order.\n The b coefficients are:\n b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right]\n b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2} & \\frac{1}{2} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+2,p} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right] \n  U&#94;{n+2,c} = U&#94;{n+1} +\\Delta t \\left[ \\frac{1}{2} R(t&#94;{n+2,p}, U&#94;{n+2})+\\frac{1}{2} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  P=AB(3)-C=AM(2) steps This scheme is 3rd order.\n The b coefficients are:\n b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right]\n b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{12} & \\frac{2}{3} & \\frac{5}{12} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+3,p} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1})\n +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right] \n  U&#94;{n+3,c} = U&#94;{n+2} +\\Delta t \\left[ \\frac{5}{12}R(t&#94;{n+3}, U&#94;{n+3,p}) + \\frac{2}{3}R(t&#94;{n+2}, U&#94;{n+2})\n -\\frac{1}{12} R(t&#94;{n+1}, U&#94;{n+1})  \\right]  P=AB(4)-C=AM(3) steps This scheme is 4th order.\n The b coefficients are:\n b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 & b_4 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} -\\frac{9}{24} & \\frac{37}{24} & -\\frac{59}{24} & \\frac{55}{24} \\end{array}} \\right]\n b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 & b_3 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{24} & -\\frac{5}{24} & \\frac{19}{24} & \\frac{9}{24} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+4,p} = U&#94;{n+3} +\\Delta t \\left[ \\frac{55}{24}R(t&#94;{n+3}, U&#94;{n+3}) - \\frac{59}{24}R(t&#94;{n+2}, U&#94;{n+2})\n +\\frac{37}{24} R(t&#94;{n+1}, U&#94;{n+1}) - \\frac{9}{24} R(t&#94;{n}, U&#94;{n}) \\right] \n  U&#94;{n+4,c} = U&#94;{n+3} +\\Delta t \\left[ \\frac{9}{24}R(t&#94;{n+4}, U&#94;{n+4,p}) + \\frac{19}{24}R(t&#94;{n+3}, U&#94;{n+3})\n -\\frac{5}{24} R(t&#94;{n+2}, U&#94;{n+2}) + \\frac{1}{24} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  Bibliography Used By module~~foodie_integrator_adams_bashforth_moulton~~UsedByGraph module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~type_euler_1d->program~integrate_euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: adams_bashforth_moulton_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = -1 Number of time steps. type( adams_bashforth_integrator ), private :: predictor Predictor solver. type( adams_moulton_integrator ), private :: corrector Corrector solver. Finalizations Procedures final :: finalize Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. Description FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. Subroutines private elementalsubroutine init (self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth-Moulton integrator: initialize the b coefficients. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. Description Destroy the integrator. private subroutine integrate (self, U, previous, Dt, t, iterations) Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(in) :: self Actual ABM integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations of AM scheme. Description Integrate field with Adams-Bashforth-Moulton class scheme. private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. Description Finalize object.","tags":"","loc":"module/foodie_integrator_adams_bashforth_moulton.html","title":"foodie_integrator_adams_bashforth_moulton – Shu-Osher-shock-tube-problem"},{"text":"Uses: type_weno_interpolator type_weno_interpolator_upwind module~~wenoof~~UsesGraph module~wenoof wenoof module~type_weno_interpolator_upwind type_weno_interpolator_upwind module~type_weno_interpolator_upwind->module~wenoof module~type_weno_interpolator type_weno_interpolator module~type_weno_interpolator->module~wenoof module~type_weno_interpolator->module~type_weno_interpolator_upwind module~wenoof_kinds wenoof_kinds module~wenoof_kinds->module~type_weno_interpolator_upwind module~wenoof_kinds->module~type_weno_interpolator Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. WenOOF, WENO interpolation Object Oriented Fortran library Used By module~~wenoof~~UsedByGraph module~wenoof wenoof module~type_euler_1d type_euler_1D module~wenoof->module~type_euler_1d program~integrate_euler_1d integrate_euler_1D module~type_euler_1d->program~integrate_euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: weno_factory Type-Bound Procedures procedure, public, nopass :: create Description WENO factory aimed to create and return a concrete WENO interpolator to the client code without exposing the concrete\n interpolators classes. Subroutines private subroutine create (constructor, interpolator) Arguments Type Intent Optional Attributes Name class( weno_constructor ), intent(in) :: constructor The concrete WENO constructor selected by client code. class( weno_interpolator ), intent(out), allocatable :: interpolator The concrete WENO interpolator. Description Create and return a concrete WENO interpolator object being an extension of the abstract weno_interpolator type.","tags":"","loc":"module/wenoof.html","title":"wenoof – Shu-Osher-shock-tube-problem"},{"text":"WenOOF kinds: definition of reals and integer kind parameters of WenOOF library. Used By module~~wenoof_kinds~~UsedByGraph module~wenoof_kinds wenoof_kinds module~type_weno_interpolator_upwind type_weno_interpolator_upwind module~wenoof_kinds->module~type_weno_interpolator_upwind module~type_weno_interpolator type_weno_interpolator module~wenoof_kinds->module~type_weno_interpolator module~wenoof wenoof module~type_weno_interpolator_upwind->module~wenoof module~type_weno_interpolator->module~type_weno_interpolator_upwind module~type_weno_interpolator->module~wenoof module~type_euler_1d type_euler_1D module~wenoof->module~type_euler_1d program~integrate_euler_1d integrate_euler_1D module~type_euler_1d->program~integrate_euler_1d var panmodulewenoof_kindsUsedByGraph = svgPanZoom('#modulewenoof_kindsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: R8P = selected_real_kind(15,307) 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6,37) 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision.","tags":"","loc":"module/wenoof_kinds.html","title":"wenoof_kinds – Shu-Osher-shock-tube-problem"},{"text":"Uses: wenoof_kinds module~~type_weno_interpolator~~UsesGraph module~type_weno_interpolator type_weno_interpolator module~wenoof_kinds wenoof_kinds module~wenoof_kinds->module~type_weno_interpolator Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract WENO interpolator object, Used By module~~type_weno_interpolator~~UsedByGraph module~type_weno_interpolator type_weno_interpolator module~type_weno_interpolator_upwind type_weno_interpolator_upwind module~type_weno_interpolator->module~type_weno_interpolator_upwind module~wenoof wenoof module~type_weno_interpolator->module~wenoof module~type_weno_interpolator_upwind->module~wenoof module~type_euler_1d type_euler_1D module~wenoof->module~type_euler_1d program~integrate_euler_1d integrate_euler_1D module~type_euler_1d->program~integrate_euler_1d var panmoduletype_weno_interpolatorUsedByGraph = svgPanZoom('#moduletype_weno_interpolatorUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private elementalsubroutine abstract_destructor (self) Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(inout) :: self WENO interpolator. Description Destoy a WENO interpolator. abstract interface private subroutine abstract_constructor (self, constructor) Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(inout) :: self WENO interpolator. class( weno_constructor ), intent(in) :: constructor WENO constructor. Description Create a WENO interpolator. abstract interface private puresubroutine abstract_description (self, string) Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(in) :: self WENO interpolator. character(len=:), intent(out), allocatable :: string String returned. Description Return a string describing a WENO interpolator. abstract interface private puresubroutine abstract_interpolate (self, S, stencil, location, interpolation) Arguments Type Intent Optional Attributes Name class( weno_interpolator ), intent(in) :: self WENO interpolator. integer(kind=I_P), intent(in) :: S Number of stencils used. real(kind=R_P), intent(in) :: stencil (1:,1-S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. character(len=*), intent(in) :: location Location of interpolated value(s): central, left, right, both. real(kind=R_P), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Description Interpolate the stecil input values computing the actual interpolation. Derived Types type, public, abstract :: weno_constructor Description Abstract type used for create new concrete WENO interpolators. type, public, abstract :: weno_interpolator Type-Bound Procedures procedure(abstract_destructor), public, pass(self), deferred :: destroy procedure(abstract_constructor), public, pass(self), deferred :: create procedure(abstract_description), public, pass(self), deferred :: description procedure(abstract_interpolate), public, pass(self), deferred :: interpolate Description WENO interpolator object.","tags":"","loc":"module/type_weno_interpolator.html","title":"type_weno_interpolator – Shu-Osher-shock-tube-problem"},{"text":"Uses: wenoof_kinds type_weno_interpolator module~~type_weno_interpolator_upwind~~UsesGraph module~type_weno_interpolator_upwind type_weno_interpolator_upwind module~wenoof_kinds wenoof_kinds module~wenoof_kinds->module~type_weno_interpolator_upwind module~type_weno_interpolator type_weno_interpolator module~wenoof_kinds->module~type_weno_interpolator module~type_weno_interpolator->module~type_weno_interpolator_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module providing upwind biased WENO interpolator object and constructor, Note The provided WENO interpolator implements the Efficient Implementation of Weighted ENO Schemes ,\n Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130. Used By module~~type_weno_interpolator_upwind~~UsedByGraph module~type_weno_interpolator_upwind type_weno_interpolator_upwind module~wenoof wenoof module~type_weno_interpolator_upwind->module~wenoof module~type_euler_1d type_euler_1D module~wenoof->module~type_euler_1d program~integrate_euler_1d integrate_euler_1D module~type_euler_1d->program~integrate_euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface weno_constructor_upwind private elementalfunction weno_constructor_upwind_init (S, eps) result(constructor) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: S Maximum stencils dimension. real(kind=R_P), intent(in), optional :: eps Parameter for avoiding divided by zero when computing smoothness indicators. Return Value type( weno_constructor_upwind ) WENO constructor. Description Create (initialize) the WENO interpolator. Derived Types type, public, extends(weno_constructor) :: weno_constructor_upwind Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0 Stencils dimension. real(kind=R_P), public :: eps = 10._R_P**(-6) Parameter for avoiding divided by zero when computing smoothness indicators. Constructor private elemental function weno_constructor_upwind_init (S, eps) Create (initialize) the WENO interpolator. Description Upwind biased WENO interpolator constructor, type, public, extends(weno_interpolator) :: weno_interpolator_upwind Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: S = 0_I_P Stencil dimension. real(kind=R_P), private :: eps = 0._R_P Parameter for avoiding divided by zero when computing smoothness indicators. real(kind=R_P), private, allocatable :: weights_opt (:,:) Optimal weights                    [1:2,0:S-1]. real(kind=R_P), private, allocatable :: poly_coef (:,:,:) Polynomials coefficients           [1:2,0:S-1,0:S-1]. real(kind=R_P), private, allocatable :: smooth_coef (:,:,:) Smoothness indicators coefficients [0:S-1,0:S-1,0:S-1]. Finalizations Procedures final :: finalize Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy procedure, public, pass(self) :: create procedure, public, pass(self) :: description procedure, public, pass(self) :: interpolate generic, public :: assignment(=) => assign_interpolator Overloading = assignament. procedure, private, pass(lhs) :: assign_interpolator Assignament operator. Description Upwind biased WENO interpolator object, Functions private elementalfunction weno_constructor_upwind_init (S, eps) result(constructor) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: S Maximum stencils dimension. real(kind=R_P), intent(in), optional :: eps Parameter for avoiding divided by zero when computing smoothness indicators. Return Value type( weno_constructor_upwind ) WENO constructor. Description Create (initialize) the WENO interpolator. Subroutines private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(inout) :: self WENO interpolator. Description Destoy the WENO interpolator. private subroutine create (self, constructor) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(inout) :: self WENO interpolator. class( weno_constructor ), intent(in) :: constructor WENO constructor. Description Create the WENO interpolator. private puresubroutine description (self, string) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(in) :: self WENO interpolator. character(len=:), intent(out), allocatable :: string String returned. Description Return a string describing the WENO interpolator. private puresubroutine interpolate (self, S, stencil, location, interpolation) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(in) :: self WENO interpolator. integer, intent(in) :: S Number of stencils actually used. real(kind=R_P), intent(in) :: stencil (1:,1-S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. character(len=*), intent(in) :: location Location of interpolated value(s): left, right, both. real(kind=R_P), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Description Interpolate the stecil input values computing the actual interpolation. private puresubroutine assign_interpolator (lhs, rhs) Arguments Type Intent Optional Attributes Name class( weno_interpolator_upwind ), intent(inout) :: lhs Left hand side. class( weno_interpolator ), intent(in) :: rhs Right hand side. Description Assign one interpolator to another. private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( weno_interpolator_upwind ), intent(inout) :: self WENO interpolator. Description Finalize object.","tags":"","loc":"module/type_weno_interpolator_upwind.html","title":"type_weno_interpolator_upwind – Shu-Osher-shock-tube-problem"},{"text":"Uses: iso_fortran_env module~~pyplot_module~~UsesGraph module~pyplot_module pyplot_module iso_fortran_env iso_fortran_env iso_fortran_env->module~pyplot_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~pyplot_module~~UsedByGraph module~pyplot_module pyplot_module program~integrate_euler_1d integrate_euler_1D module~pyplot_module->program~integrate_euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, private, parameter :: wp = real64 character(len=*), private, parameter :: tmp_file = 'pyplot_module_temp_1234567890.py' character(len=*), private, parameter :: python_exe = 'python' character(len=*), private, parameter :: int_fmt = '(I10)' integer, private, parameter :: max_int_len = 10 character(len=*), private, parameter :: real_fmt = '(E30.16)' integer, private, parameter :: max_real_len = 30 Derived Types type, public :: pyplot Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: str logical, private :: show_legend = .false. logical, private :: use_numpy = .true. logical, private :: mplot3d = .false. Type-Bound Procedures procedure, public :: initialize procedure, public :: add_plot procedure, public :: add_3d_plot procedure, public :: add_bar procedure, public :: savefig procedure, public :: destroy procedure, public :: execute procedure, public :: add_str Subroutines private subroutine destroy (me) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me Description Author Jacob Williams private subroutine add_str (me, str) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in) :: str Description Author Jacob Williams private subroutine initialize (me, grid, xlabel, ylabel, zlabel, title, legend, use_numpy, figsize, font_size, axes_labelsize, xtick_labelsize, ytick_labelsize, ztick_labelsize, legend_fontsize, mplot3d) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me logical, intent(in), optional :: grid character(len=*), intent(in), optional :: xlabel character(len=*), intent(in), optional :: ylabel character(len=*), intent(in), optional :: zlabel character(len=*), intent(in), optional :: title logical, intent(in), optional :: legend logical, intent(in), optional :: use_numpy integer, intent(in), optional dimension(2) :: figsize integer, intent(in), optional :: font_size integer, intent(in), optional :: axes_labelsize integer, intent(in), optional :: xtick_labelsize integer, intent(in), optional :: ytick_labelsize integer, intent(in), optional :: ztick_labelsize integer, intent(in), optional :: legend_fontsize logical, intent(in), optional :: mplot3d Description Author Jacob Williams private subroutine add_plot (me, x, y, label, linestyle, markersize, linewidth) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: markersize integer, intent(in), optional :: linewidth Description Author Jacob Williams private subroutine add_3d_plot (me, x, y, z, label, linestyle, markersize, linewidth) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: markersize integer, intent(in), optional :: linewidth Description Author Jacob Williams private subroutine add_bar (me, left, height, label, width, bottom, color) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: left real(kind=wp), intent(in), dimension(:) :: height character(len=*), intent(in) :: label real(kind=wp), intent(in), optional dimension(:) :: width real(kind=wp), intent(in), optional dimension(:) :: bottom character(len=*), intent(in), optional :: color Description Author Jacob Williams private subroutine optional_int_to_string (int_value, string_value, default_value) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: int_value character(len=*), intent(out) :: string_value character(len=*), intent(in) :: default_value Description Author Jacob Williams private subroutine integer_to_string (i, s) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: i character(len=*), intent(out) :: s Description Author Jacob Williams private subroutine vec_to_string (v, str, use_numpy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: v character(len=:), intent(out), allocatable :: str logical, intent(in) :: use_numpy Description Author Jacob Williams private subroutine execute (me, pyfile) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in), optional :: pyfile Description Author Jacob Williams private subroutine savefig (me, figfile, pyfile) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in) :: figfile character(len=*), intent(in), optional :: pyfile Description Author Jacob Williams","tags":"","loc":"module/pyplot_module.html","title":"pyplot_module – Shu-Osher-shock-tube-problem"},{"text":"Uses: IR_Precision iso_fortran_env module~~data_type_command_line_interface~~UsesGraph module~data_type_command_line_interface Data_Type_Command_Line_Interface IR_Precision IR_Precision IR_Precision->module~data_type_command_line_interface iso_fortran_env iso_fortran_env iso_fortran_env->module~data_type_command_line_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FLAP, Fortran command Line Arguments Parser for poor people ChangeLog Used By module~~data_type_command_line_interface~~UsedByGraph module~data_type_command_line_interface Data_Type_Command_Line_Interface program~integrate_euler_1d integrate_euler_1D module~data_type_command_line_interface->program~integrate_euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), private, parameter :: max_val_len = 1000 Maximum number of characters of CLA value. character(len=*), private, parameter :: action_store = 'STORE' CLA that stores value (if invoked a value must be passed). character(len=*), private, parameter :: action_store_star = 'STORE*' CLA that stores value or revert on default is invoked alone. character(len=*), private, parameter :: action_store_true = 'STORE_TRUE' CLA that stores .true. without the necessity of a value. character(len=*), private, parameter :: action_store_false = 'STORE_FALSE' CLA that stores .false. without the necessity of a value. character(len=*), private, parameter :: action_print_help = 'PRINT_HELP' CLA that print help message. character(len=*), private, parameter :: action_print_vers = 'PRINT_VERSION' CLA that print version. character(len=*), private, parameter :: args_sep = '||!||' Arguments separator for multiple valued (list) CLA. integer(kind=I4P), private, parameter :: error_cla_optional_no_def = 1 Optional CLA without default value. integer(kind=I4P), private, parameter :: error_cla_required_m_exclude = 2 Required CLA cannot exclude others. integer(kind=I4P), private, parameter :: error_cla_positional_m_exclude = 3 Positional CLA cannot exclude others. integer(kind=I4P), private, parameter :: error_cla_named_no_name = 4 Named CLA without switch name. integer(kind=I4P), private, parameter :: error_cla_positional_no_position = 5 Positional CLA without position. integer(kind=I4P), private, parameter :: error_cla_positional_no_store = 6 Positional CLA without action_store. integer(kind=I4P), private, parameter :: error_cla_not_in_choices = 7 CLA value out of a specified choices. integer(kind=I4P), private, parameter :: error_cla_missing_required = 8 Missing required CLA. integer(kind=I4P), private, parameter :: error_cla_m_exclude = 9 Two mutually exclusive CLAs have been passed. integer(kind=I4P), private, parameter :: error_cla_casting_logical = 10 Error casting CLA value to logical type. integer(kind=I4P), private, parameter :: error_cla_choices_logical = 11 Error adding choices check for CLA value of logical type. integer(kind=I4P), private, parameter :: error_cla_no_list = 12 Actual CLA is not list-values. integer(kind=I4P), private, parameter :: error_cla_nargs_insufficient = 13 Multi-valued CLA with insufficient arguments. integer(kind=I4P), private, parameter :: error_cla_value_missing = 14 Missing value of CLA. integer(kind=I4P), private, parameter :: error_cla_unknown = 15 Unknown CLA (switch name). integer(kind=I4P), private, parameter :: error_cla_envvar_positional = 16 Envvar not allowed for positional CLA. integer(kind=I4P), private, parameter :: error_cla_envvar_not_store = 17 Envvar not allowed action different from store; integer(kind=I4P), private, parameter :: error_cla_envvar_nargs = 18 Envvar not allowed for list-values CLA. integer(kind=I4P), private, parameter :: error_cla_store_star_positional = 19 Action store* not allowed for positional CLA. integer(kind=I4P), private, parameter :: error_cla_store_star_nargs = 20 Action store* not allowed for list-values CLA. integer(kind=I4P), private, parameter :: error_cla_store_star_envvar = 21 Action store* not allowed for environment variable CLA. integer(kind=I4P), private, parameter :: error_cla_action_unknown = 22 Unknown CLA (switch name). integer(kind=I4P), private, parameter :: error_clasg_consistency = 23 CLAs group consistency error. integer(kind=I4P), private, parameter :: error_clasg_m_exclude = 24 Two mutually exclusive CLAs group have been called. integer(kind=I4P), private, parameter :: error_cli_missing_cla = 25 CLA not found in CLI. integer(kind=I4P), private, parameter :: error_cli_missing_group = 26 Group not found in CLI. integer(kind=I4P), private, parameter :: error_cli_missing_selection_cla = 27 CLA selection in CLI failing. integer(kind=I4P), private, parameter :: error_cli_too_few_clas = 28 Insufficient arguments for CLI. integer(kind=I4P), private, parameter :: status_clasg_print_v = -1 Print version status. integer(kind=I4P), private, parameter :: status_clasg_print_h = -2 Print help status. Derived Types type, private, abstract :: Type_Object Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), private, allocatable :: help Help message. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilog message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). integer(kind=I4P), public :: error = 0_I4P Error traping flag. Type-Bound Procedures procedure, public :: free_object Free dynamic memory. procedure, public :: errored Trig error occurence and print meaningful message. procedure, public :: print_version Print version. procedure, public :: assign_object Assignment overloading. type, private, extends( Type_Object ) :: Type_Command_Line_Argument Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: switch Switch name. character(len=:), private, allocatable :: switch_ab Abbreviated switch name. logical, private :: required = .false. Flag for set required argument. logical, private :: positional = .false. Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), private :: position = 0_I4P Position of positional CLA. logical, private :: passed = .false. Flag for checking if CLA has been passed to CLI. logical, private :: hidden = .false. Flag for hiding CLA, thus it does not compare into help. character(len=:), private, allocatable :: act CLA value action. character(len=:), private, allocatable :: def Default value. character(len=:), private, allocatable :: nargs Number of arguments consumed by CLA. character(len=:), private, allocatable :: choices List (comma separated) of allowable values for the argument. character(len=:), private, allocatable :: val CLA value. character(len=:), private, allocatable :: envvar Environment variable from which take value. Finalizations Procedures final :: finalize_cla Free dynamic memory when finalizing. Type-Bound Procedures procedure, public :: free => free_cla Free dynamic memory. procedure, public :: check => check_cla Check CLA data consistency. procedure, public :: check_choices => check_choices_cla Check if CLA value is in allowed choices. procedure, public :: check_list_size => check_list_size_cla Check CLA multiple values list size consistency. generic, public :: get => get_cla, get_cla_list Get CLA value(s). generic, public :: get_varying => get_cla_list_varying_R8P, get_cla_list_varying_R4P, get_cla_list_varying_I8P, get_cla_list_varying_I4P, get_cla_list_varying_I2P, get_cla_list_varying_I1P, get_cla_list_varying_logical, get_cla_list_varying_char Get CLA value(s) from CLAs list parsedi, varying size list. procedure, public :: usage => usage_cla Get correct CLA usage. procedure, public :: signature => signature_cla Get CLA signature for adding to CLI one. procedure, private :: get_cla Get CLA (single) value from CLAs list parsed. procedure, private :: get_cla_list Get CLA multiple values from CLAs list parsed. procedure, private :: get_cla_list_varying_R8P Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure, private :: get_cla_list_varying_R4P Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure, private :: get_cla_list_varying_I8P Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure, private :: get_cla_list_varying_I4P Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure, private :: get_cla_list_varying_I2P Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure, private :: get_cla_list_varying_I1P Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure, private :: get_cla_list_varying_logical Get CLA multiple values from CLAs list parsed, varying size, bool. procedure, private :: get_cla_list_varying_char Get CLA multiple values from CLAs list parsed, varying size, char. procedure, private :: assign_cla CLA assignment overloading. generic, private :: assignment(=) => assign_cla CLA assignment overloading. Description Command line arguments (CLA). type, private, extends( Type_Object ) :: Type_Command_Line_Arguments_Group Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: group Group name (command). integer(kind=I4P), private :: Na = 0_I4P Number of CLA. integer(kind=I4P), private :: Na_required = 0_I4P Number of command line arguments that CLI requires. integer(kind=I4P), private :: Na_optional = 0_I4P Number of command line arguments that are optional for CLI. type( Type_Command_Line_Argument ), private, allocatable :: cla (:) CLA list [1:Na]. logical, private :: called = .false. Flag for checking if CLAs group has been passed to CLI. Finalizations Procedures final :: finalize_clasg Free dynamic memory when finalizing. Type-Bound Procedures procedure, public :: free => free_clasg Free dynamic memory. procedure, public :: check => check_clasg Check CLAs data consistency. procedure, public :: check_required => check_required_clasg Check if required CLAs are passed. procedure, public :: check_m_exclusive => check_m_exclusive_clasg Check if two mutually exclusive CLAs have been passed. procedure, public :: add => add_cla_clasg Add CLA to CLAs group. procedure, public :: passed => passed_clasg Check if a CLA has been passed. procedure, public :: defined => defined_clasg Check if a CLA has been defined. procedure, public :: parse => parse_clasg Parse CLAs group arguments. procedure, public :: usage => usage_clasg Get correct CLAs group usage. procedure, public :: signature => signature_clasg Get CLAs group signature for adding to the CLI one. procedure, private :: assign_clasg CLAs group assignment overloading. generic, private :: assignment(=) => assign_clasg CLAs group assignment overloading. Description Group of CLAs for building nested commands.\n Free dynamic memory when finalizing. type, public, extends( Type_Object ) :: Type_Command_Line_Interface Components Type Visibility Attributes Name Initial type( Type_Command_Line_Arguments_Group ), private, allocatable :: clasg (:) CLA list [1:Na]. character(len=512), private, allocatable :: args (:) Actually passed command line arguments. character(len=512), private, allocatable :: examples (:) Examples of correct usage. logical, private :: disable_hv = .false. Disable automatic 'help' and 'version' CLAs. Finalizations Procedures final :: finalize Free dynamic memory when finalizing. Type-Bound Procedures procedure, public :: free Free dynamic memory. procedure, public :: init Initialize CLI. procedure, public :: add_group Add CLAs group CLI. procedure, public :: add Add CLA to CLI. procedure, public :: passed Check if a CLA has been passed. procedure, public :: defined Check if a CLA has been defined. procedure, public :: defined_group Check if a CLAs group has been defined. procedure, public :: set_mutually_exclusive_groups Set two CLAs group as mutually exclusive. procedure, public :: run_command => called_group Check if a CLAs group has been runned. procedure, public :: parse Parse Command Line Interfaces. generic, public :: get => get_cla_cli, get_cla_list_cli Get CLA value(s) from CLAs list parsed. generic, public :: get_varying => get_cla_list_varying_R8P_cli, get_cla_list_varying_R4P_cli, get_cla_list_varying_I8P_cli, get_cla_list_varying_I4P_cli, get_cla_list_varying_I2P_cli, get_cla_list_varying_I1P_cli, get_cla_list_varying_logical_cli, get_cla_list_varying_char_cli Get CLA value(s) from CLAs list parsedi, varying size list. procedure, public :: usage Get CLI usage. procedure, public :: signature Get CLI signature. procedure, public :: print_usage Print correct usage of CLI. procedure, public :: save_man_page Save man page build on CLI. procedure, private :: check Check CLAs data consistenc. procedure, private :: check_m_exclusive Check if two mutually exclusive CLAs group have been called. procedure, private :: get_clasg_indexes Get CLAs groups indexes. generic, private :: get_args => get_args_from_string, get_args_from_invocation Get CLAs from string.\n Get CLAs from CLI invocation. procedure, private :: get_args_from_string Get CLAs from string. procedure, private :: get_args_from_invocation Get CLAs from CLI invocation. procedure, private :: get_cla_cli Get CLA (single) value from CLAs list parsed. procedure, private :: get_cla_list_cli Get CLA multiple values from CLAs list parsed. procedure, private :: get_cla_list_varying_R16P_cli Get CLA multiple values from CLAs list parsed, varying size, R16P. procedure, private :: get_cla_list_varying_R8P_cli Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure, private :: get_cla_list_varying_R4P_cli Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure, private :: get_cla_list_varying_I8P_cli Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure, private :: get_cla_list_varying_I4P_cli Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure, private :: get_cla_list_varying_I2P_cli Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure, private :: get_cla_list_varying_I1P_cli Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure, private :: get_cla_list_varying_logical_cli Get CLA multiple values from CLAs list parsed, varying size, bool. procedure, private :: get_cla_list_varying_char_cli Get CLA multiple values from CLAs list parsed, varying size, char. procedure, private :: assign_cli CLI assignment overloading. generic, private :: assignment(=) => assign_cli CLI assignment overloading. Description Command Line Interface (CLI).\n Free dynamic memory when finalizing. Functions private purefunction Upper_Case (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be converted. Return Value character(len=len(string)) Converted string. Description Convert the lower case characters of a string to upper case one. private function check_list_size_cla (cla, Nv, val, pref) result(is_ok) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I4P), intent(in) :: Nv Number of values. character(len=*), intent(in) :: val First value. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. Description Check CLA multiple values list size consistency. private function usage_cla (cla, pref) result(usage) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(in) :: cla CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Return Value character(len=:),\n  allocatable Usage string. Description Get correct CLA usage. private function signature_cla (cla) result(signd) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(in) :: cla CLA data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLA signature for adding to the CLI one. private purefunction passed_clasg (clasg, switch, position) result(passed) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Description Check if a CLA has been passed. private function defined_clasg (clasg, switch, pos) result(defined) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in) :: switch Switch name. integer(kind=I4P), intent(out), optional :: pos CLA position. Return Value logical Check if a CLA has been defined. Description Check if a CLA has been defined. private function usage_clasg (clasg, pref, no_header) result(usage) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. Return Value character(len=:),\n  allocatable Usage string. Description Get correct CLAs group usage. private function signature_clasg (clasg) result(signd) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLAs group signature for adding to the CLI one. private function passed (cli, group, switch, position) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Description Check if a CLA has been passed. private function defined_group (cli, group, g) result(defined) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. integer(kind=I4P), intent(out), optional :: g Index of group. Return Value logical Check if a CLAs group has been defined. Description Check if a CLAs group has been defined. private function called_group (cli, group) result(called) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. Return Value logical Check if a CLAs group has been runned. Description Check if a CLAs group has been runned. private function defined (cli, switch, group) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: switch Switch name. character(len=*), intent(in), optional :: group Name of group (command) of CLAs. Return Value logical Check if a CLA has been defined. Description Check if a CLA has been defined. private function usage (cli, g, pref, no_header, no_examples, no_epilog) result(usaged) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. integer(kind=I4P), intent(in) :: g Group index. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: no_examples Avoid insert examples to usage. logical, intent(in), optional :: no_epilog Avoid insert epilogue to usage. Return Value character(len=:),\n  allocatable Usage string. Description Print correct usage of CLI. private function signature (cli) result(signd) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLI signature. Subroutines private puresubroutine tokenize (strin, delimiter, toks, Nt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strin String to be tokenized. character(len=*), intent(in) :: delimiter Delimiter of tokens. character(len=len(strin)), intent(out), allocatable :: toks (:) Tokens. integer(kind=I4P), intent(out), optional :: Nt Number of tokens. Description Tokenize a string in order to parse it. private elementalsubroutine free_object (obj) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: obj Object data. Description Free dynamic memory. private subroutine errored (obj, error, pref, group, switch, val_str, log_value, a1, a2) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: obj Object data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Group name. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: val_str Value string. character(len=*), intent(in), optional :: log_value Logical value to be casted. integer(kind=I4P), intent(in), optional :: a1 integer(kind=I4P), intent(in), optional :: a2 CLAs group inconsistent indexes. Description Trig error occurence and print meaningful message. private subroutine print_version (obj, pref) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(in) :: obj Object data. character(len=*), intent(in), optional :: pref Prefixing string. Description Print version. private elementalsubroutine assign_object (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: lhs Left hand side. class( Type_Object ), intent(in) :: rhs Rigth hand side. private elementalsubroutine free_cla (cla) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. Description Free dynamic memory. private elementalsubroutine finalize_cla (cla) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. Description Free dynamic memory when finalizing. private subroutine check_cla (cla, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check CLA data consistency. private subroutine check_choices_cla (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. class(*), intent(in) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if CLA value is in allowed choices. private subroutine get_cla (cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val CLA value. Description Get CLA (single) value. private subroutine get_cla_list (cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. Description Get CLA (multiple) value. private subroutine get_cla_list_varying_R16P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R16P). private subroutine get_cla_list_varying_R8P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R8P). private subroutine get_cla_list_varying_R4P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R4P). private subroutine get_cla_list_varying_I8P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I8P). private subroutine get_cla_list_varying_I4P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I4P). private subroutine get_cla_list_varying_I2P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I2P). private subroutine get_cla_list_varying_I1P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I1P). private subroutine get_cla_list_varying_logical (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, logical. private subroutine get_cla_list_varying_char (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, character. private elementalsubroutine assign_cla (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Argument ), intent(in) :: rhs Rigth hand side. private elementalsubroutine free_clasg (clasg) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. Description Free dynamic memory. private elementalsubroutine finalize_clasg (clasg) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. Description Free dynamic memory when finalizing. private subroutine check_clasg (clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check CLA data consistency. private subroutine check_required_clasg (clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if required CLAs are passed. private subroutine check_m_exclusive_clasg (clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if two mutually exclusive CLAs have been passed. private subroutine add_cla_clasg (clasg, pref, cla) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. type( Type_Command_Line_Argument ), intent(in) :: cla CLA data. Description Add CLA to CLAs list. private subroutine parse_clasg (clasg, pref, args) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in) :: args (:) Command line arguments. Description Parse CLAs group arguments. private elementalsubroutine assign_clasg (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Arguments_Group ), intent(in) :: rhs Right hand side. private elementalsubroutine free (cli) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. Description Free dynamic memory. private elementalsubroutine finalize (cli) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. Description Free dynamic memory when finalizing. private subroutine init (cli, progname, version, help, description, license, authors, examples, epilog, disable_hv) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: progname Program name. character(len=*), intent(in), optional :: version Program version. character(len=*), intent(in), optional :: help Help message introducing the CLI usage. character(len=*), intent(in), optional :: description Detailed description message introducing the program. character(len=*), intent(in), optional :: license License description. character(len=*), intent(in), optional :: authors Authors list. character(len=*), intent(in), optional :: examples (1:) Examples of correct usage. character(len=*), intent(in), optional :: epilog Epilog message. logical, intent(in), optional :: disable_hv Disable automatic insert of 'help' and 'version' CLAs. Description Initialize CLI. private subroutine add_group (cli, help, description, exclude, group) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: help Help message. character(len=*), intent(in), optional :: description Detailed description. character(len=*), intent(in), optional :: exclude Group name of the mutually exclusive group. character(len=*), intent(in) :: group Name of the grouped CLAs. Description Add CLAs group to CLI. private subroutine set_mutually_exclusive_groups (cli, group1, group2) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in) :: group1 Name of the first grouped CLAs. character(len=*), intent(in) :: group2 Name of the second grouped CLAs. Description Set two CLAs group ad mutually exclusive. private subroutine add (cli, pref, group, group_index, switch, switch_ab, help, required, positional, position, hidden, act, def, nargs, choices, exclude, envvar, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of the grouped CLAs. integer(kind=I4P), intent(in), optional :: group_index Index of the grouped CLAs. character(len=*), intent(in), optional :: switch Switch name. character(len=*), intent(in), optional :: switch_ab Abbreviated switch name. character(len=*), intent(in), optional :: help Help message describing the CLA. logical, intent(in), optional :: required Flag for set required argument. logical, intent(in), optional :: positional Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. logical, intent(in), optional :: hidden Flag for hiding CLA, thus it does not compare into help. character(len=*), intent(in), optional :: act CLA value action. character(len=*), intent(in), optional :: def Default value. character(len=*), intent(in), optional :: nargs Number of arguments consumed by CLA. character(len=*), intent(in), optional :: choices List of allowable values for the argument. character(len=*), intent(in), optional :: exclude Switch name of the mutually exclusive CLA. character(len=*), intent(in), optional :: envvar Environment variable from which take value. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Add CLA to CLI. private subroutine check (cli, pref, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Check CLAs data consistency. private subroutine check_m_exclusive (cli, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if two mutually exclusive CLAs group have been called. private subroutine parse (cli, pref, args, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Parse Command Line Interfaces by means of a previously initialized CLAs groups list. private subroutine get_clasg_indexes (cli, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. private subroutine get_args_from_string (cli, args, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from string. private subroutine get_args_from_invocation (cli, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from CLI invocation. private subroutine get_cla_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA (single) value from CLAs list parsed. private subroutine get_cla_list_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val (1:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed. private subroutine get_cla_list_varying_R16P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). private subroutine get_cla_list_varying_R8P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). private subroutine get_cla_list_varying_R4P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). private subroutine get_cla_list_varying_I8P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). private subroutine get_cla_list_varying_I4P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). private subroutine get_cla_list_varying_I2P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). private subroutine get_cla_list_varying_I1P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). private subroutine get_cla_list_varying_logical_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, logical. private subroutine get_cla_list_varying_char_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, character. private subroutine print_usage (cli, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Description Print correct usage of CLI. private subroutine save_man_page (cli, man_file, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: man_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Save man page build on the CLI. private elementalsubroutine assign_cli (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Interface ), intent(in) :: rhs Right hand side.","tags":"","loc":"module/data_type_command_line_interface.html","title":"Data_Type_Command_Line_Interface – Shu-Osher-shock-tube-problem"},{"text":"Uses: IR_Precision type_euler_1D Data_Type_Command_Line_Interface foodie pyplot_module program~~integrate_euler_1d~~UsesGraph program~integrate_euler_1d integrate_euler_1D IR_Precision IR_Precision IR_Precision->program~integrate_euler_1d module~type_euler_1d type_euler_1D IR_Precision->module~type_euler_1d module~data_type_command_line_interface Data_Type_Command_Line_Interface IR_Precision->module~data_type_command_line_interface module~pyplot_module pyplot_module module~pyplot_module->program~integrate_euler_1d module~type_euler_1d->program~integrate_euler_1d module~foodie foodie module~foodie->program~integrate_euler_1d module~foodie->module~type_euler_1d module~data_type_command_line_interface->program~integrate_euler_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~pyplot_module iso_fortran_env->module~data_type_command_line_interface module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta iso_fortran_env->module~foodie_integrator_low_storage_runge_kutta module~wenoof wenoof module~wenoof->module~type_euler_1d module~type_weno_interpolator_upwind type_weno_interpolator_upwind module~type_weno_interpolator_upwind->module~wenoof module~type_weno_interpolator type_weno_interpolator module~type_weno_interpolator->module~wenoof module~type_weno_interpolator->module~type_weno_interpolator_upwind module~wenoof_kinds wenoof_kinds module~wenoof_kinds->module~type_weno_interpolator_upwind module~wenoof_kinds->module~type_weno_interpolator module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_moulton var panprogramintegrate_euler_1dUsesGraph = svgPanZoom('#programintegrate_euler_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODIE with the integration of Euler 1D PDEs system. Calls program~~integrate_euler_1d~~CallsGraph program~integrate_euler_1d integrate_euler_1D proc~save_time_serie save_time_serie program~integrate_euler_1d->proc~save_time_serie proc~command_line_interface command_line_interface program~integrate_euler_1d->proc~command_line_interface proc~finish finish program~integrate_euler_1d->proc~finish proc~init init program~integrate_euler_1d->proc~init str str program~integrate_euler_1d->str proc~save_time_serie->str proc~finish->proc~save_time_serie proc~finish->str proc~save_results save_results proc~finish->proc~save_results proc~init->proc~save_time_serie proc~init->str proc~save_results->str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( ls_runge_kutta_integrator ) :: rk_integrator Runge-Kutta integrator. integer, parameter :: rk_stages = 7 Runge-Kutta stages number. type(euler_1D) :: rk_stage (1:rk_stages) Runge-Kutta stages. real(kind=R_P) :: Dt Time step. real(kind=R_P) :: t Time. real(kind=R_P) :: t_final Final time. type(euler_1D) :: domain Domain of Euler equations. integer(kind=I_P) :: order Order of accuracy. real(kind=R_P), parameter :: CFL = 0.7_R_P CFL value. integer(kind=I_P), parameter :: Ns = 1 Number of differnt initial gas species. integer(kind=I_P), parameter :: Nc = Ns+2 Number of conservative variables. integer(kind=I_P), parameter :: Np = Ns+4 Number of primitive variables. integer(kind=I_P) :: Ni Number of grid cells. real(kind=R_P), allocatable :: x (:) Cell center x-abscissa values. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. integer(kind=I_P) :: steps Time steps counter. Subroutines subroutine command_line_interface () Arguments None Description Handle Command Line Interface. subroutine init () Arguments None Description Initialize the field. subroutine finish () Arguments None Description Peform after-success finishing operations. subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. subroutine save_time_serie (title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Source Code program integrate_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D , only : euler_1D use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : ls_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 7 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: Dt !< Time step. real ( R_P ) :: t !< Time. real ( R_P ) :: t_final !< Final time. type ( euler_1D ) :: domain !< Domain of Euler equations. integer ( I_P ) :: order !< Order of accuracy. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: steps !< Time steps counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call command_line_interface call init steps = 1 do while ( t < t_final ) if ( verbose ) print \"(A)\" , ' Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) Dt = domain % dt ( Nmax = 0_I_P , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt steps = steps + 1 call save_time_serie ( t = t ) enddo if ( verbose ) print \"(A)\" , ' Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) call finish stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine command_line_interface () !--------------------------------------------------------------------------------------------------------------------------------- !< Handle Command Line Interface. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. integer ( I_P ) :: error !< Error handler. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration' , & examples = [ \"euler-1D --results  \" , & \"euler-1D -r -t -v -p\" , & \"euler-1D            \" , & \"euler-1D --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--order' , help = 'Order of accuracy' , choices = '1,3,5,7' , required = . false ., act = 'store' , def = '1' , error = error ) call cli % add ( switch = '--t_final' , help = 'Final time of integration' , required = . false ., act = 'store' , def = '0.178d0' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , & def = '.false.' , error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--order' , val = order , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--t_final' , val = t_final , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine command_line_interface subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. real ( R_P ) :: rho_sin !< Sinusoidal density distribution. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 2.85_R_P Dx = 1._R_P / Ni do i = 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.12_R_P ) then initial_state (:, i ) = [ 3.857143_R_P , & ! rho(s) 2.629369_R_P , & ! u 1 0.33333_R_P , & ! p 3.857143_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else rho_sin = 1._R_P + 0.2_R_P * sin ( 8._R_P * x ( i ) * 2._R_P * pi ) initial_state (:, i ) = [ rho_sin , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p rho_sin , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = 'TRA' , BC_R = 'TRA' , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = order ) call save_time_serie ( title = 'Shu-Osher shock tube problem' , & filename = 'shu-osher-order-' // trim ( str (. true ., order )) // '-grid-' // trim ( str (. true ., Ni )) // '.dat' , & t = t ) t = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine finish () !--------------------------------------------------------------------------------------------------------------------------------- !< Peform after-success finishing operations. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'Shu-Osher shock tube problem' , & filename = 'shu-osher-order-' // trim ( str (. true ., order )) // '-grid-' // trim ( str (. true ., Ni ))) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finish subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D","tags":"","loc":"program/integrate_euler_1d.html","title":"integrate_euler_1D – Shu-Osher-shock-tube-problem"}]}